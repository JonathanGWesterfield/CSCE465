<html><head><title>15.3. PKI Trust Models</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch15lev1sec3"></a>
<h3 id="title-IDAOCPHH" class="docSection1Title">15.3. PKI Trust Models</h3>
<p class="docText">Suppose Alice wants to send an encrypted email message to Bob. She needs to securely find out Bob's public key. The PKI trust model defines where Alice gets her trust anchors, and what paths would create a legal chain from a trust anchor to the target name (&quot;Bob&quot; in this example).</p>
<a name="ch15lev2sec1"></a>
<h4 id="title-IDAZCPHH" class="docSection2Title">15.3.1. Monopoly Model</h4>
<p class="docText">In this model, the world chooses one organization, universally trusted by all companies, countries, universities, and other organizations to be the single CA for the world. The key of that one organization is embedded in all software and hardware as the PKI trust anchor. Everyone must get certificates from it. This is a wonderfully simple model, mathematically. This is the model favored by organizations hoping to be the monopolist. However, there are problems with it:</p>
<ul><li><p class="docList">There is no one universally trusted organization.</p></li><li><p class="docList">Given that all software and hardware would come preconfigured with the monopoly organization's key, it would be infeasible to ever change that key in case it were compromised, since that would involve reconfiguration of every piece of equipment and software.</p></li><li><p class="docList">It would be expensive and insecure to have a remote organization certify your key. How would they know it was you? How would you be able to securely send them your public key? Although transmission of the public key does not require secrecy, it requires integrity. Otherwise the CA could be tricked into certifying the public key as yours.</p></li><li><p class="docList">Once enough software and hardware was deployed so that it would be difficult for the world to switch organizations, the organization would have monopoly control, and could charge whatever it wanted for granting certificates.</p></li><li><p class="docList">The entire security of the world rests on that one organization never having an incompetent or corrupt employee who might be bribed or tricked into issuing bogus certificates or divulging the CA's private key.</p></li></ul>
<a name="ch15lev2sec2"></a>
<h4 id="title-IDA1DPHH" class="docSection2Title">15.3.2. Monopoly plus Registration Authorities (RAs)</h4>
<p class="docText">This model is just like &sect;<a class="docLink" href="#ch15lev2sec1">15.3.1</a> <span class="docEmphasis">Monopoly Model</span> except that the single CA chooses other organizations (known as RAs) to securely check identities and obtain and vouch for public keys. The RA then securely communicates with the CA, perhaps by sending signed email with the information that would go into the certificate, and the CA can then issue a certificate because it trusts the RA.</p>
<p class="docText">This model's advantage over the &sect;<a class="docLink" href="#ch15lev2sec1">15.3.1</a> <span class="docEmphasis">Monopoly Model</span> is that it is more convenient and secure to obtain certificates, since there are more places to go to get certified. However, all the other disadvantages of the monopoly model apply.</p>
<p class="docText">RAs can be added to any of the models we'll talk about. Some people believe that it is better for their organization to run an RA and leave the operation of the CA to an organization more expert at what it takes to be a CA. However, in practice, the CA just rubber-stamps whatever information is verified by the RAs. It is the RA that has to do the security-sensitive operations of ensuring the proper mapping of name to key. The CA might be better able to provide a tamper-proof audit trail of certificates it has signed.</p>
<a name="ch15lev2sec3"></a>
<h4 id="title-IDA3EPHH" class="docSection2Title">15.3.3. Delegated CAs</h4>
<p class="docText">In this model the trust anchor CA can issue certificates to other CAs, vouching for their keys and vouching for their trustworthiness as CAs. Users can then obtain certificates from one of the delegated CAs instead of having to go to the trust anchor CA.</p>
<p class="docText">The difference between a delegated CA and an RA is whether Alice sees a chain of certificates from a trust anchor to Bob's name, or sees a single certificate. Assuming a monopoly trust anchor, this model has security and operational properties similar to &sect;<a class="docLink" href="#ch15lev2sec2">15.3.2</a> <span class="docEmphasis">Monopoly plus Registration Authorities (RAs)</span>. Chains of certificates through delegated CAs can be incorporated into any of the models we'll discuss.</p>
<a name="ch15lev2sec4"></a>
<h4 id="title-IDAVFPHH" class="docSection2Title">15.3.4. Oligarchy</h4>
<p class="docText">This is the model commonly used in browsers. In this model, instead of having products preconfigured with a single key, the products come configured with many trust anchors, and a certificate issued by any one of them is accepted. Usually in such a model it is possible for the user to examine and edit the list of trust anchors, adding or deleting trust anchors. It has the advantage over the monopoly models that the organizations chosen as trust anchors will be in competition with each other, so the world might be spared monopoly pricing. However it is likely to be even <span class="docEmphasis">less</span> secure than the monopoly model:</p>
<ul><li><p class="docList">In the monopoly model, if the single organization ever has a corrupt or incompetent employee, the entire security of the world is at risk. In the oligarchy model, though, <span class="docEmphasis">any</span> of the trust anchor organizations getting compromised will put the security of the world at risk. It is of course far more likely that at least one of <span class="docEmphasis">n</span> organizations will wind up with a misused key when <span class="docEmphasis">n</span> is bigger than 1.</p></li><li><p class="docList">The trust anchor organizations are trusted by the product vendor, not by the user. Why should the vendor decide whom the user should trust? Also, how does the vendor choose which organizations to trust? You'd like to assume that there is some elaborate procedure by which the vendor evaluates the trustworthiness of the organization before adding its key to the trust anchor set. The policy is at the discretion of the vendor, and some vendors have chosen to include any organization willing to pay for the privilege of being included in the preconfigured trust anchor set.</p></li><li><p class="docList">It might be easy to trick a naive user into adding a bogus trust anchor into the set. This depends on the implementation. One could imagine an implementation that, upon seeing a certificate signed by an organization that wasn't in the set, would show the user a pop-up box saying, <span class="docEmphasis">Warning. This was signed by an unknown CA. Would you like to accept the certificate anyway?</span> (The user will almost certainly say <span class="docEmphasis">OK</span>.) <span class="docEmphasis">Would you like to always accept this certificate without being asked in the future?</span> (<span class="docEmphasis">OK.</span>) <span class="docEmphasis">Would you like to always accept certificates from the CA that issued that certificate?</span> (<span class="docEmphasis">OK.</span>) <span class="docEmphasis">Would you like to always accept certificates from any CA?</span> (<span class="docEmphasis">OK.</span>) <span class="docEmphasis">Since you're willing to trust anyone for anything, would you like me to make random edits to the files on your hard drive without bothering you with a pop-up box?</span> <a name="iddle1379"></a>(<span class="docEmphasis">OK.</span>) (You might want to see how many of these questions your browser asks, and it would be an interesting psychology exercise to see how outrageous you can be before a user stops clicking <span class="docEmphasis">OK</span>.) Note that if a user is sufficiently sophisticated and careful, she can ask for information about the certificate before clicking <span class="docEmphasis">OK</span> to accept it. She will be informed of the name of the signer, say <span class="docEmphRomanAlt">Mother Teresa</span> (the most trustworthy imaginable signer). But this does not necessarily mean it was really signed by Mother Teresa. It just means that whoever signed it (say <span class="docEmphasis">SleazeInc</span>) put the string <span class="docEmphRomanAlt">Mother Teresa</span> into the <span class="docEmphSmaller">ISSUER NAME</span> field.</p></li><li><p class="docList">Users will not understand the concept of trust anchors. If they have been assured that the application they are using does encryption, they will assume that it will be secure even if they're using a public workstation, perhaps in a hotel room or at an airport. Although it will always be an issue if a user can be tricked into using a public workstation with malicious code, it would be easier for the previous user of the workstation to modify the set of trust anchors and the proxy to be used (probably not a privileged operation) than to change the software.</p></li><li><p class="docList">There is no practical way for even a knowledgeable user to be able to examine the set of trust anchors and tell if someone has modified the set. Browsers today come shipped with about 80 trust anchors. You can examine them by name, but someone could delete the key of <span class="docEmphasis">TrustworthyInc</span>, and put in a new key claiming that it belongs to <span class="docEmphasis">TrustworthyInc</span>. You might even be able to look at digests of the keys, but what user will be sufficiently paranoid to have printed out all the message digests of the 80 or so trust anchors that get shipped with the application and compare them with the configured set?</p></li></ul>
<a name="ch15lev2sec5"></a>
<h4 id="title-IDAWIPHH" class="docSection2Title">15.3.5. Anarchy Model</h4>
<p class="docText">This is the model used by PGP. Each user is responsible for configuring some trust anchors, for instance, public keys of people he has met and who have handed him a business card with a PGP <span class="docEmphStrong">fingerprint</span> (the message digest of the public key), and sent him email containing a public key with that digest. Then anyone can sign certificates for anyone else. Some organizations (for instance, MIT does this today) volunteer to keep a certificate database into which anyone can deposit certificates. To get the key of someone whose key is not in your set of trust anchors, you can search through the public database to see if you can find a path from one of your trust anchors to the name you want. This absolutely eliminates the monopoly pricing, but it is really unworkable on a large scale:</p>
<ul><li><p class="docList">The database would get unworkably large if it were deployed on Internet scale. If every user donated, say, ten certificates, the database would consist of billions of certificates. It would be impractical to search through the database and construct paths.</p></li><li><p class="docList"><a name="iddle1675"></a>Assuming somehow Alice could piece together a chain from one of her trust anchors to the name <span class="docEmphRomanAlt">Bob</span>, how would she know whether to trust the chain? So, Carol (her trust anchor) vouches for Ted's key. Ted vouches for Gail's key. Gail vouches for Ken's key. Ken vouches for Bob's key. Are all these individuals trustworthy?</p></li></ul>
<p class="docText">As long as this model is used within a small community where all the users are trustworthy, it will work, but on the Internet scale, when there are individuals who will purposely add bogus certificates, it would be impossible to know whether to trust a path. Some people have suggested that if you can build multiple chains to the name that you can be more assured of the trustworthiness. But once someone decides to add bogus certificates, he can create arbitrary numbers of fictitious identities and arbitrary numbers of certificates signed by those entities. So sheer numbers will not be any assurance of trustworthiness.</p>
<a name="ch15lev2sec6"></a>
<h4 id="title-IDAAKPHH" class="docSection2Title">15.3.6. Name Constraints</h4>
<p class="docText">The concept of name constraints is that the trustworthiness of a CA is not a binary value where a CA would either be completely untrusted or trusted for everything. Instead, a CA should only be trusted for certifying some subset of the users. For instance, MIT's CA, most likely managed by playful undergraduates, should be trusted for certifying name/key binding of MIT students, but not for certifying the key of, say, <span class="docEmphRomanAlt">president@whitehouse.gov</span>.</p>
<p class="docText">Assuming users have hierarchical names, such as <span class="docEmphRomanAlt">radia@alum.mit.edu</span>, it is easy to specify a policy for trusting the MIT CA. The MIT CA should be trusted for certifying names in the namespace under mit.edu, but not names of the form <span class="docEmphRomanAlt">foo@harvard.edu</span>. Although I<sub>2</sub> might be a Sun employee, you would not trust the Sun CA to certify the name <span class="docEmphRomanAlt">radia@alum.mit.edu</span>. But you would trust the Sun CA to certify the name <span class="docEmphRomanAlt">radia.perlman@sun.com</span>. The name by which you know someone determines whom you trust to certify that name. Users might have multiple names. The PKI doesn't care. Each name is a separate PKI entity. They might use the same public key, in which case someone might happen to notice that <span class="docEmphRomanAlt">radia@alum.mit.edu</span> and <span class="docEmphRomanAlt">radia.perlman@sun.com</span> are most likely the same individual because the two entities have the same public key. Or I<sub>2</sub> might use different keys for my<sub>2</sub> different identities.</p>
<a name="ch15lev2sec7"></a>
<h4 id="title-IDASLPHH" class="docSection2Title">15.3.7. Top-Down with Name Constraints</h4>
<p class="docText">This model is similar to the monopoly model in that everyone must be configured with a pre-ordained, never changing root key, and that root CA delegates to other CAs. However, the delegated CAs are only allowed to issue certificates for their portions of the namespace. In this model it is easy to find the path to a name (just follow the namespace from the root down). But it has the other <a name="iddle1025"></a><a name="iddle1224"></a><a name="iddle1226"></a><a name="iddle1299"></a><a name="iddle1579"></a><a name="iddle2112"></a>problems of the monopoly model, in that everyone has to agree upon a root organization, and that organization and its key would be prohibitively expensive to ever replace.</p>
<a name="ch15lev2sec8"></a>
<h4 id="title-IDAJNPHH" class="docSection2Title">15.3.8. Bottom-Up with Name Constraints</h4>
<p class="docText">This model is not deployed, although the design of Lotus Notes is close (see &sect;<a class="docLink" href="ch24lev1sec5.html#ch24lev1sec5">24.5</a> <span class="docEmphasis">Lotus Notes Security</span>). It was originally proposed for Digital's security architecture in the late 1980s (see &sect;<a class="docLink" href="ch24lev1sec4.html#ch24lev1sec4">24.4</a> <span class="docEmphasis">DASS/SPX</span>). We believe this model, or something close to it, will better serve the Internet because of the reasons we give at the end of this section. The philosophy of this model is that each organization can create its own PKI and then link to others. The model assumes a hierarchical namespace in which each node is represented by a CA. Not only does the parent certify the child's name, but the child certifies the parent's name. In other words, .edu would certify mit.edu, and mit.edu would certify .edu. In addition to up-links (where the child certifies the parent) and down-links (where the parent certifies the child), cross-links are allowed, where a <span class="docEmphStrong">cross-link</span> is a link from any node to any other node where neither is an ancestor of the other. (See <a class="docLink" href="#ch15fig01">Figure 15-1</a>.) The certificate by which one node creates a cross-link to another node is known as a <span class="docEmphStrong">cross-certificate</span>.</p>
<a name="ch15fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 15-1. Bottom-Up PKI Model</h5>
</center></p><p class="docText">
<img border="0" alt="" width="400" height="98" src="15fig01.jpg" /></p>
<br />
<p class="docText">Note that with links in both directions (from child to parent and from parent to child), it is possible to navigate the namespace starting from any node. Instead of using the root as your trust anchor, you can start anywhereÂthe uppermost key within your own organization, or even your own key! If the trust anchor is your own key, the only thing you need to know a priori is your own key pair. If the trust anchor is something other than your key, you also need to know the trust anchor's public key.</p>
<p class="docText">We define an <span class="docEmphStrong">ancestor</span> of a name to be any prefix of that name (where the strings delimited by slashes are considered atomic), including the name itself. To find a path to a target, start at your trust anchor. If it is an ancestor of the target name, go down from there to the name. If not, look for a cross-certificate to an ancestor of the target. If you don't find a suitable cross-certificate, go up to the parent, look for cross-certificates to an ancestor of the target, and so forth, until you either find a suitable cross-certificate or get to the least common ancestor of the trust anchor and the target. (The least common ancestor is the node with the longest name which is a prefix of both names.) Once at an ancestor of the target, just follow down-links to the target.</p>
<p class="docText">The rule is you follow up-links as far as necessary (until you encounter a cross-link to an ancestor of the target at or below the least common ancestor, or until you reach the least common ancestor), then you follow at most one cross-link, and then you follow down-links from there. Without cross-links, the set of CAs you must trust are all your ancestors and all the target's ancestors up to the least common ancestor. With cross-links, the set of CAs that you must trust is a subset of that.</p>
<p class="docText">So for instance, imagine user A/B/X in <a class="docLink" href="#ch15fig01">Figure 15-1</a> wishes to find the key of user A/C/Y, and user A/B/X uses her own key as her trust anchor. So she looks in the directory under her own record (A/B/X) for cross-certificates. Since there are none, she goes up to her parent (A/B) and looks for <a name="iddle1128"></a><a name="iddle1369"></a><a name="iddle1580"></a><a name="iddle1929"></a>cross-certificates. Since there are none, she goes to its parent (A), and at that point she has reached the least common ancestor, so she can go down to the target name.</p>
<p class="docText">Now suppose A/C/Y wants to find the key of B/Y/Z/C. She'd go up to her parent (A/C), and then follow the cross link to B/Y/Z, and then go down to B/Y/Z/C.</p>
<p class="docText">But there is no path back from B/Y/Z/C to A/C/Y since the PKI does not go up to a common ancestor of those two names, and there is no cross link from an ancestor of B/Y/Z/C to an ancestor of A/C/Y. It might look as though B/Y/Z/C could go up one level to B/Y/Z, and then down to B/Y/Z/A from which there is a cross link to A/C. In order to be able to find such a path, the search rules would be very complex, since each link would have to be followed in case it led to a cross link to the target name. But a thornier issue is whether to trust any intermediary other than the CAs up to a common ancestor. If the trust rules are clear, e.g., only CAs along the name path are trusted, then it's easy to find and blame the compromised CA, and it's also easy to know what damage can be caused by a given CA's being compromised. If you trust any CA for anything it won't be secure. If you have any rule between those two extremes, the security becomes very complicated to configure.</p>
<p class="docText">If it were important for there to be a path from B/Y/Z/C to A/C/Y, then B/Y/Z/C or one of its parents would create a cross link to A, A/C, or A/C/Y. Eventually organizations would tire of maintaining many cross-links. At that point there arises a business opportunity to provide inter-organization connectivity (which we'll call <span class="docEmphStrong">root service</span>), but in competition with other organizations providing root service. An organization that offers root service would advertise its rates, how much liability it is willing to assume, would explain its policies and procedures for how carefully it checks information before issuing a certificate, and so forth.</p>
<p class="docText">We like this model. It was originally proposed for Digital's security architecture in the late 1980s. With the trust anchor being the uppermost key in one's own organization, it is similar to the PKI for Lotus Notes, and the bridge CA model used for the Federal PKI. The <span class="docEmphStrong">bridge CA</span> is simply a CA that certifies and is certified by the uppermost CA in each organization. The advantages of this model are:</p>
<ul><li><p class="docList">It is easy to find out if a path exists.</p></li><li><p class="docList">The policy of assuming that the name by which something is known implies whom you'd trust to certify the name is something people can understand, and is sufficiently flexible and simple that it might actually work.</p></li><li><p class="docList">PKI can be deployed in any organization independently of the rest of the world. There is no reason to pay a commercial CA for certificates. There is no reason to wait for the entire world-encompassing PKI to get put into place before you can use PKI in your own organization, or between a few organizations.</p></li><li><p class="docList">Since authentication paths between users in your own organization never go outside of your own organization, security of what is presumably the most security-sensitive operationÂauthenticating users in your own organizationÂis entirely in your own hands. Compromise of any CA outside of your own organization will not allow anyone to impersonate one of your own users to your own services.</p></li><li><p class="docList">Replacing any key is reasonably easy. For instance, assume that a few companies offering root service successfully manage to acquire a large customer base. If a root service's key gets compromised, then it only affects the top CA of each of the root service's customers. Each such CA has to revoke the old certificate it issued to the root service and issue a new certificate containing the new key, and automatically all the users in the CA's subtree are using the new key in place of the old key.</p></li><li><p class="docList">No organization gets so entrenched that it can start charging monopolistic prices. Competition is always possible.</p></li><li><p class="docList">Configuration is very easy. At the very least you need to know your own key pair. With this PKI model, that is <span class="docEmphasis">all</span> you need to know, since all the other CAs can be reached by paths starting with your own key. Your private key might be carried on a smart card; for other methods of obtaining your private key, see &sect;<a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">12.4</a> <span class="docEmphasis">Strong Password Credentials Download Protocols</span>. To use a key other than your own as the trust anchor, for instance the uppermost key in your organization, you will need to also know the public key of that trust anchor.</p></li></ul>
<p class="docText">How would this be deployed? Suppose an organization, say <span class="docEmphRomanAlt">finance.east.bigorg.com</span>, deploys PKI-based security using this model. When someone, say Joe, is hired into that organization, he visits the CA operator. This is just another step in the process of getting hired, like visiting the badge-making office. Joe obtains a public key pair, perhaps by generating it on his own machine or obtaining a smart card. Given that the CA (like the badge facility) is probably on site, it is easy for him to physically meet the CA operator and be introduced by someone the CA operator knows. It is therefore secure and convenient for him and the CA to certify each other's public keys. Then the up-link certificate can be stored in a directory so that Joe can plug his smart card into any workstation and search the directory for all the other certificates he will need.</p>
<p class="docText"><a name="iddle1676"></a><a name="iddle1820"></a><a name="iddle1898"></a><a name="iddle1957"></a><a name="iddle2025"></a>Joe may have a life other than as an employee. He might get another certificate (and name and virtual identity) from his <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_111">ISP</a></span> for email and from his credit card company for securely ordering things. He could decide which identity to use for any particular activity. These identities might or might not use the same public key. There may be no way of knowing when two different entities in the PKI namespace happen to map to the same carbon-based life form.</p>
<a name="ch15lev2sec9"></a>
<h4 id="title-IDAMUPHH" class="docSection2Title">15.3.9. Relative Names</h4>
<p class="docText">Relative names is another useful concept found in DASS/SPX, useful because if an entire subtree of the namespace moves, most of the certificates do not need to be reissued. This is done by having certificates carry <span class="docEmphStrong">relative names</span> rather than absolute names. That means that instead of putting in the entire name <span class="docEmphRomanAlt">joe.finance.east.bigorg.com</span>, the down-link certificate (the one from parent to child) would carry the name <span class="docEmphRomanAlt">joe</span>. Now, in case the company reorganizes, so that finance is moved up under bigorg.com (so it is now <span class="docEmphRomanAlt">finance.bigorg.com</span>), only the new certificates between bigorg.com and finance.bigorg.com need to be issued. All the certificates for the subtree under finance would remain the same.</p>
<p class="docText">With relative names, a child certificate would carry only the component which is the extension of the parent's name. A parent certificate would not carry a name at all, but instead say <span class="docEmphasis">this is my parent</span>. There is an interesting issue with what to put into a cross-certificate. There are two possibilities. One possibility is to put an absolute name into a cross-certificate. That way if the issuer's portion of the namespace gets moved, but the subject's portion hasn't changed, then the certificate will still be valid. The other possibility is to put in a relative name (like <span class="docEmphRomanAlt">../../B/C</span>), in which case the certificate would remain valid if a branch of the namespace containing both names were moved as a whole (see <a class="docLink" href="ch15lev1sec9.html#ch15lev1sec9">Homework Problem 2</a>).</p>
<p class="docText">Although relative names have some attractive properties, there are some very complex issues, such as what name to put into a cross-link and how an entity learns its own name. Since nothing with relative names has been deployed, it would be an interesting area to study. <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_199">SDSI</a></span> and SPKI (RFC 2693 <i><a class="docLink" href="app02.html#gloss01_212">SPKI</a></i> <i><a class="docLink" href="app02.html#gloss01_034">Certificate</a></i> <span class="docEmphasis">Theory</span>) present a design that uses a form of relative names.</p>
<a name="ch15lev2sec10"></a>
<h4 id="title-IDAWWPHH" class="docSection2Title">15.3.10. Name Constraints in Certificates</h4>
<p class="docText">The certificate format adopted by PKIX (see &sect;<a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">15.6</a> <span class="docEmphasis">PKIX and X.509</span>) has a field called <span class="docEmphSmaller">NAME CONSTRAINTS</span>, which allows the issuer to specify what names the subject is trusted to certify. The field can contain allowed names and disallowed names. PKIX certificates can be used to build any of the models we've mentioned. To build the bottom-up model, a child or cross-certificate would specify that the subject was only allowed to certify names in the subtree below the subject's name. A parent certificate would contain the constraint <span class="docEmphasis">any names except myself and below</span>.</p>
<p class="docText">We'd still recommend mostly building the bottom-up model, but there is some amount of flexibility that the strict <span class="docEmphasis">up* Â cross once Â down*</span> algorithm might not give. For instance, an organization might have a cross-link to other-org.com, but realizing that other-org.com also keeps cross-certificates to yet-another.com and still-another.com, the name constraint in the cross-certificate might say that the subject would be trusted to certify names in the namespaces of any of other-org.com, yet-another.com, and still-another.com. Or there might be several root organizations that all cross-certify each other, with each having certified some subset of the organizations. Since two organizations might not have been certified by the same root, it might be necessary to go up to the root, then find a path across the roots to the target's root, and then go down. This could be accomplished by having roots cross-certify each other using the name constraint <span class="docEmphasis">trusted for all names</span>. The further one gets from the bottom-up model, and the closer one gets to the anarchy model, the more complex it will be to search all valid paths.</p>
<a name="ch15lev2sec11"></a>
<h4 id="title-IDA0XPHH" class="docSection2Title">15.3.11. Policies in Certificates</h4>
<p class="docText">The PKI in PEM (see <a class="docLink" href="ch21.html#ch21">Chapter 21</a> <span class="docEmphasis">PEM &amp; S/MIME</span>) had built-in policies. The PEM PKI consisted of a single root CA which certified multiple hierarchies, each with its own policy. Some hierarchies had pre-defined (by the standards body) policies. PEM allowed future hierarchies with different published policies. If you wanted to get certified in a particular hierarchy you had to follow the policies of that hierarchy, and you could only get certified in one hierarchyÂthe one whose policies you followed. Policies were intended to be things like how carefully you checked identity before issuing a certificate and how often you administered drug tests to the CA operators (see &sect;<a class="docLink" href="ch21lev1sec5.html#ch21lev1sec5">21.5</a> <span class="docEmphasis">PEM Certificate Hierarchy</span>). The PEM PKI was a failure and was never substantially deployed, in part because of its rigidity.</p>
<p class="docText">PKIX provides certificate extensions for policies, intended to support something along the lines of what the PEM hierarchy designers envisioned. Instead of defining what the policies are, PKIX allows for putting in OIDs, which are hierarchically assigned globally unique identifiers. The meaning of these is not standardized. Anyone can obtain an OID and define it to mean anything.</p>
<p class="docText">Policies don't have values associated with them. So, for instance, if what you want is a policy for security level, you couldn't say <span class="docEmphasis">policy = security level, value = confidential</span>. Instead, you'd have to choose separate OIDs for each level of security, for example an OID for <span class="docEmphasis">top secret</span>, a different OID for <span class="docEmphasis">secret</span>, and yet another for <i><a class="docLink" href="app02.html#gloss01_051">confidential</a></i>. If you want a certificate chain where every link in the chain is at least secret, then the top secret links would have to specify they meet confidential, secret, and top secret policies. It is not possible for the application to say that each link in the chain can be either secret or top secret. Instead there has to be a chain that has the same OID in each certificate.</p>
<p class="docText">To further complicate things, it is possible, assuming two organizations are using OIDs for similar enough policies that they are willing to consider them equivalent, the cross-certificate from <a name="iddle1723"></a><a name="iddle1733"></a><a name="iddle1743"></a><a name="iddle1746"></a>one organization to the other can contain mapping rules such as <span class="docEmphasis">OID1=OID2</span>. That means that if a chain which must contain OID1 in the first organization crosses into the other organization's PKI, all subsequent certificates in the chain must contain OID2.</p>
<p class="docText">The way policies are processed in a chain is that the application specifies what policy OIDs, if any, it wants to see in certificates. For example, the application might specify <span class="docEmphasis">OID1 or OID2 or OID3</span>. A chain must have the same OID in every link. So for instance, even if the application doesn't care whether it's OID1 or 2 or 3, if the first certificate in the chain contains only OID2 and the next certificate in the chain contains only OID3, then the chain is not valid. If the first certificate contains OID1 and OID2 and the next one contains OID2 and OID3, then the chain so far is valid, but every subsequent certificate in the chain must now contain OID2, since that was the only acceptable OID that was contained in both of the first two certificates.</p>
<p class="docText">If policy mapping happens in the middle of the chain, and OID2 is declared equivalent to OID5, then (assuming OID2 needed to be in all the remaining certificates in the chain) OID5 must appear in all the remaining certificates in the chain.</p>
<p class="docText">These rules are somewhat arbitrary, and whether people wind up using the PKIX policies in any useful way remains to be seen.</p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>