<html><head><title>24.7. Microsoft Windows Security</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch24lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch24lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch24lev1sec7"></a>
<h3 id="title-IDAJTSZK" class="docSection1Title">24.7. Microsoft Windows Security</h3>
<a name="ch24lev2sec20"></a>
<h4 id="title-IDASTSZK" class="docSection2Title">24.7.1. LAN Manager and NTLM</h4>
<p class="docText"><a name="iddle1719"></a>LAN Manager comes equipped with a simple, straightforward cryptographic authentication protocol between client and server based on shared secrets. Each server that a user is entitled to access is configured with security information about that user, including a hash of the user's password. When a user Alice wishes to access a server, she types her name and password at her workstation, which contacts the server, sending Alice's name. The server sends a challenge, which the workstation encrypts using the hash of the user's password. Some applications (like RPC) continue cryptographic protection beyond the initial handshake using the user's hashed password to establish a session key.</p>
<p class="docText">This protocol is very similar to NetWare V3. In both protocols, the fact that the server stores a hash of the user's password rather than the actual password does not theoretically make the scheme more secure. A modified version of the client software could impersonate the user if it directly used the hash of the password rather than hashing the string the user types. But it would be a lot more convenient and practical for an intruder Trudy if she could capture the actual password rather than the hash of the password, since then Trudy could type the password at unmodified client code. One difference between the protocols is that the LAN Manager scheme does not use salt. That means that if the user uses the same password on multiple servers, and an intruder captures one server's database, the intruder can impersonate the user at other servers.</p>
<p class="docText">For NT, the scheme was extended in a way that was transparent to client machines. <i><a class="docLink" href="app02.html#gloss01_227">Transparent</a></i> means that the new scheme works with the old client code and in fact a client machine cannot tell based on the protocol whether the server is using the old protocol or the new protocol. In the NT protocol, instead of keeping the security information at each server, security information is stored in a trusted on-line entity called a <span class="docEmphasis">domain controller</span>. The new scheme is called NTLM. It has the following advantages:</p>
<ul><li><p class="docList">Management is simplified, since user security information only needs to be configured into a single location, the domain controller.</p></li><li><p class="docList">It is more user-friendly, since a user will have a single password that will work on all servers the user is entitled to use. In the old scheme, a user could certainly use the same password on all servers, but when the user Alice changed her password, she'd have to remember to change her password at all the servers.</p></li></ul>
<p class="docText">The NT scheme works like the authentication facilitator node we discussed in &sect;<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec2">9.1.2</a> <span class="docEmphasis">Storing User Passwords</span>. The domain controller (which is what we called the authentication facilitator node), stores a secret for each server in the domain, which enables a server in the domain and the domain controller to communicate securely. The domain controller also stores security information for each human user in the domain, including a hash of the user's password, a list of groups to which the user belongs, when to prod the user to change her password, and the hours she's allowed to log in. When a user wishes to log into a server in the user's domain, that server sends a challenge to the user's workstation, which then generates a cryptographic response based on the user's password and the challenge (see <a class="docLink" href="#ch24fig07">Figure 24-8</a>). Since the server does not store any security information for the user, it cannot evaluate the response. Instead, in an encrypted conversation to the domain controller, the server forwards its challenge and the workstation's response. The domain controller answers <span class="docEmphRomanAlt">yes</span> or <span class="docEmphRomanAlt">no</span> in the encrypted reply to the server. If the answer is <span class="docEmphRomanAlt">yes</span>, the domain controller also sends information about the user, such as to which groups the user belongs, and the user's hashed password. (This information, like all the sensitive information between the domain controller and the server, is encrypted.) The hashed password is transmitted so that the server can use it to compute a session key for protection of the remainder of the client-server conversation.</p>
<a name="ch24fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 24-8. Microsoft Windows NT Authentication</h5>
</center></p><p class="docText"><div class="v1"><a target="_blank" href="24fig08_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="265" src="24fig08.jpg" /></p>
<br />
<p class="docText">It is possible for a client in one domain D<sub>1</sub> to be authenticated by a server in another domain D<sub>2</sub> provided that D<sub>1</sub> and D<sub>2</sub> have been preconfigured to trust each other. There is no transitivity, i.e., if Alice is in domain D<sub>1</sub> and Bob is in domain D<sub>2</sub>, they can communicate if D<sub>1</sub> and D<sub>2</sub> have a trust relationship. It is not possible to transit through domain D<sub>3</sub> in the case where D<sub>1</sub> and D<sub>3</sub> trust each other and D<sub>3</sub> and D<sub>2</sub> trust each other but D<sub>1</sub> and D<sub>2</sub> do not trust each other. This is similar to Kerberos V4.</p>
<p class="docText"><a name="iddle1011"></a><a name="iddle1524"></a><a name="iddle2131"></a><a name="iddle2132"></a>Names include a domain name, for example D<sub>1</sub>\Alice and D<sub>2</sub>\Bob. When Alice's workstation contacts Bob, it transmits Alice's name (D<sub>1</sub>\Alice). Bob contacts Bob's own domain controller, as in the single domain protocol. But Bob's domain controller can't make the decision since D<sub>2</sub> has no information stored for D<sub>1</sub>\Alice. But D<sub>2</sub> can communicate securely with D<sub>1</sub>, and so D<sub>2</sub> forwards the information (D<sub>1</sub>\Alice, <span class="docEmphasis">C</span>, <span class="docEmphasis">R</span>) to D<sub>1</sub>, which replies to D<sub>2</sub> with <span class="docEmphRomanAlt">yes</span> (plus group information, Alice's hashed password, and so on) or <span class="docEmphRomanAlt">no</span>, and then D<sub>2</sub> relays this information to Bob (see <a class="docLink" href="#ch24fig08">Figure 24-9</a>).</p>
<a name="ch24fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 24-9. Microsoft Windows NT Interdomain Authentication</h5>
</center></p><p class="docText"><div class="v1"><a target="_blank" href="24fig09_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="215" src="24fig09.jpg" /></p>
<br />
<p class="docText">The cryptographic aspects of the protocol are straightforward. RC4 is used to encrypt the conversation between the server and the domain controller. The domain controller has a long-term secret key stored for each server in the domain, and uses that to establish initial mutual authentication with the server, but as a side-effect of the authentication they establish a session key, and use that to encrypt subsequent communication. The session key for the conversation with the domain controller is obtained by adding the two challenges used in the mutual authentication and encrypting the result with the long-term secret. There is an authenticator in every packet that proves the message is in proper sequence, which prevents session hijacking, but is not used to provide integrity protection of the contents of the message. Encryption is only used on select fields in the packet, i.e., only where necessary.</p>
<a name="ch24lev2sec21"></a>
<h4 id="title-IDAZ0SZK" class="docSection2Title">24.7.2. Windows 2000 Kerberos</h4>
<p class="docText">With Windows 2000 came another step in the evolution of Windows authentication. User authentication information is moved from the Domain Controller to Active Directory, which serves as both KDC and directory service. The protocol is a modified version of Kerberos V5.</p>
<p class="docText">As with OSF DCE, the designers at Microsoft were faced with the challenge that while Kerberos is designed to provide authentication of the names of communicating principals, what the OS needs for users is not a name but rather a UID (user ID) and a list of GIDs (group IDs), since that is the information used to make access control decisions. Otherwise there would need to be a separate translation mechanism available to every server. The Microsoft design is similar to the OSF DCE design, but simpler and more controversial. Both use the <span class="docEmphSmaller">AUTHORIZATION-DATA</span> field in the Kerberos ticket to hold the additional information. But unlike OSF DCE, which stood on its head creating a virtual Privilege Server entity and had many additional round trips when logging in users, Win2K Kerberos simply had the KDC add the <span class="docEmphSmaller">AUTHORIZATION-DATA</span> field to the ticket when it was generated. Technically, this did not comply with the Kerberos specification (though there have been legalistic arguments over whether it does or does not) while the OSF DCE approach did. But only lawyers worry about compliance. Users and system administrators worry about interoperability, and both OSF DCE and Windows 2000 Kerberos offer only backward compatibility with &quot;standard&quot; Kerberos applications. They offer none with one another nor can their services authenticate users not registered with their own registries.</p>
<p class="docText">Another source of controversy is that the syntax of the authorization extensions is an &quot;open secret&quot;. At the time of this writing, the design was posted at <span class="docEmphRomanAlt"><a class="docLink" target="_blank" href="http://www.microsoft.com/technet/security/kerberos/">http://www.microsoft.com/technet/security/kerberos/</a></span> and was downloadable by anyone, but required readers to acknowledge that the information is a trade secret of Microsoft, that they may only read it for purposes of reviewing its security, and that they may not discuss it with anyone who had not agreed to the same terms. Whether a company can retain trade secret rights to published information is an interesting legal question. In the court of public opinion, most observers are unwilling to call such a design &quot;open&quot;.</p>
<p class="docText">Another practical problem in Kerberos in the multi-realm case is that Kerberos doesn't specify how clients should find a sequence of realms that will allow them to authenticate to a remote server and doesn't specify how servers should decide whether a given sequence of realms is acceptable. This complex set of configuration issues is left to client and server implementations. In most cases, it would be more practical to configure this information in the KDCs. In the Windows 2000 Kerberos protocol, a client does not need to figure out the path to a remote service. It requests a service ticket from its local KDC, which instead returns a TGT to the next KDC in the chain. The client then repeats this process until it reaches the service's KDC, which gives it a service ticket. The KDCs should (and may) also check incoming requests to assure that the client has come through an acceptable sequence of KDCs on its way to the server and refuse to issue the next ticket if not. In this case, neither the client nor the server would need any knowledge of trust relationships. If authentication succeeds, it implies that the intermediate KDCs did all of the appropriate checks and it was OK. This extension has been proposed for standardization in the next revision of Kerberos.</p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch24lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch24lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>