<html><head><title>15.4. Revocation</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch15lev1sec4"></a>
<h3 id="title-IDAYKCCK" class="docSection1Title">15.4. Revocation</h3>
<p class="docText">If someone realizes their key has been stolen, or if someone gets fired from an organization, it is important to be able to revoke their certificate. Certificates typically have expiration dates in them, but since it is a lot of trouble to issue a certificate (especially if the CA is off-line), the validity time is typically months, too long to wait if it needs to be revoked.</p>
<p class="docText">This is similar to what happens with credit cards. They, too, have an expiration date. They are usually issued to be good for a year or more. However, if one is stolen, it is important to be able to revoke its validity quickly. Originally, the credit card companies published books of bad credit card numbers, and distributed these books to all the merchants. Before accepting the card, the merchant would check to make sure the credit card number wasn't in the book. This mechanism is similar to a CRL (certificate revocation list) mechanism.</p>
<p class="docText">Today the usual mechanism for credit cards is that for each transaction the merchant calls someplace that has access to a database of invalid credit card numbers (or valid credit card numbers), and the merchant is told whether the credit card is valid (and if there is sufficient credit limit for the purchase). This is similar to an <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_146">OLRS (on-line revocation service)</a></span> mechanism. The PKIX standard protocol for requesting revocation status of a certificate is called <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_142">OCSP (on-line certificate status protocol)</a></span>, and is documented in RFC 2560.</p>
<p class="docText"><a name="iddle1223"></a><a name="iddle1251"></a><a name="iddle1913"></a><a name="iddle2123"></a>Why do certificates have expiration times at all? Assuming there is a method of revoking them, the only security reason to have them expire is to make the revocation mechanism more efficient, for instance by keeping the CRL of manageable size. There are two additional real-world reasons for designing certificates with expiration times:</p>
<ul><li><p class="docList">many deployed systems don't bother with revocation at all, and depend on expiration instead</p></li><li><p class="docList">companies that want to collect revenue from issuing certificates want to be able to collect multiple times for the same certificate.</p></li></ul>
<p class="docText">True story: At one time most browsers, by default, did not check expiration date, and even today all of them allow you to choose to ignore the expiration date in a certificate. To get PKI deployed, Verisign initially issued certificates with reasonable terms (e.g., low issuing fee) and lifetimes of two years. But once safely entrenched, the terms they demanded for renewing these certificates were far less favorable. Many server administrators noticed that most browsers didn't check the expiration date, and so didn't bother getting new certificates. In order to be compatible with the many servers with expired certificates, browsers are very casual about expiration date (e.g., having the default be not to check it, or making it very easy for the user to agree to ignore it).</p>
<a name="ch15lev2sec12"></a>
<h4 id="title-IDADNCCK" class="docSection2Title">15.4.1. Revocation Mechanisms</h4>
<p class="docText">The basic idea of a CRL is that the CA periodically issues a signed list of all the revoked certificates. This list must be issued periodically, even if no certificates have been revoked since the last CRL, since otherwise an attacker could post an old CRL (from before his certificate was revoked). If a timestamped CRL is issued periodically, then the verifier can refuse to honor any certificates if it cannot find a sufficiently recent CRL. Each CRL contains a complete list of all the unexpired, revoked certificates.</p>
<a name="ch15lev3sec1"></a>
<h5 id="title-IDAONCCK" class="docSection3Title">15.4.1.1. Delta CRLs</h5>
<p class="docText">Delta CRLs are intended to make CRL distribution more efficient. Let's say you want to have revocation take effect within one hour. With a CRL, that would mean that every hour the CA would have to post a new CRL, and every verifier would have to download the latest CRL. Suppose the CRL was very large, perhaps because the company just laid off 10000 people. Every hour, every verifier would have to download a huge CRL, even though very few certificates had been revoked after that layoff.</p>
<p class="docText">A delta CRL lists changes from the last complete CRL. The latest full CRL would have to be posted (and downloaded to each verifier) along with the periodic delta CRLs. The delta CRL would say <span class="docEmphasis">these are all the certificates that have been revoked since February 7, 10 AM, which is the most recent full CRL</span>. The delta CRL would be very short, often containing no certificates. Issuing delta <a name="iddle1734"></a><a name="iddle2122"></a><a name="iddle2137"></a>CRLs periodically obviates the need to issue full CRLs periodically. Instead one can issue a full CRL in place of a delta CRL when the delta CRL gets sufficiently large.</p>
<a name="ch15lev3sec2"></a>
<h5 id="title-IDATOCCK" class="docSection3Title">15.4.1.2. First Valid Certificate</h5>
<p class="docText">This is an idea we<sub>1,2</sub> designed for making the CRL small again after it has become too large. This scheme also allows certificates to not have a predetermined expiration time when issued. Instead, they are only marked with a serial number, which increases every time a certificate is issued (or the issue time could be used instead of a serial number). Our version of a CRL would have one additional field that is not included in X.509. The CRL would contain a <span class="docEmphSmaller">FIRST VALID CERTIFICATE</span> field. Any certificates with lower serial numbers (or issue times) are invalid.</p>
<p class="docText">Certificates in our scheme would have no predetermined expiration time. As long as the CRL is of manageable size there is no reason to reissue any certificates. If it looks like the CRL is getting too large, the company issues a memo warning everyone with certificate serial numbers less than some number <span class="docEmphasis">n</span> that they'll need new certificates by, say, a week from the date of the memo. The number <span class="docEmphasis">n</span> might be the next-to-be-issued certificate serial number, or it could be some earlier one. The number <span class="docEmphasis">n</span> is chosen so that few of the serial numbers in the current CRL are less than <span class="docEmphasis">n</span>. Revoked certificates with serial numbers greater than <span class="docEmphasis">n</span> must continue to appear in the new CRL, while valid certificates with numbers greater than <span class="docEmphasis">n</span> do not have to be reissued. Some time later, say two weeks after the memo is sent, the CA issues a new CRL with <span class="docEmphasis">n</span> in the <span class="docEmphSmaller">FIRST VALID CERTIFICATE</span> field. Affected users (those with serial numbers less than <span class="docEmphasis">n</span>) who ignored the memo will thenceforth not be able to access the network until they get new certificates, since their certificates are now invalid.</p>
<p class="docText">There are cases when even with this scheme it might be reasonable to have expiration times in certificates. For example, at a university, students might be given certificates for use of the system on a per-semester basis, with a certificate that expires after the semester. Upon paying tuition for the next semester, the student is given a new certificate. But even in those cases, it may still be reasonable to combine expiration times in some certificates with our scheme, since our scheme would allow an emergency mass-revocation of certificates.</p>
<a name="ch15lev2sec13"></a>
<h4 id="title-IDADQCCK" class="docSection2Title">15.4.2. OLRS Schemes</h4>
<p class="docText">An OLRS (on-line revocation server) is a system that can be queried over the net about the revocation status of individual certificates. If Alice is using service Bob, then Bob is the verifier (the one making sure Alice's certificate is valid). The design most people envision is that the server Bob queries the OLRS through some authenticated communication.</p>
<p class="docText">You might think that introducing an <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_147">on-line server</a></span> into a PKI eliminates an important security advantage of public keys, because you now have an on-line trusted service. But the OLRS is not as <a name="iddle1114"></a><a name="iddle1404"></a>security sensitive as a CA (or KDC). The worst the OLRS can do is claim that revoked certificates are still valid, but at least the damage is limited. It does not have a vulnerable database of user secrets (like a KDC does). Its key should be different from the CA's key, so if its key is stolen, the CA's key would not be compromised.</p>
<p class="docText">An OLRS variant is to have Alice obtain a certificate from the OLRS declaring that <span class="docEmphasis">as of 8 AM on June 3 Alice's certificate was not revoked</span>. Assuming Alice will be visiting many resources, this saves the OLRS the work of talking to multiple verifiers, saves the verifier the work of querying the OLRS, and saves the network from the bandwidth used by having multiple verifiers query the OLRS. Alice would present two certificates to Bob: her long-lived certificate obtained from the CA, and the certificate of non-revocation from the OLRS.</p>
<p class="docText">Bob can decide how quickly revocation should take effect. If he wants revocation to take place within, say, one hour, then he can insist that Alice's non-revocation certificate be timestamped within the last hour. If he complains it isn't sufficiently recent, then Alice can obtain a new one.</p>
<p class="docText">Alice can proactively refresh her certificate, knowing that most servers would want one that is, say, less than an hour old. Then the round-trip querying of the OLRS does not need to be done at the time of a transaction.</p>
<p class="docText">Even with Bob (instead of Alice) querying the OLRS, it is possible to do caching and refreshing. Bob can keep track of the users that tend to use his resource and proactively check with the OLRS to see if any of them have been revoked.</p>
<a name="ch15lev2sec14"></a>
<h4 id="title-IDATRCCK" class="docSection2Title">15.4.3. Good-lists vs. Bad-lists</h4>
<p class="docText">The standards assume that the CRL will contain all the serial numbers of bad certificates, or that the OLRS would have a database of revoked certificates. This sort of scheme is known as a <span class="docEmphStrong">bad-list</span> scheme, since it keeps track of the bad certificates.</p>
<p class="docText">A scheme which keeps track of the good certificates is more secure, however. Suppose the CA operator is bribed to issue a certificate, using a serial number from a valid certificate, and that no audit log indicates that this bogus certificate has been issued. Nobody will know this certificate needs to be revoked, since no legitimate person knows it was ever issued. It will not be contained in the CRL.</p>
<p class="docText">Suppose instead that the CRL contains a list of all the valid certificates (and not just serial numbers, but hashes of the certificate for each serial number). Then the bogus certificate would not be honored, because it would not appear in the list of good certificates.</p>
<p class="docText">There are two interesting issues with good-lists:</p>
<ul><li><p class="docList">The good-list is likely to be much larger than the bad-list, and might change more frequently, so performance might be worse than with a bad-list.</p></li><li><p class="docList"><a name="iddle1274"></a><a name="iddle2138"></a>An organization might not want to make the list of its valid certificates public. This is easily answered by having the published good-list contain <span class="docEmphasis">only</span> hashes of valid certificates, rather than any other identifying information.</p></li></ul>
<p class="docText">Note that usually the good-list or bad-list, especially if publicly readable, will contain only serial numbers and hashes of the certificates rather than any other identifiable information. Then the only information divulged is the number of valid certificates (in the good-list case) or invalid certificates (in the bad-list case). There is no reason to believe that the count of good certificates is more security sensitive than the count of bad certificates.</p>
<p class="docText">The X.509 standard says it is not permitted to issue two certificates with the same serial number, and that all certificates issued must be logged. But we can't assume that a bad guy would be hindered from issuing bogus, unaudited certificates just because it would violate the specification!</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>