<html><head><title>13.4. Logging Into the Network</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch13lev1sec4"></a>
<h3 id="title-IDAKAZNR" class="docSection1Title">13.4. Logging Into the Network</h3>
<p class="docText">By way of introduction, let's look at the steps that take place as Alice uses the network. She'll expect the login procedure to be pretty much the same as for logging into an operating system. First, the workstation prompts Alice for a name and a password.</p>
<a name="ch13lev2sec1"></a>
<h4 id="title-IDAVAZNR" class="docSection2Title">13.4.1. Obtaining a Session Key and TGT</h4>
<p class="docText">Alice types her account name and password at the workstation. The workstation sends a message to the KDC, in the clear (unencrypted), which gives Alice's account name. On receipt of the request, the KDC returns credentials to the KDC, encrypted with Alice's master key. The credentials consist of</p>
<ul><li><p class="docList">a session key <span class="docEmphasis">S</span><sub>A</sub> (a secret key to be used during the login session).</p></li><li><p class="docList">a ticket-granting ticket (TGT). The TGT contains the session key, the user's name, and an expiration time, encrypted with <span class="docEmphasis">K</span><sub>KDC</sub>. Because it is encrypted with the KDC's master key, the TGT is an unintelligible bunch of bits to anyone other than the KDC.</p></li></ul>
<p class="docText">These credentials are sent back to the workstation encrypted with Alice's master key, <span class="docEmphasis">K</span><sub>A</sub>. Note that the information in the TGT is therefore doubly encrypted when transmitted by the KDCÂfirst with <span class="docEmphasis">K</span><sub>KDC</sub> and then with <span class="docEmphasis">K</span><sub>A</sub>. Kerberos V4 is sometimes criticized for this minor performance suboptimality, since encrypting the already-encrypted TGT offers no security benefit.</p>
<p class="docText">The workstation converts the password Alice types into a DES key. When the workstation receives the credentials, it attempts to decrypt them using this DES key. If this decryption succeeds (which it will if Alice typed her password correctly), then the workstation discards Alice's master key (the key derived from her password), retaining instead the TGT and the session key.</p>
<p class="docText">Kerberos documentation refers to the request sent by the workstation to the KDC as a <span class="docEmphStrong">KRB_AS_REQ</span>, for <span class="docEmphStrong">Kerberos Authentication Server Request</span>. We'll call it <span class="docEmphStrong">AS_REQ</span>. The message in which the KDC returns the session key and TGT is known in the Kerberos documentation as a <span class="docEmphStrong">KRB_AS_REP</span>, for <span class="docEmphStrong">Kerberos Authentication Service Reply</span>. We'll call it <span class="docEmphStrong">AS_REP</span>.</p>
<p class="docText"></p><a name="ch13fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 13-1. Obtaining a TGT</h5>
</center></p><p class="docText">
<img border="0" alt="" width="500" height="122" src="13fig01.jpg" /></p>
<br />
<p class="docText"><a name="iddle1105"></a>Actually, Kerberos V4 does not prompt the user for her password until after the workstation has received the credentials from the KDC. This is because Kerberos V4 was very serious in following the generally good security rule of having the workstation know the user's password for the minimum time possible. Waiting the few seconds to get the credentials before asking the user for the password really doesn't enhance security significantly, and in fact V5 has the user type the password before the workstation sends the AS_REQ. The reason V5 changed the order was that V5 requires the workstation to prove it knows the user's password before it sends the credentials, which makes it less easy to obtain a quantity with which to do off-line password guessing. An eavesdropper will still be able to do off-line password guessing with V5, but in V4 all you have to do is send the name <span class="docEmphRomanAlt">Alice</span> to the KDC and it will return a quantity with which you can do password guessing. This is likely to be easier than eavesdropping.</p>
<p class="docText">What is the purpose of the TGT? When Alice needs to access a remote resource, her workstation sends the TGT to the KDC along with a request for a ticket to the resource's node. The TGT contains the information the KDC needs about Alice's login session (session key, Alice's name, expiration time,...). This allows the KDC to operate without having any volatile data; it has a largely static database, and for each request it sends a response and then forgets that it happened. This offers a number of operational advantages, like making it easy to replicate the KDC and not having to maintain state across crashes.</p>
<p class="docText">An interesting variant might be to have the workstation generate the TGT (see <a class="docLink" href="ch13lev1sec13.html#ch13lev1sec13">Homework Problem 1</a>).</p>
<a name="ch13lev2sec2"></a>
<h4 id="title-IDAQEZNR" class="docSection2Title">13.4.2. Alice Asks to Talk to a Remote Node</h4>
<p class="docText">Suppose that after logging in as described above, Alice types a command that requires access to a remote node (like <span class="docEmphRomanAlt">rlogin Bob</span>, which logs Alice into Bob). The workstation sends to the KDC the TGT, the name <span class="docEmphRomanAlt">Bob</span>, and an <span class="docEmphStrong">authenticator</span> which proves that the workstation knows the session key. The authenticator consists of the time of day encrypted with the session key (in this case <span class="docEmphasis">S</span><sub>A</sub>). This request is known in the Kerberos documentation as a <span class="docEmphStrong">KRB_TGS_REQ</span>, and the reply is known as <span class="docEmphStrong">KRB_TGS_REP</span>; we'll call them <span class="docEmphStrong">TGS_REQ</span> and <span class="docEmphStrong">TGS_REP</span>. The TGS_REP contains a ticket to Bob and <span class="docEmphasis">K</span><sub>AB</sub> (the session key to be shared by Alice and Bob), encrypted with <span class="docEmphasis">S</span><sub>A</sub> (the session key to the KDC).</p>
<p class="docText">Because of the use of authenticators it is necessary for resources on the network to keep reasonably synchronized time. The times can be off by some amount. The allowable time skew is independently set at each server, and therefore some servers may be configured to be fussier than others about times being close. The allowed time skew is usually set to be on the order of five minutes on the assumption that it is possible to get computers' clocks to be accurate within five minutes without undue administrative burden. In practice, that assumption has turned out to be more problematic than expected. Distributed time services, once deployed, make much tighter synchronization straightforward.</p>
<p class="docText">It turns out that there is no security or functionality gained by having Kerberos require an authenticator when Alice's workstation requests a ticket to Bob. If someone who didn't know the session key transmitted the TGT and the name <span class="docEmphRomanAlt">Bob</span> to the KDC, the KDC would return information encrypted with <span class="docEmphasis">S</span><sub>A</sub>, which would be of no use to someone who didn't know Alice's session key. The reason the designers of Kerberos did it this way is to make the protocol for talking to the Ticket-Granting Service of the KDC be the same as for talking to other resources. When talking to most resources other than the KDC, the authenticator does provide security, because it prevents the replay of old requests and authenticates the sender (which is important if the reply is unencrypted).</p>
<p class="docText">The KDC decrypts the TGT (with <span class="docEmphasis">K</span><sub>KDC</sub>) and discovers the session key <span class="docEmphasis">S</span><sub>A</sub>. It also checks the expiration time in the TGT. If the TGT is valid, the KDC constructs a new key <span class="docEmphasis">K</span><sub>AB</sub>, for use in talking between Alice and Bob, and constructs a <b><a class="docLink" href="app02.html#gloss01_224">ticket</a></b>, which consists of the newly generated key <span class="docEmphasis">K</span><sub>AB</sub>, the name <span class="docEmphRomanAlt">Alice</span>, and an expiration time, all encrypted with Bob's master key, <span class="docEmphasis">K</span><sub>B</sub>. The KDC sends the ticket, along with the name <span class="docEmphRomanAlt">Bob</span> and <span class="docEmphasis">K</span><sub>AB,</sub> to the workstation. Again this information must be encrypted, and it is encrypted with <span class="docEmphasis">S</span><sub>A</sub>. On receipt, the workstation decrypts the information using <span class="docEmphasis">S</span><sub>A</sub>.</p>
<p class="docText">Now the workstation sends a request to Bob. In the Kerberos documentation this request is called a <span class="docEmphStrong">KRB_AP_REQ</span>, for <span class="docEmphasis">application request</span>, which we'll call <span class="docEmphStrong">AP_REQ.</span> It consists of the ticket and an authenticator (in this case the time encrypted with the session key <span class="docEmphasis">K</span><sub>AB</sub>). The reply from Bob is known in Kerberos as <span class="docEmphStrong">KRB_AP_REP</span>, and we'll call it <span class="docEmphStrong">AP_REP</span>. Bob decrypts the ticket and discovers the key <span class="docEmphasis">K</span><sub>AB</sub> and the name <span class="docEmphRomanAlt">Alice</span>. Bob now assumes that anyone with knowledge of <span class="docEmphasis">K</span><sub>AB</sub> is acting on Alice's behalf. Then Bob decrypts the authenticator to know that the party to which he is speaking does indeed know the session key <span class="docEmphasis">K</span><sub>AB</sub>. He checks that the time in the decrypted authenticator is close to current (within five minutes) to ensure that this is not a replay of some earlier request.</p>
<p class="docText">To make sure it is not a replay of a request recent enough to look current given the time skew, Bob should keep all timestamps he has received recently, say in the last five minutes (a parameter set appropriately for the maximum allowable time skew) and check that each received timestamp from a given source is different from any of the stored values. Any authenticator older than five minutes (or whatever the value of the maximum allowable time skew) would be rejected anyway, so Bob need not remember values older than 5 minutes. Kerberos V4 doesn't bother saving timestamps. Saving timestamps doesn't help anyway if Bob is a replicated service in which all the instances of Bob use the same master key. The threat of an eavesdropper replaying the authenticator Alice sent to one instance of Bob to a different instance of Bob could have been avoided if Kerberos had done something like put the network layer address of the instance of Bob in the authenticator.</p>
<a name="ch13fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 13-2. Getting a ticket to Bob for Alice</h5>
</center></p><p class="docText"><div class="v1"><a target="_blank" href="13fig02_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="176" src="13fig02.jpg" /></p>
<br />
<a name="ch13fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 13-3. Logging into Bob from Alice's workstation</h5>
</center></p><p class="docText">
<img border="0" alt="" width="500" height="139" src="13fig03.jpg" /></p>
<br />
<p class="docText">To provide mutual authentication, Bob adds one to the time he decrypted from the authenticator, reencrypts that with <span class="docEmphasis">K</span><sub>AB</sub> and sends it back. Alice's workstation is now reassured that it is talking to Bob, since the party at the other side was able to decrypt the ticket, which meant he knew <span class="docEmphasis">K</span><sub>AB</sub>, which was encrypted with <span class="docEmphasis">K</span><sub>B</sub>.</p>
<p class="docText">Thereafter, depending on the application, messages between Alice and Bob may be unprotected, integrity-protected, or encrypted and integrity-protected. Some applications always use the same Kerberos protection (authentication only, data integrity protection, or data encryption plus integrity protection). Others make it optional (a switch setting when calling the application). The decision is a security vs. performance trade-off when using Kerberos.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>