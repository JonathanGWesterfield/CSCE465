<html><head><title>6.5. Digital Signature Standard (DSS)</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="15051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch06lev1sec5"></a>
<h3 id="643999-859" class="docSection1Title">6.5. Digital Signature Standard (DSS)</h3>
<p class="docText"><a name="iddle1304"></a><a name="iddle1700"></a><a name="iddle2010"></a>NIST, the (U.S.) National Institute of Standards and Technology, has proposed an algorithm for digital signatures based on ElGamal. The algorithm is known as <span class="docEmphStrong">DSA</span>, for <span class="docEmphStrong">Digital Signature Algorithm</span>. As a proposed standard it is known as <b><a class="docLink" href="app02.html#gloss01_077">DSS</a></b>.</p>
<p class="docText">The differences between it and ElGamal mainly have to do with performance. Instead of all calculations being done mod <span class="docEmphasis">p</span> (where <span class="docEmphasis">p</span> is a 512-bit prime), some are done mod <span class="docEmphasis">q</span> (where <span class="docEmphasis">q</span> is a 160-bit prime which divides <span class="docEmphasis">p</span>-1). This makes the exponents 160 bits rather than 512 bits, which makes signing three times faster. However, there are other differences that make DSS slower than it might have been. In particular, an inverse calculation is required by both the signer and the verifier. DSS could easily have been defined to require only the signer to calculate an inverse. Instead, DSS allows the signer to precalculate its inverse before it even has a message, at the expense of requiring the verifier to also calculate an inverse.</p>
<p class="docText">But why should we make it more convenient for the signer, given that it's less convenient for the verifier? Presumably there is at least one verification for each signatureÂotherwise why would one bother signing anything?</p>
<p class="docText">There is one important application in which DSS's approach might be an important optimization: smart cards (see &sect;<a class="docLink" href="ch10lev1sec8.html#ch10lev1sec8">10.8</a> <span class="docEmphasis">Authentication Tokens</span>). A smart card is likely to have a very low-performance processor. It will have to do a signature in order for a user to successfully log in. If the operation of signing takes a long time, say two minutes or more, it will annoy the human who is trying to use the network.</p>
<p class="docText">Taking inverses is one of the most computationally expensive parts of generating a DSS signature. If it had to be done on a smart card at the time the user logged in, the user would be forced to wait many seconds. However, if the smart card generated some &lt;<span class="docEmphasis">S<sub>m</sub></span>, <span class="docEmphasis">S<sub>m</sub></span><sup>-1</sup>&gt; pairs while the user was logged in, then when the user next wants to log in, the smart card will have already done the requisite inverse operation.</p>
<p class="docText">The machines doing verifications, the DSS designers believe, will be fast machines, so doing an extra inverse operation will not be annoying.</p>
<a name="ch06lev2sec15"></a>
<h4 id="title-IDADNSEC" class="docSection2Title">6.5.1. The DSS Algorithm</h4>
<ul><li><p class="docList">Generate <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> (which will be public).</p><p class="docList">Find 160-bit prime <span class="docEmphasis">q</span>. Find a 512-bit prime <span class="docEmphasis">p</span> of the form <span class="docEmphasis">kq</span>+1. This is a very expensive operation, but it need not be done often. As a matter of fact it can be done once and the <span class="docEmphasis">p</span> can be published in the standard. Everyone can use the same <span class="docEmphasis">p</span>, with some caveats. It is rumored to be possible for someone to generate a <span class="docEmphasis">p</span> in such a way that someone can break cryptographic <a name="iddle1993"></a>operations based on that <span class="docEmphasis">p</span>, but no other someone would be able to tell that there was anything wrong with using that <span class="docEmphasis">p</span>. So having a particular <span class="docEmphasis">p</span> published in the standard as the one everyone should use is controversial. In addition, if there is a <span class="docEmphasis">p</span> that everyone uses, there is an efficiency gain (because you don't have to generate new <span class="docEmphasis">p</span>s and <span class="docEmphasis">q</span>s), but the chosen <span class="docEmphasis">p</span> presents a target for attacking the algorithm.</p></li><li><p class="docList">Generate <span class="docEmphasis">g</span> (which will be public).</p><p class="docList">Find a number <span class="docEmphasis">g</span> such that <span class="docEmphasis">g<sup>q</sup></span> = 1 mod <span class="docEmphasis">p</span>.</p><p class="docList">This is done by taking any random number <span class="docEmphasis">h</span> &gt; 1 and raising it to (<span class="docEmphasis">p</span>-1)/<span class="docEmphasis">q</span> to get <span class="docEmphasis">g</span>. Then, since <span class="docEmphasis">g</span> = <span class="docEmphasis">h</span><sup>(<span class="docEmphasis">p</span>-1)/<span class="docEmphasis">q</span></sup>, <span class="docEmphasis">g<sup>q</sup></span> = <span class="docEmphasis">h</span><sup><span class="docEmphasis">p</span>-1</sup> = 1 by Fermat's theorem.</p><p class="docList">(Actually, <span class="docEmphasis">h</span> can't be just <span class="docEmphasis">any</span> old random number. It is important that <span class="docEmphasis">g</span> not be 1, or else things will not be secure at all. So a new <span class="docEmphasis">h</span> is tried if <span class="docEmphasis">g</span> = <span class="docEmphasis">h</span><sup>(<span class="docEmphasis">p</span>-1)/<span class="docEmphasis">q</span></sup> turns out to be 1.)</p></li><li><p class="docList">Choose a long-term public/private key pair &lt;<span class="docEmphasis">T</span>, <span class="docEmphasis">S</span>&gt;.</p><p class="docList">This is done by choosing a random <span class="docEmphasis">S</span> &lt; <span class="docEmphasis">q</span> and setting <span class="docEmphasis">T</span> = <span class="docEmphasis">g<sup>S</sup></span> mod <span class="docEmphasis">p</span>.</p></li><li><p class="docList">Choose a per message public/private key pair &lt;<span class="docEmphasis">T<sub>m</sub></span>, <span class="docEmphasis">S<sub>m</sub></span>&gt;.</p><p class="docList">This is done by choosing a random <span class="docEmphasis">S<sub>m</sub></span> and setting <span class="docEmphasis">T<sub>m</sub></span> = ((<span class="docEmphasis">g<sup>S</sup>m</span> mod <span class="docEmphasis">p</span>) mod <span class="docEmphasis">q</span>).</p><p class="docList">While you're at it, calculate <span class="docEmphasis">S<sub>m</sub></span><sup>-1</sup> mod <span class="docEmphasis">q</span> so it won't need to be done in real time when signing the message.</p></li><li><p class="docList">Calculate a message digest <span class="docEmphasis">d<sub>m</sub></span> of the message.</p><p class="docList">The DSS has a sister function, <span class="docEmphStrong">SHS</span>, that is a hashing algorithm recommended by NIST for use with DSS. SHS happens to hash to 160 bits, but it is only coincidence that the size of the hash matches the size of <span class="docEmphasis">q</span>. 160 bits seemed a logical number for both because it's about the right size and it's a multiple of 32, so it's conveniently stored on machines with 32-bit words. DSS could be used with any hash function, though no security would be gained by using one longer than 160 bits.</p></li><li><p class="docList">Compute the signature <span class="docEmphasis">X</span> = <span class="docEmphasis">S<sub>m</sub></span><sup>-1</sup>(<span class="docEmphasis">d<sub>m</sub></span> + <span class="docEmphasis">ST<sub>m</sub></span>) mod <span class="docEmphasis">q</span>.</p></li><li><p class="docList">Transmit all relevant information:</p><blockquote><p></p><p class="docList">the message <span class="docEmphasis">m</span>;</p><p></p><p class="docList">the per-message public number <span class="docEmphasis">T<sub>m</sub></span>;</p><p></p><p class="docList">the signature <span class="docEmphasis">X</span>.</p></blockquote><p class="docList">The public key information, consisting of <span class="docEmphasis">T</span>, <span class="docEmphasis">p</span>, <span class="docEmphasis">q</span>, and <span class="docEmphasis">g</span>, is known beforehand and doesn't need to be transmitted with the message.</p></li><li><p class="docList">Verify the signature:</p><blockquote><p></p><p class="docList"><a name="iddle1396"></a><a name="iddle1718"></a>Calculate the mod <span class="docEmphasis">q</span> inverse of the signature, <span class="docEmphasis">X</span><sup>-1</sup>.</p><p></p><p class="docList">Calculate <span class="docEmphasis">d<sub>m</sub></span>.</p><p></p><p class="docList">Calculate <span class="docEmphasis">x</span> = <span class="docEmphasis">d<sub>m</sub></span>&#183; <span class="docEmphasis">X</span><sup>-1</sup> mod <span class="docEmphasis">q</span>.</p><p></p><p class="docList">Calculate <span class="docEmphasis">y</span> = <span class="docEmphasis">T<sub>m</sub></span>&#183; <span class="docEmphasis">X</span><sup>-1</sup> mod <span class="docEmphasis">q</span>.</p><p></p><p class="docList">Calculate <span class="docEmphasis">z</span> = (<span class="docEmphasis">g<sup>x</sup></span> &#183; <span class="docEmphasis">T<sup>y</sup></span> mod <span class="docEmphasis">p</span>) mod <span class="docEmphasis">q</span>.</p><p></p><p class="docList">If <span class="docEmphasis">z</span> = <span class="docEmphasis">T<sub>m</sub></span>, then the signature is verified.</p></blockquote></li></ul>
<a name="ch06lev2sec16"></a>
<h4 id="title-IDAVYSEC" class="docSection2Title">6.5.2. Why Does the Verification Procedure Work?</h4>
<p class="docText">Let <span class="docEmphasis">v</span> = (<span class="docEmphasis">d<sub>m</sub></span> + <span class="docEmphasis">ST<sub>m</sub></span>)<sup>-1</sup> mod <span class="docEmphasis">q</span>. Then,</p>
<blockquote><p></p><p class="docList"><span class="docEmphasis">X</span><sup>-1</sup> = (<span class="docEmphasis">S<sub>m</sub></span><sup>-1</sup>(<span class="docEmphasis">d<sub>m</sub></span> + <span class="docEmphasis">ST<sub>m</sub></span>))<sup>-1</sup> = <span class="docEmphasis">S<sub>m</sub></span>(<span class="docEmphasis">d<sub>m</sub></span> + <span class="docEmphasis">ST<sub>m</sub></span>)<sup>-1</sup> = <span class="docEmphasis">S<sub>m</sub>v</span> mod <span class="docEmphasis">q</span>,</p><p></p><p class="docList"><span class="docEmphasis">x</span> = <span class="docEmphasis">d<sub>m</sub></span>&#183; <span class="docEmphasis">X</span><sup>-1</sup> = <span class="docEmphasis">d<sub>m</sub>S<sub>m</sub>v</span> mod <span class="docEmphasis">q</span>,</p><p></p><p class="docList"><span class="docEmphasis">y</span> = <span class="docEmphasis">T<sub>m</sub></span>&#183; <span class="docEmphasis">X</span><sup>-1</sup> = <span class="docEmphasis">T<sub>m</sub>S<sub>m</sub>v</span> mod <span class="docEmphasis">q</span>,</p><p></p><p class="docList"><span class="docEmphasis">z</span> = <span class="docEmphasis">g<sup>x</sup></span> &#183; <span class="docEmphasis">T<sup>y</sup></span> = <span class="docEmphasis">g<sup>d<sub>m</sub>S<sub>m</sub>v</sup>g<sup>ST<sub>m</sub>S<sub>m</sub>v</sup></span> = <span class="docEmphasis">g</span><sup>(<span class="docEmphasis">d<sub>m</sub></span>+<span class="docEmphasis">ST<sub>m</sub></span>)<span class="docEmphasis">S<sub>m</sub>v</span></sup> = <span class="docEmphasis">g<sup>S</sup>m</span> = <span class="docEmphasis">T<sub>m</sub></span> mod <span class="docEmphasis">p</span> mod <span class="docEmphasis">q</span>.</p><p></p><p class="docList">(We're not worried about the mod <span class="docEmphasis">q</span> in the exponents of <span class="docEmphasis">g</span> since <span class="docEmphasis">g<sup>q</sup></span> = 1 mod <span class="docEmphasis">p</span>.)</p></blockquote>
<a name="ch06lev2sec17"></a>
<h4 id="title-IDAR4SEC" class="docSection2Title">6.5.3. Why Is This Secure?</h4>
<p class="docText">What does it mean to be secure? It means several things.</p>
<ul><li><p class="docList">Signing something does not divulge the private key <span class="docEmphasis">S</span>.</p></li><li><p class="docList">Nobody should be able to generate a signature for a given message without knowing <span class="docEmphasis">S</span>.</p></li><li><p class="docList">Nobody should be able to generate a message that matches a given signature.</p></li><li><p class="docList">Nobody should be able to modify a signed message in a way that keeps the same signature valid.</p></li></ul>
<p class="docText">Why does DSS have all these properties? The Fundamental Tenet of Cryptography (nobody knows how to break it). DSS also has the blessing of the NSA, arguably the best cryptographers in the world. Unfortunately it's a mixed blessing, since some cynics believe NSA would never propose an algorithm it couldn't break.</p>
<a name="ch06lev2sec18"></a>
<h4 id="title-IDAZ5SEC" class="docSection2Title">6.5.4. The DSS Controversy</h4>
<p class="docText"><a name="iddle1323"></a><a name="iddle1701"></a><a name="iddle1845"></a><a name="iddle2093"></a>DSS was published by NIST on August 30, 1991 as a proposed standard for digital signatures. NIST announced a 90-day comment period, which sparked a flurry of debate and an extension of the comment period. At the time of this writing the debate continues with no end in sight.</p>
<p class="docText">The hidden (or sometimes not hidden) question in the debate over DSS is why NIST chose a variant of ElGamal rather than standardizing on RSA, which had become the de facto industry standard. The arguments about standardizing on DSS are:</p>
<ul><li><p class="docList">Test of timeÂDSS may have undetected flaws, since it has not be subjected to the intense scrutiny of RSA.</p></li><li><p class="docList">Mandated 512-bit/160-bit moduliÂDSS fixes the key length at 512 bits for <span class="docEmphasis">p</span> and 160 bits for <span class="docEmphasis">q</span>. It is true that a DSS key of 512 bits might be a little more secure than a 512-bit RSA key, because the RSA key is a composite number and the DSS key is a prime, but it certainly won't be as secure as a 600-bit RSA key. According to calculations made by Ron Rivest [<a class="docLink" href="biblio01.html#biblio01_141">RIVE91b</a>], a determined and well-financed attacker, say with a budget of $25 million, could break DSS with a 512-bit modulus in a year. [NIST has responded by allowing key lengths up to 1024 bits for <span class="docEmphasis">p</span>.]</p></li><li><p class="docList">Since choosing a DSS &lt;<span class="docEmphasis">p</span>, <span class="docEmphasis">q</span>, <span class="docEmphasis">g</span>&gt; triple is computationally expensive, it is likely that many people will base their own key on parameters that have been published. With RSA, an attacker that breaks a key breaks only a single key. With DSS, an attacker that breaks a &lt;<span class="docEmphasis">p</span>, <span class="docEmphasis">q</span>, <span class="docEmphasis">g</span>&gt; triple breaks all keys upon which it is based.</p></li><li><p class="docList">Trapdoor primesÂAnother problem with using a published &lt;<span class="docEmphasis">p</span>, <span class="docEmphasis">q</span>, <span class="docEmphasis">g</span>&gt; triple is that you have to trust the source. It is possible for the source to generate a triple that is &quot;pre-broken&quot; in the sense that the source knows how to forge signatures for any key based on that triple. It's been claimed that the sample &lt;<span class="docEmphasis">p</span>, <span class="docEmphasis">q</span>, <span class="docEmphasis">g</span>&gt; published in the DSS document is suspicious, in that it has interesting mathematical properties which make it unlikely that it was chosen at random. This does not by any means prove that it is pre-broken, but it does make people nervous.</p></li><li><p class="docList">PerformanceÂDSS is about a hundred times slower for signature verification than RSA with <span class="docEmphasis">e</span> = 3, and in many applications, signature verification happens frequently and is performance-sensitive. In terms of the other operations, DSS is much faster for key generation, though for most applications the performance of key generation is not an issue since it is not done frequently. RSA and DSS are similar in performance for generating signatures, though DSS has the advantage that some of the signature computation can be precomputed before seeing the message. The NIST reasoning is that for the application of smart cards, this ability to precompute for signatures makes DSS superior, since a human will not need to wait as long when logging into a system.</p></li><li><p class="docList"><a name="iddle1324"></a><a name="iddle1784"></a><a name="iddle1792"></a><a name="iddle1823"></a><a name="iddle1854"></a><a name="iddle1938"></a><a name="iddle1955"></a>DSS requires choosing a unique secret number for each message. There are several ways of doing this, but they all have problems (see next section).</p></li><li><p class="docList">PatentsÂOne of the advantages of DSS was that it was not owned by RSADSI or PKP (which own exclusive rights to most other public key techniques) and could be used royalty-free. PKP subsequently acquired a patent by Schnorr, which it claims covers DSS. NIST has never conceded that Schnorr covers DSS, and at this time the issue remains unresolved.</p></li></ul>
<a name="ch06lev2sec19"></a>
<h4 id="title-IDAYETEC" class="docSection2Title">6.5.5. Per-Message Secret Number</h4>
<blockquote>
<p class="docText"><span class="docEmphasis">Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin.</span></p>
<p class="docText">ÂJohn Von Neumann (1951)</p></blockquote>
<p class="docText">Both DSS and ElGamal require that the signer generate a unique secret number for each message. If the same secret number were used for two different messages, it would expose the signer's private key. Likewise, if a secret number were predictable or guessable, the signer's private key would be exposed.</p>
<p class="docText">How is the private key exposed if the secret number for a message is known? In DSS, the signature is <span class="docEmphasis">X<sub>m</sub></span> = <span class="docEmphasis">S<sub>m</sub></span><sup>-1</sup>(<span class="docEmphasis">d<sub>m</sub></span> + <span class="docEmphasis">ST<sub>m</sub></span>) mod <span class="docEmphasis">q</span>. Remember that <span class="docEmphasis">S<sub>m</sub></span> is the secret number, <span class="docEmphasis">d<sub>m</sub></span> is the message digest, <span class="docEmphasis">T<sub>m</sub></span> is <span class="docEmphasis">g<sup>S<sub>m</sub></sup></span> mod <span class="docEmphasis">p</span> mod <span class="docEmphasis">q</span>, and <span class="docEmphasis">S</span> is the signer's private key. So if <span class="docEmphasis">S<sub>m</sub></span> is known, then we can compute</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="1"><col width="400"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">(<span class="docEmphasis">X<sub>m</sub>S<sub>m</sub></span> - <span class="docEmphasis">d<sub>m</sub></span>)<span class="docEmphasis">T<sub>m</sub></span><sup>-1</sup> mod <span class="docEmphasis">q</span> = <span class="docEmphasis">S</span> mod <span class="docEmphasis">q</span></p></td></tr></table></p><br />
<p class="docText">This is all we need to forge DSS signatures.</p>
<p class="docText">How is the private key exposed when two messages share the same secret number? In DSS, if <span class="docEmphasis">m</span> and <span class="docEmphasis">m</span>' are signed using the same secret number <span class="docEmphasis">S<sub>m</sub></span>, then we can compute</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="500"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">(<span class="docEmphasis">X<sub>m</sub></span> - <span class="docEmphasis">X<sub>m'</sub></span>)<sup>-1</sup>(<span class="docEmphasis">d<sub>m</sub></span> - <span class="docEmphasis">d<sub>m'</sub></span>) mod <span class="docEmphasis">q</span> = <span class="docEmphasis">S<sub>m</sub></span> mod <span class="docEmphasis">q</span></p></td></tr></table></p><br />
<p class="docText">This is enough to compute <span class="docEmphasis">S</span> mod <span class="docEmphasis">q</span> as we did above, allowing us to forge signatures.</p>
<p class="docText">Similar arguments exist for ElGamal signatures. See <a class="docLink" href="ch06lev1sec9.html#ch06qa1q10">Homework Problem 10</a>.</p>
<p class="docText">There are several ways of generating a unique secret number for each message. Keep in mind that signatures might be done with a device with minimal computational ability.</p>
<ul><li><p class="docList">Use truly random numbers. The problem with this is that it requires special hardware. It's difficult enough to make hardware predictable, but it's even harder to make it predictably unpredictable.</p></li><li><p class="docList"><a name="iddle1279"></a><a name="iddle1436"></a><a name="iddle1570"></a>Use a cryptographic pseudo-random number generator. The problem with this is that it requires nonvolatile storage in order to store its state.</p></li><li><p class="docList">Use a cryptographic hash of a combination of the message and the signer's private key. The problem with this is that it can't be computed until the message is known, eliminating a claimed advantage of DSS and ElGamal over RSA.</p></li></ul>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="15051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>