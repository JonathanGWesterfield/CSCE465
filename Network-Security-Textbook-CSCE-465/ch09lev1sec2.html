<html><head><title>9.2. Address-Based Authentication</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="16051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch09lev1sec2"></a>
<h3 id="643999-886" class="docSection1Title">9.2. Address-Based Authentication</h3>
<blockquote>
<p class="docText"><span class="docEmphasis">It's not what you know. It's where you are.</span></p>
</blockquote>
<p class="docText"><span class="docEmphStrong">Address-based authentication</span> does not rely on sending passwords around the network, but rather assumes that the identity of the source can be inferred based on the network address from which packets arrive. It was adopted early in the evolution of computer networks by both UNIX and VMS. The basic idea is that each computer stores information which specifies accounts on other computers that should have access to its resources. For instance, suppose account name <span class="docEmphRomanAlt">Smith</span> on the machine residing at network address <span class="docEmphasis">N</span> is allowed access to computer <span class="docEmphasis">C</span>. Requests for resources are commands like <span class="docEmphRomanAlt">copy a specified file</span>, <span class="docEmphRomanAlt">log in</span>, or <span class="docEmphRomanAlt">execute the following command at the specified remote machine</span>. If a request arrives from address <span class="docEmphasis">N</span> claiming to be sent on behalf of user Smith, then <span class="docEmphasis">C</span> will honor the request.</p>
<p class="docText">On UNIX, the <span class="docEmphasis">Berkeley rtools</span> support such access; on VMS, similar functionality is called <span class="docEmphasis">PROXY</span>. The general idea can be implemented in various ways.</p>
<ul><li><p class="docList">Machine <span class="docEmphasis">B</span> might have a list of network addresses of &quot;equivalent&quot; machines. If machine <span class="docEmphasis">A</span> is listed, then any account name on <span class="docEmphasis">A</span> is equivalent to the same account name on <span class="docEmphasis">B</span>. If a request from <span class="docEmphasis">A</span> arrives with the name <span class="docEmphRomanAlt">JohnSmith</span>, then the request will be honored if it is for anything that the account <span class="docEmphRomanAlt">JohnSmith</span> on <span class="docEmphasis">B</span> was allowed to do. This has the problem that the user has to have the identical account name on all systems.</p></li><li><p class="docList">Machine <span class="docEmphasis">B</span> might instead have a list of &lt;address, remote account name, local account name&gt;. If a request arrives from address <span class="docEmphasis">A</span> with the name <span class="docEmphRomanAlt">Jekyll</span>, then the database is scanned for the matching entry, say &lt;<span class="docEmphasis">A</span>, <span class="docEmphRomanAlt">Jekyll</span>, <span class="docEmphRomanAlt">Hyde</span>&gt;. Then the request is honored provided the local account <span class="docEmphRomanAlt">Hyde</span> is authorized to do the request.</p></li></ul>
<p class="docText">UNIX implements two account mapping schemes:</p>
<ul><li><p class="docList"><span class="docEmphRomanAlt">/etc/hosts.equiv</span> file. There is a global file (named <span class="docEmphRomanAlt">/etc/hosts.equiv</span>) which implements the first scheme above. The file <span class="docEmphRomanAlt">/etc/hosts.equiv</span> on machine <span class="docEmphasis">A</span> contains a list of computers that have identical user account assignments. Suppose a computer <span class="docEmphasis">B</span> is listed in <span class="docEmphRomanAlt">/etc/hosts.equiv</span>. Suppose <span class="docEmphasis">A</span> receives a request with account name <span class="docEmphRomanAlt">Smith</span>, and <span class="docEmphasis">B</span>'s address in the source address field of the network header. If an account with the name <span class="docEmphRomanAlt">Smith</span> exists on machine <span class="docEmphasis">A</span>, the <a name="iddle1914"></a>request will be given the same privileges as the local user Smith. (Actually, an exception is made for the privileged account <span class="docEmphRomanAlt">root</span>; it will not be given access by virtue of an entry in <span class="docEmphRomanAlt">/etc/ hosts.equiv</span>). The <span class="docEmphRomanAlt">/etc/hosts.equiv</span> file is useful for managing corresponding accounts in bulk on machines with common accounts and common management.</p></li><li><p class="docList">Per-user <span class="docEmphRomanAlt">.rhosts</span> files. In each UNIX user's home directory, there can be a file named <span class="docEmphRomanAlt">.rhosts</span>, which contains a list of &lt;computer, account&gt; pairs that are allowed access to the user's account. Any user Bob can permit remote access to his account by creating a <span class="docEmphRomanAlt">.rhosts</span> file in his home directory. The account names need not be the same on the remote machine as they are on this one, so Bob can handle the case where he has different account names on different systems. Because of the way the information is organized, any request that is <span class="docEmphasis">not</span> for an account named the same as the source account must include the name of the account that should process the request. For instance, if the local account name on system <span class="docEmphasis">A</span> is <span class="docEmphRomanAlt">Bob</span> and the request is from computer <span class="docEmphasis">B</span>, account name <span class="docEmphRomanAlt">Smith</span>, the request has to specify that it would like to be treated with the privileges given account name <span class="docEmphRomanAlt">Bob</span>. (See <a class="docLink" href="ch09lev1sec10.html#ch09qa1q1">Homework Problem 1</a>.)</p></li></ul>
<p class="docText">On VMS, individual users are not permitted to establish their own proxy access files. (This is considered a security feature to prevent users from giving access to their friends). Instead, there is a centrally managed <span class="docEmphStrong">proxy database</span> that says for each remote &lt;computer, account&gt; pair what account(s) that pair may access, usually with one of them marked as the default. For example, there might be an entry specifying that account <span class="docEmphRomanAlt">Smith</span> from address <span class="docEmphasis">B</span> should have access to local accounts <span class="docEmphRomanAlt">Bob</span> and <span class="docEmphRomanAlt">Alice</span>, where the account <span class="docEmphRomanAlt">Bob</span> might be marked as the default.</p>
<p class="docText">The VMS scheme makes access somewhat more user-friendly than the UNIX scheme in the case where a user has different account names on different systems. Generally (in VMS) the user need not specify the target account in that case. In the rare case where a user is authorized to access multiple accounts on the remote computer, a target account can be specified in the request to access an account other than the default. (In UNIX, it is always necessary to specify the target account in the request if the account name is different.)</p>
<p class="docText">Address-based authentication is safe from eavesdropping, but is subject to two other threats:</p>
<ul><li><p class="docList">If someone, say Trudy, gains privilege on a node FOO, she can access all users' resources of FOOÂthere's nothing authentication can do about that. But in addition, she can access the network resources of any user with an account on FOO by getting FOO to claim the request comes from that user. Theoretically, it is not obvious how Trudy, once she gains access to FOO, would know which other machines she could invade, since the &lt;machine, account&gt; pairs reachable from &lt;<span class="docEmphRomanAlt">FOO</span>, <span class="docEmphRomanAlt">Smith</span>&gt; are not listed at FOO, but are instead listed at the remote machine. However, in a lot of cases, if &lt;<span class="docEmphRomanAlt">FOO</span>, <span class="docEmphRomanAlt">Smith</span>&gt; allows proxy access from &lt;<span class="docEmphRomanAlt">BAR</span>, <span class="docEmphRomanAlt">JohnS</span>&gt;, then it is likely that node BAR specifically allows account <span class="docEmphRomanAlt">Smith</span> at node FOO access to account <span class="docEmphRomanAlt">JohnS</span> at BAR. So Trudy, once she has privileges on FOO, can scan the proxy database (in the case of VMS) or the <span class="docEmphRomanAlt">/etc/hosts.equiv</span> file and the <span class="docEmphRomanAlt">.rhosts</span> files of each <a name="iddle1884"></a>of the users (in the case of UNIX), and make a guess that any &lt;node, account name&gt; pairs she finds are likely to let her in from node FOO with the specified account name.</p></li><li><p class="docList">If someone on the network, say Trudy, can impersonate network addresses of nodes, she can access all the network resources of all users who have accounts on any of those nodes. It is often relatively easy to impersonate a network address. For instance, on broadcast LANs (like Ethernet and Token Ring), it is easy not only to send traffic with the address of a different node on that LAN, but also to receive traffic destined for that node. In many other cases, although it is easy to transmit a packet that has a false source address, the returning traffic would be delivered to the real node rather than the impersonating node.</p></li></ul>
<p class="docText">Depending on the environment, therefore, address-based authentication may be more or less secure than sending passwords in the clear. It is unquestionably more convenient and is the authentication mechanism of choice in many distributed systems deployed today.</p>
<a name="ch09lev2sec3"></a>
<h4 id="title-IDAR3FCE" class="docSection2Title">9.2.1. Network Address Impersonation</h4>
<blockquote>
<p class="docText"><span class="docEmphasis">The wire protocol guys don't worry about security because that's really a network protocol problem. The network protocol guys don't worry about it because, really, it's an application problem. The application guys don't worry about it because, after all, they can just use the IP address and trust the network.</span></p>
<p class="docText">ÂMarcus Ranum</p></blockquote>
<p class="docText">How can Trudy impersonate Alice's network address? Generally it is easy to transmit a packet claiming any address as the source address, either at the network layer or the data link layer. Sometimes it is more difficult. For instance, due to the design of token rings, if Trudy and Alice were on the same ring and Trudy were to transmit a packet using Alice's data link address, then Alice might remove Trudy's packet from the ring or raise a duplicate address error. Another example is star-topology LANs, where each node is connected via a point-to-point link to a central hub. A hub might learn (or be configured with) the data link address of the node on each link, and refuse to forward a packet if the data link source address is not correct for that line, though a hub (being a layer 2 device) is unlikely to check the network layer (layer 3) source address.</p>
<p class="docText">A router could also have features to make it difficult for someone to claim to be a different network address. If a router has a point-to-point link to an endnode, it could (like the hub) refuse to accept a packet if the network layer source address is not correct according to the router's configuration. A router could also be configured, on a per-link basis, with a set of addresses that it should expect to appear on each link, and refuse packets with unexpected source addresses. Perhaps if the routers were all trusted, and authentication were added to routing messages to prevent someone <a name="iddle1081"></a><a name="iddle2019"></a>from injecting bad routing messages, then a router would not need to be configured on a per-link basis with a set of expected source addresses, but instead could derive the per-link expected source addresses from the routing database.</p>
<p class="docText">It is often more difficult for Trudy to receive messages addressed to Alice's network address than for Trudy to claim Alice's address as the source address. If Trudy is on the same LAN as Alice, it is trivialÂTrudy just needs to listen to packets addressed to Alice's data link address. If Trudy is not on the same LAN as Alice, but is on one of the LANs in the path between the source and Alice, it's a little harder but still easy. The reason it's a little harder is that Trudy would need to listen to all packets address to the data link address of the router that forwards packets towards Alice from the LAN on which Trudy resides. This is harder than listening to Alice's data link address because a router will probably be receiving packets for many destinations, and Trudy will have to be fast enough to ignore the messages that aren't specifically for Alice.</p>
<p class="docText">If Trudy is not on the same LAN as Alice, and not on the path between the source and Alice, then it is more difficult for Trudy to receive packets addressed to Alice. Trudy could potentially inject routing messages that would trick the routers into sending traffic for Alice's address to Trudy. It is possible to add a cryptographic authentication mechanism to router messages which would prevent Trudy from injecting routing information.</p>
<p class="docText">Even with cryptographic authentication of routers, it may be possible for Trudy to be able to both transmit from and receive packets for Alice's network address. For instance, in IP, there is a feature known as <span class="docEmphasis">source routing</span>, in which Trudy can inject an IP packet containing not just a source address (Alice's network address) and destination address D, but also a <span class="docEmphasis">source route</span> that gives intermediate destinations. IP will route to each intermediate destination in turn. Assume Trudy uses the source route &lt;<span class="docEmphRomanAlt">Alice</span>, <span class="docEmphRomanAlt">Trudy</span>, <span class="docEmphRomanAlt">D</span>&gt;. The applications that run on IP that do address-based authentication will use the field <span class="docEmphRomanAlt">Alice</span> for the address check. When D receives a packet from Alice via source route &lt;<span class="docEmphRomanAlt">Alice</span>, <span class="docEmphRomanAlt">Trudy</span>, <span class="docEmphRomanAlt">D</span>&gt;, then D, following the IP host requirements document (RFC 1122), will reply with source route &lt;<span class="docEmphRomanAlt">D</span>, <span class="docEmphRomanAlt">Trudy</span>, <span class="docEmphRomanAlt">Alice</span>&gt;. The return traffic will go to Trudy.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="16051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>