<html><head><title>26.25. Forward Compatibility</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch26lev1sec24.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch26lev1sec26.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch26lev1sec25"></a>
<h3 id="title-IDA3WZ4D" class="docSection1Title">26.25. Forward Compatibility</h3>
<p class="docText">History shows that protocols evolve. It is important to design a protocol in such a way that new capabilities can be added. This is a desirable property of any sort of protocol, not just security protocols. There are some special security considerations in evolving protocols, such as preventing an active attacker from tricking two parties into using an older, possibly less secure version of the protocol.</p>
<a name="ch26lev2sec4"></a>
<h4 id="title-IDAIXZ4D" class="docSection2Title">26.25.1. Options</h4>
<p class="docText">It is useful to allow new fields to be added to messages in future versions of the protocol. Sometimes these fields can be ignored by implementations that don't support them. Sometimes a packet with an unsupported option should be dropped. In order to make it possible for an implementation that does not recognize an option to skip over it and parse the rest of the message, it is essential that there be some way to know where the option ends. There are two techniques:</p>
<ul><li><p class="docList">Having a special marker at the end of the option. This tends to be computation-intensive, since the implementation must read all the option data as it searches for the end marker.</p></li><li><p class="docList">TLV encoding, which means each option starts with a <span class="docEmphSmaller">TYPE</span> field indicating the type of option, a <span class="docEmphSmaller">LENGTH</span> field indicating the length of the data in this option, and a <span class="docEmphSmaller">VALUE</span> field, which gives option-specific information.</p></li></ul>
<p class="docText">TLV encoding is more common because it is more efficient. However, the &quot;L&quot; must always be present, and in the same units, in order for implementations to be able to skip unknown options. Sometimes protocol designers who don't quite understand the concept of TLV encoding do clever <a name="iddle1218"></a>things like notice that the option they are defining is fixed length, so they don't need the <span class="docEmphSmaller">LENGTH</span> field. Or that one option might be expressed in different units. For instance, although AH (see &sect;<a class="docLink" href="ch17lev1sec3.html#ch17lev1sec3">17.3</a> <span class="docEmphasis">AH (Authentication Header)</span> is designed to look like an IPv6 extension header, its length is expressed in units of 32-bit words, when all the other IPv6 options are expressed in units of 64-bit words.</p>
<p class="docText">It is also useful to be able to add some options which should simply be skipped over by an implementation that does not support it, and to add other options which must be understood or else the packet must be dropped. But if an implementation does not recognize the option, how would it know whether it could be safely ignored or not? There are several possible solutions. One is to have a flag in the option header known as the <span class="docEmphStrong">critical bit</span>, which if not set on an unknown option, indicates the option can simply be skipped over and ignored. Another possibility is to reserve some of the type numbers for critical options, and some of them for noncritical options (those that can be safely skipped if unrecognized).</p>
<a name="ch26lev2sec5"></a>
<h4 id="title-IDAOZZ4D" class="docSection2Title">26.25.2. Version Numbers</h4>
<p class="docText">A lot of protocols have a field for version number, but don't specify what to do with it. IKE and SSL are typical culprits. The purpose of a version number field is to allow the protocol to change in the future without confusing old implementations. One way of doing this without a version number is to declare the modified protocol to be a &quot;new protocol&quot;, which would then need a different multiplexor value (a different TCP port for instance). With a version number, you can keep the same multiplexor value, but there have to be rules about handling version numbers so that an old implementation won't be confused by a redesigned packet format.</p>
<a name="ch26lev3sec1"></a>
<h5 id="title-IDAZZZ4D" class="docSection3Title">26.25.2.1. Version Number Field Must Not Move</h5>
<p class="docText">If versions are to be differentiated based on a version number field, then <span class="docEmphasis">the version number field must always be in the same place in the message</span>. Although this might seem obvious, when SSL was redesigned to be version 3, the version number field was moved! Luckily, there is a way to recognize which version an SSL message is (in version 2's client hello message, the first octet will be 128, and in version 3's client hello message, the first octet will be something between 20 and 23).</p>
<a name="ch26lev3sec2"></a>
<h5 id="title-IDAI0Z4D" class="docSection3Title">26.25.2.2. Negotiating Highest Version Supported</h5>
<p class="docText">Typically, when there is a new version of a protocol, the new implementations support both versions for some time. If you support both versions, how do you know what version to speak when talking to another node? Presumably the newer version is superior for some reason. So you typically first attempt to talk with the newer version, and if that fails, you attempt again with the older version. With this strategy it is important to make sure that two nodes that are both capable of speaking the new version wind up speaking the new version, and not getting fooled into speaking the older version because of lost messages or active attackers sending, deleting, or modifying messages. Why would an active attacker care enough to trick two nodes into speaking an earlier version of the protocol? Perhaps the newer version is more secure, or has features that the attacker would prefer the nodes not be able to use. (We'd hope there was <span class="docEmphasis">some</span> benefit to be gained by having designed a new version of the protocol!)</p>
<p class="docText">The right thing to do if you see a message with a higher version number than you support is to drop the message and send an error report to the other side indicating you don't support that version. But there will be no way for that error message to be cryptographically integrity-protected since the protocol has not been able to negotiate a key. So unless care is taken, nodes could be tricked into speaking the older version if an active attacker or network flakiness deleted the message of the initial attempt, or an attacker sent an <span class="docEmphRomanAlt">error: unsupported version number</span> message.</p>
<p class="docText">One method of ensuring that two nodes don't get tricked into talking an older version is to have two version numbers in the packet. One would be the version number of the packet. The other would be the highest version the sender supports. But a single bit suffices, indicating that the sender can support a higher version number than the message indicates. If you establish a connection with someone, using version <span class="docEmphasis">n</span>, and you support something higher than <span class="docEmphasis">n</span>, and you receive authenticated messages with the <span class="docEmphSmaller">HIGHER VERSION NUMBER SUPPORTED</span> flag, then you can attempt to reconnect with a higher version number.</p>
<a name="ch26lev3sec3"></a>
<h5 id="title-IDAL1Z4D" class="docSection3Title">26.25.2.3. Minor Version Number Field</h5>
<p class="docText">Another area in which protocol designers get confused is the proper use of a <span class="docEmphSmaller">MINOR VERSION NUMBER</span> field. Why should there be both <span class="docEmphSmaller">MAJOR VERSION NUMBER</span> and <span class="docEmphSmaller">MINOR VERSION NUMBER</span> fields? The proper use of a minor version number is to indicate new capabilities that are backward compatible. The major version number should change if the protocol is incompatible. The minor version number is informational only. If the node you are talking to indicates it is version <span class="docEmphRomanAlt">4.7</span> (where <span class="docEmphRomanAlt">4</span> is the major version number and <span class="docEmphRomanAlt">7</span> is the minor version), and you are version <span class="docEmphRomanAlt">4.3</span>, then you ignore the minor version number. But the version <span class="docEmphRomanAlt">4.7</span> node might use it to know that there are certain fields you wouldn't support, so it won't send them.</p>
<p class="docText">For instance, ISAKMP handles minor version numbers incorrectly. It has an 8-bit <span class="docEmphSmaller">VERSION NUMBER</span> field, split into 4 bits for <span class="docEmphSmaller">MAJOR VERSION</span>, and 4 bits for <span class="docEmphSmaller">MINOR VERSION</span>. The specification says you should reject a message if the major version is higher, or if the major versions are the same and the minor version is higher than yours. So the result is exactly the same as if it was just an 8-bit field, but it's more complicated to understand and will run out of numbers more quickly than an 8-bit field since there are only 16 major version numbers. (Unless someone worries about numbers getting used up and mandates that you must use up all the minor version numbers before you're allowed to bump the major version number.)</p>
<p class="docText"><a name="iddle1731"></a>Most likely the confusion about the proper use of the minor version number is because software releases have major and minor version numbers, and the choice as to which to increment is a marketing decision.</p>
<a name="ch26lev2sec6"></a>
<h4 id="title-IDAS3Z4D" class="docSection2Title">26.25.3. Vendor Options</h4>
<p class="docText">Another type of option is a vendor-defined option. The only difference between a vendor-defined option and the type of option we described in &sect;<a class="docLink" href="#ch26lev2sec4">26.25.1</a> <span class="docEmphasis">Options</span> is that a vendor-defined option might not be able to obtain one of the compact T values for specifying that option in TLV encoding. The organization that assigns T values might require that the option be publicly documented in order to obtain a number, and the vendor might want to keep their use proprietary. Or the vendor might want to experiment with the option before bothering to request a number. Or the vendor might fail to convince a standards organization to adopt the option, and T values might only be given to options that have been standardized.</p>
<p class="docText">If an option does not have one of the compact assigned T values, there must be a way for it to be assigned a unique number. ASN.1 defines a way to obtain OIDs, but OIDs are variable length. This complicates encoding of a vendor option. IKE encodes each vendor option in an explicit envelope with a type and length. The type code in the envelope is simply &quot;vendor option&quot; (i.e., the same for all vendor options). Inside the envelope is the specific vendor option data, and it is up to the vendor to define an encoding. Ideally the encoding is such that there is no potential ambiguity between different vendors' vendor options. This could be done by using an OID, or defining the first 16 octets to be a hash of information guaranteed to be unique, such as the vendor name, location, name of the capability, etc.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch26lev1sec24.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch26lev1sec26.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>