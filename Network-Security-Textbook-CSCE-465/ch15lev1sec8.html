<html><head><title>15.8. Authorization Futures</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch15lev1sec8"></a>
<h3 id="title-IDAAENHH" class="docSection1Title">15.8. Authorization Futures</h3>
<p class="docText">The two most important problems in network security are <span class="docEmphasis">Who are you?</span> and <span class="docEmphasis">Should you be doing that?</span> Authorization is the <span class="docEmphasis">Should you be doing that?</span> part of network security. In the remainder of this chapter we discuss how authorization could be done using PKI, although no deployed PKIs today do authorization as described here.</p>
<a name="ch15lev2sec21"></a>
<h4 id="title-IDAUENHH" class="docSection2Title">15.8.1. ACL (Access Control List)</h4>
<p class="docText">Typically the way a server decides whether a user should have access to a resource is by first authenticating the user, and then consulting a database associated with the resource that indicates who is allowed to do what with that resource. For instance, the database associated with a file might say that Alice can read it and Bob and Carol can both read and write it. This database is often referred to as an <b><a class="docLink" href="app02.html#gloss01_003">ACL (access control list)</a></b>.</p>
<a name="ch15lev2sec22"></a>
<h4 id="title-IDAJFNHH" class="docSection2Title">15.8.2. Central Administration/Capabilities</h4>
<p class="docText">Another model of authorization is that instead of listing, with each resource, the set of authorized users and their rights (e.g., <span class="docEmphasis">read</span>, <span class="docEmphasis">write</span>, <i><a class="docLink" href="app02.html#gloss01_089">execute</a></i>), you would have a database that listed, for each user, everything she was allowed to do. If everything were a single application, then the ACL model and the central administration model would be basically the same, since in both cases there would be a database that listed all the authorized users and what rights each had. But in a world in which there are many resources, not all under control of the same organization, it would be difficult to have a central database listing what each user was allowed to do, and it would have scaling problems if there were many resources each user was allowed to access, especially if resources were created and deleted at a high rate.</p>
<p class="docText">There might be a suite of applications all accessed through a single portal. For instance, you might log into the &quot;human resources&quot; suite of applications that would allow you to select whether you wanted to submit an expense report, record vacation time, or choose health care options. In this case you could consider the entire suite of applications as a single application with a common ACL, and even if rights for the suite are centrally administered, as long as the suite is considered as one application, it would be equivalent to the ACL model. However, it might become burdensome to have all the application-specific rights centrally administered. When the maintainer of the expense reporting application decided to add a new frill, say something that allows the user to preauthorize business class airfare, it might be easier to have an application-specific ACL that listed <span class="docEmphasis">preauthorize business class airfare</span> as one of the rights rather than adding it into the suite's ACL.</p>
<p class="docText">Some people worry that ACLs don't scale well if there are many users allowed access to each resource. But the concept of groups answers that concern.</p>
<a name="ch15lev2sec23"></a>
<h4 id="title-IDAMGNHH" class="docSection2Title">15.8.3. Groups</h4>
<p class="docText">If there is a file that should be accessible to, say, any Sun employee, it would be tedious to type in all the names of the authorized individuals, especially if there were more than one resource with the same authorizations. The concept of a <b><a class="docLink" href="app02.html#gloss01_098">group</a></b> was invented to make ACLs more scalable. It is possible to include a group name on an ACL, which means that any member of the group is allowed access to the resource.</p>
<p class="docText">Traditionally a server that protected a resource with a group named on the ACL needed to know all the members of the group. But it is useful to allow more flexible group mechanisms in order to support cross-organizational groups where no one server is allowed to know all the members, or anonymous groups, where someone can prove membership in the group without having to divulge their identity.</p>
<p class="docText">Traditionally groups were centrally administered, so it was easy to know all the groups to which a user belonged, and the user would not belong to many groups. But in many situations it is useful for any user to be able to create a group (such as <span class="docEmphRomanAlt">Alice's friends</span>, or <span class="docEmphRomanAlt">students who have already turned in their exams in my course</span>), and have anyone else be able to name such a group on an ACL.</p>
<p class="docText">Scaling up this simple concept of users, groups, and ACLs to a distributed environment has not been solved in practice. This section describes how it might be done. There exist secret-key-based systems (DCE, Windows NT, and Windows 2000/Kerberos) that distribute group membership information from a central server.</p>
<a name="ch15lev3sec3"></a>
<h5 id="title-IDAPHNHH" class="docSection3Title">15.8.3.1. Cross-Organizational and Nested Groups</h5>
<p class="docText">An ACL should be able to contain any boolean combination of groups and individuals. Likewise, group membership should be any boolean combination of groups and individuals, e.g., the members of <span class="docEmphRomanAlt">Alliance-executives</span> might be <span class="docEmphRomanAlt">CompanyA-execs</span>, <span class="docEmphRomanAlt">CompanyB-execs</span>, and <span class="docEmphRomanAlt">John Smith</span>. Each of the groups <span class="docEmphRomanAlt">Alliance-executives</span>, <span class="docEmphRomanAlt">CompanyA-execs</span>, and <span class="docEmphRomanAlt">CompanyB-execs</span> is likely to be managed by a different organization and the membership is likely to be stored on different servers. How, then, can a server that protects a resource that has the group <span class="docEmphRomanAlt">Alliance-executives</span> on the ACL know whether to allow Alice access? If she's not explicitly listed on the ACL, she might be a member of one of the groups on the ACL. But the server does not necessarily know all the members of the group. Let's assume that the group name can be looked up in a directory to find out information such as its network address and its public key.</p>
<ul><li><p class="docList">The server could periodically find every group on any ACL on any resource it protects, and attempt to collect the complete membership. This means looking up all the members of all subgroups, and subgroups of subgroups. This has scaling problems (the group memberships might be very large), performance problems (there might be a lot of traffic with servers querying group membership servers for membership lists), and cache staleness problems. How <a name="iddle1045"></a><a name="iddle1253"></a><a name="iddle1927"></a>often would this be done? Once a day is a lot of traffic, but also a lot of time to elapse for Alice's group membership to take effect, and for revocations to take effect.</p></li><li><p class="docList">The server could ask the on-line group server whether Alice is a member of the group at the time Alice requests access to a resource on which a group appears. This could also be a performance nightmare with many queries, especially in the case of unauthorized users. At the least, once Alice is discovered to either belong or not belong, the server should cache this information. But again, if the cache is held for a long time it means that membership can take a long time to take effect, and revocation can also takes a long time to take effect.</p></li><li><p class="docList">All groups to which Alice belongs could be added into her Kerberos ticket. This implies that the KDC or some central authorization service knows all the groups she is in. This makes it difficult to support cross-organizational groups, where no one entity knows all the groups a user is in, and it can have scaling problems as well if a user is in many groups.</p></li><li><p class="docList">Groups to which Alice belongs could be listed in Alice's certificate. This also has scaling problems if she is in many groups. It also implies that the CA knows all the groups Alice belongs to, and requires reissuance of the certificate any time Alice joins or leaves a group.</p></li><li><p class="docList">Alice might be given a set of group membership certificates for each group to which she belongs. She could present them all whenever attempting to access a resource, or the server could request certificates for relevant groups.</p></li><li><p class="docList">The server could tell Alice in which groups she should prove membership to gain access to the resource. Then Alice, if she has membership certificates for those groups, could send the certificates to the server, or obtain group membership certificates as needed. This is an attractive solution for many reasons. In many situations it is better to have the clients do the work than the servers, because of denial-of-service attacks on the servers. Also, a single interaction with the group membership server would allow Alice to use that certificate on many servers. Further, Alice's workstation can keep track of which group memberships she has recently needed, and proactively refresh credentials. This frees servers from checking revocation status on certificates. Instead of checking for revocation, they can insist that the group membership certificate Alice presents is reasonably fresh (say less than three hours old). Each server can have its own policy for how fresh group membership certificates must be, and refuse group membership certificates staler than that.</p></li></ul>
<a name="ch15lev2sec24"></a>
<h4 id="title-IDAOKNHH" class="docSection2Title">15.8.4. Roles</h4>
<p class="docText">The term <span class="docEmphStrong">role</span> is used in many different ways. The most common concept is that Alice can be logged in as role <span class="docEmphasis">AliceÂordinary user</span> or <span class="docEmphasis">AliceÂsystem administrator</span>, and she gets different privileges <a name="iddle1181"></a><a name="iddle1885"></a>depending on which role she's in. Authorization based on roles is referred to as RBAC (role based access control), and as with the term <span class="docEmphasis">role</span>, the term <span class="docEmphasis">RBAC</span> means different things to different people. Some advocates of the roles concept claim that the purpose of roles is to allow central administration of rights, instead of having an ACL for each resource. They claim such a system (which lists all the privileges that go along with a role) will scale better than an ACL model, but if centralized administration really were easier, then wouldn't the same argument apply to individuals and groups?</p>
<p class="docText">Usually people think of a role as something that needs to be consciously invoked by a user, often requiring additional authentication such as typing a different password. In contrast, with groups it is assumed that all members are automatically given all rights of the group as long as they are members. Users may or may not be allowed to simultaneously act in multiple roles, and perhaps multiple users may or may not be allowed to simultaneously act in a particular role (like <span class="docEmphasis">President of the United States</span>).</p>
<p class="docText">Some things people would like to see roles solve:</p>
<ul><li><p class="docList">When a user is acting in a particular role, the application presents a different user interface. For instance, when a user is acting as <span class="docEmphasis">manager</span>, the expense reporting utility might present commands for approving expense reports, whereas when the user is acting as <span class="docEmphasis">employee</span>, the application might present commands for reporting expenses.</p></li><li><p class="docList">Having roles enables a user to be granted a subset of all the permissions they might have. This makes it less likely that a typo will cause a user to inadvertently do an undesirable privileged operation, because they'd only invoke the privileged role briefly, and only when necessary to do a specific action.</p></li><li><p class="docList">Allowing a user to be able to run with a subset of her rights (not invoking her most privileged role except when necessary) gives some protection from malicious code. While running untrusted code, the user would be careful to run in an unprivileged role.</p></li><li><p class="docList">Sometimes there are complex policies, such as that you are allowed to read either file A or file B but not both. Somehow, proponents of roles claim roles will solve this problem. This sort of policy is called a <b><a class="docLink" href="app02.html#gloss01_041">Chinese wall</a></b>.</p></li></ul>
<p class="docText">On a single machine, some of these concepts of roles can be implemented straightforwardly. But what about in a distributed environment?</p>
<p class="docText">Most of the functionality that people envision for roles can be done with groups. But there are three concepts: individuals, groups, and roles. What might be the difference between a role and a group? A role has to be explicitly invoked, and perhaps with additional authentication. So in that case, what is the difference between a role and an individual? Why not just consider <span class="docEmphasis">administrator</span> and <span class="docEmphasis">user</span> as different entities? The reason is that for auditing purposes it is useful to know which user was acting in the <span class="docEmphasis">administrator</span> role when a particular action was taken.</p>
<p class="docText"><a name="iddle1124"></a>Making fancy policies work in a distributed fashion is at best a subject of research today. If you want to ensure that only one user is acting in a particular role at any time, or that a user must not be allowed to see both files A and B, a conceivable method for implementing this is to have a central service (which might for robustness or performance be implemented on multiple machines, coordinating amongst themselves) which keeps track of who has done what and grants permissions for actions. This wouldn't be a central service for the entire inter-organizational internet, but rather a service for a suite of applications. The user logs into the central server, so it can keep track of what role(s) the user has at the moment and what actions the user has taken.</p>
<a name="ch15lev2sec25"></a>
<h4 id="title-IDAQNNHH" class="docSection2Title">15.8.5. Anonymous Groups</h4>
<p class="docText">If a user can prove she is a member of a group which is authorized access to the resource, it is not necessarily the case that she needs to divulge and prove her identity. In many cases it <span class="docEmphasis">will</span> be necessary, for auditing purposes. But in some cases, it might be desirable to anonymously prove group membership.</p>
<p class="docText">This can be accomplished by having Alice authenticate herself to the group membership server, provide it with a public key <span class="docEmphasis">P</span> (different from Alice's long-term key), and have the group membership server issue a certificate stating that the holder of the private key associated with <span class="docEmphasis">P</span> is a member of the group. In order to not allow someone to correlate uses of the public key to know that the same user did both actions, a user might want to have a lot of group membership certificates for the anonymous group, each with a different key.</p>
<p class="docText">If it is desired that even the group membership server should not know which key is associated with which member, then the group membership server could do a <span class="docEmphStrong">blind signature</span>, a concept invented by David Chaum in which Bob signs something without knowing what he's signing!</p>
<p class="docText">It is rather surprising that such a protocol exists, that it would be useful for anything, and that anyone would have thought of it! But assuming you'd want to be able to use your privileges as a member of the group without anyone being able to know which individual you were, this feature would be useful. With blind signatures, Bob does not know which keys belong to which members, and so cannot divulge this information.</p>
<p class="docText">A blind signature is easy to understand. Assume the signature algorithm is RSA, and that Bob's public key is &lt;<span class="docEmphasis">e</span>,<span class="docEmphasis">n</span>&gt;. If Alice wants a particular certificate <span class="docEmphasis">c</span> signed by Bob, then she picks a random number <span class="docEmphasis">R</span>, and raises <span class="docEmphasis">R</span> to <span class="docEmphasis">e</span> mod <span class="docEmphasis">n</span>, and multiplies <span class="docEmphasis">c</span> by the result. So she gets <span class="docEmphasis">c</span>(<span class="docEmphasis">R<sup>e</sup></span> mod <span class="docEmphasis">n</span>). Bob can't distinguish this from a random number. He signs the result, meaning that he raises it to his private exponent <span class="docEmphasis">d</span>. So he computes <span class="docEmphasis">c<sup>d</sup></span>(<span class="docEmphasis">R<sup>ed</sup></span>) mod <span class="docEmphasis">n</span>. <span class="docEmphasis">R<sup>ed</sup></span> is just <span class="docEmphasis">R</span>. So Alice divides what she gets from Bob by <span class="docEmphasis">R</span> and her certificate is now validly signed by Bob. Note that this only obscures what Bob has signed if Bob signs lots of things with that key. And note that this is only secure if Bob has a different key for each kind of assertion he signs.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>