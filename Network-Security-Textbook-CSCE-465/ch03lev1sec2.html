<html><head><title>3.2. Generic Block Encryption</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="15051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch03lev1sec2"></a>
<h3 id="643999-864" class="docSection1Title">3.2. Generic Block Encryption</h3>
<p class="docText">A cryptographic algorithm converts a plaintext block into an encrypted block. It's fairly obvious that if the key length is too short (for instance, 4 bits), the cryptographic scheme would not be secure because it would be too easy to search through all possible keys. There's a similar issue with the length of the block of plaintext to be encrypted. If the block length is too short (say one octet, as in a monoalphabetic cipher), then if you ever had some paired &lt;plaintext, ciphertext&gt;, you could construct a table to be used for decryption. It might be possible to obtain such pairs because messages might only remain secret for a short time, perhaps because the message says where the army will attack the next day.</p>
<p class="docText">Having a block length too long is merely inconvenientÂunnecessarily complex and possibly having performance penalties. 64 bits is a reasonable length, in that you are unlikely to get that many blocks of &lt;plaintext,ciphertext&gt; pairs, and even if you did, it would take too much space to store the table (2<sup>64</sup> entries of 64 bits each) or too much time to sort it for efficient searching.</p>
<p class="docText">The most general way of encrypting a 64-bit block is to take each of the 2<sup>64</sup> input values and map it to a unique one of the 2<sup>64</sup> output values. (It is necessary that the mapping be <b><a class="docLink" href="app02.html#gloss01_149">one-to-one</a></b>, i.e. <a name="iddle1365"></a><a name="iddle1797"></a><a name="iddle2035"></a>only one input value maps to any given output value, since otherwise decryption would not be possible.)</p>
<p class="docText">Suppose Alice and Bob (who happen to speak a language in which all sentences are 64 bits long) want to decide upon a mapping that they can use for encrypting their conversations. How would they specify one? To specify a monoalphabetic cipher with English letters takes 26 specifications of 26 possible values, approximately. For instance,</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="9"><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">a</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">q</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">b</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">d</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">c</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">w</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">d</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">x</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">e</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">a</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">f</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">f</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">g</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">z</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">h</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">b</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">etc.</p></td></tr></table></p><br />
<p class="docText">How would you specify a mapping of all possible 64-bit input values? Well, let's start:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">0000000000000000</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">8ad1482703f217ce</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">0000000000000001</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">b33dc8710928d701</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphRomanAlt">0000000000000002</span><img src="U2192.GIF" border="0" /><span class="docEmphRomanAlt">29e856b28013fa4c</span></p></td></tr></table></p><br />
<p class="docText">Hmm, we probably don't want to write this all out. There are 2<sup>64</sup> possible input values and for each one we have to specify a 64-bit output value. This would take 2<sup>70</sup> bits. (Actually, nitpickers might note that there aren't quite 2<sup>70</sup> bits of information since the mapping has to be a <b><a class="docLink" href="app02.html#gloss01_160">permutation</a></b>, i.e., each output value is used exactly once, so for instance the final output value does not need to be explicitly specifiedÂit's the one that's left over. However, there are 2<sup>64</sup>! different possible permutations of 2<sup>64</sup> values, which would take more than 2<sup>69</sup> bits to represent.) [Remember <span class="docEmphasis">n</span>! (read &quot;<span class="docEmphasis">n</span> factorial&quot;) is <span class="docEmphasis">n</span>&#183;(<span class="docEmphasis">n</span>-1)&#183;(<span class="docEmphasis">n</span>-2)&#183;(<span class="docEmphasis">n</span>-3)&#183;&#183;&#183;3&#183;2&#183;1. It can be approximated by Stirling's formula: 

<img border="0" alt="" id="118095013052" width="150" height="26" src="060inline01.jpg" />
</p>
<p class="docText">So let's say it would take 2<sup>69</sup> bits to specify the mapping. That 2<sup>69</sup> bit number would act like a secret key that Alice and Bob would share. But it is doubtful that they could remember a key that large, or even be able to say it to each other within a lifetime, or store it on anything. So this is not particularly practical.</p>
<p class="docText">Secret key cryptographic systems are designed to take a reasonable-length key (i.e., more like 64 bits than 2<sup>64</sup> bits) and generate a one-to-one mapping that looks, to someone who does not know the key, completely random. <span class="docEmphStrong">Random</span> means that it should look, to someone who doesn't know the key, as if the mapping from an input value to an output value were generated by using a random number generator. (To get the mapping from input <span class="docEmphasis">i</span> to output <span class="docEmphasis">o</span>, flip a 2<sup>64</sup>-sided coin to choose the value of <span class="docEmphasis">o</span>Âor if such a coin is not readily available, a single coin could be flipped 64 times. Since the mapping must be one-to-one, you'll have to start over again choosing <span class="docEmphasis">o</span> if the value selected by the coin has been previously used.) If the mapping were truly random, any single bit change to the input will result in a totally independently chosen random number output. The two different output numbers should have no correlation, meaning that about half the bits should be the same and about half the bits should be different. For instance, it can't be the case that the 3<span class="docEmphasis"><sup>rd</sup></span> bit of output always changes if the 12<span class="docEmphasis"><sup>th</sup></span> bit of input changes. So the cryptographic algorithms are designed to <span class="docEmphasis">spread bits <a name="iddle1798"></a><a name="iddle1931"></a><a name="iddle2045"></a>around</span>, in the sense that a single input bit should have influence on all the bits of the output, and be able to change any one of them with a probability of about 50% (depending on the values of the other 63 bits of input).</p>
<p class="docText">There are two kinds of simple transformations one might imagine on a block of data, and they are named in the literature as <span class="docEmphasis">substitutions</span> and <span class="docEmphasis">permutations</span> (which is the only reason we are using those namesÂwe would have chosen different words, perhaps the term <span class="docEmphasis">bit shuffle</span> instead of <span class="docEmphasis">permutation</span>). Let's assume we are encrypting <span class="docEmphasis">k</span>-bit blocks:</p>
<p class="docText"><span class="docEmphStrong">A</span> <b><a class="docLink" href="app02.html#gloss01_217">substitution</a></b> specifies, for each of the 2<span class="docEmphasis"><sup>k</sup></span> possible values of the input, the <span class="docEmphasis">k</span>-bit output. As noted above, this would be impractical to build for 64-bit blocks, but would be possible with blocks of length, say, 8 bits. To specify a completely randomly chosen substitution for <span class="docEmphasis">k</span>-bit blocks would take about <span class="docEmphasis">k</span>&#183;2<span class="docEmphasis"><sup>k</sup></span> bits.</p>
<p class="docText">A <b><a class="docLink" href="app02.html#gloss01_160">permutation</a></b> specifies, for each of the <span class="docEmphasis">k</span> input bits, the output position to which it goes. For instance, the 1<span class="docEmphasis"><sup>st</sup></span> bit might become the 13<span class="docEmphasis"><sup>th</sup></span> bit of output, the 2<span class="docEmphasis"><sup>nd</sup></span> bit would become the 61<span class="docEmphasis"><sup>st</sup></span> bit of output, and so on. To specify a completely randomly chosen permutation of <span class="docEmphasis">k</span> bits would take about <span class="docEmphasis">k</span> log<sub>2</sub><span class="docEmphasis">k</span> bits (for each of the <span class="docEmphasis">k</span> bits, one has to specify which bit position it will be in the output, and it only takes log<sub>2</sub><span class="docEmphasis">k</span> bits to specify <span class="docEmphasis">k</span> values).</p>
<p class="docText">A permutation is a special case of a substitution in which each bit of the output gets its value from exactly one of the bits of the input. The number of permutations is sufficiently small that it is possible to specify and build an arbitrary 64-bit permuter.</p>
<p class="docText">One possible way to build a secret key algorithm is to break the input into manageable-sized chunks (say 8 bits), do a substitution on each small chunk, and then take the outputs of all the substitutions and run them through a permuter that is as big as the input, which shuffles the bits around. Then the process is repeated, so that each bit winds up as input to each of the substitutions. (See <a class="docLink" href="#ch03fig01">Figure 3-1</a>.)</p>
<a name="ch03fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 3-1. Example of Block Encryption</h5>
</center></p><p class="docText">
<img border="0" alt="" id="118095013052" width="500" height="342" src="03fig01.jpg" /></p>
<br />
<p class="docText">Each time through is known as a <span class="docEmphStrong">round</span>. If we do only a single round, then a bit of input can only affect 8 bits of output, since each input bit goes into only one of the substitutions. On the second round, the 8 bits affected by a particular input bit get spread around due to the permutation, and assuming each of those 8 bits goes into a different substitution, then the single input bit will affect all the output bits. Just as when shuffling a deck of cards, there is an optimal number of rounds (shuffles). Once the cards are sufficiently randomized, extra shuffles just waste time. Part of the design of an algorithm is determining the best number of rounds (for optimal security, at least enough rounds to randomize as much as possible; for efficiency reasons no more rounds than necessary).</p>
<p class="docText">Another important feature of an encryption mechanism is it must be efficient to reverse, given the key. An algorithm like the one above would take the same effort to decrypt as to encrypt, since each of the steps can be run as efficiently backwards as forwards.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="15051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>