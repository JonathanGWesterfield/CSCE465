<html><head><title>1.5. Primer on Networking</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch01lev1sec5"></a>
<h3 id="title-IDANFW3L" class="docSection1Title">1.5. Primer on Networking</h3>
<p class="docText"><a name="iddle1240"></a><a name="iddle1465"></a><a name="iddle1497"></a><a name="iddle1748"></a><a name="iddle1753"></a><a name="iddle1809"></a>You have to know something about computer networks to understand computer network security, so we're including this primer. For a more detailed understanding, we recommend <a class="docLink" href="biblio01.html#biblio01_126">PERL99</a>, <a class="docLink" href="biblio01.html#biblio01_167">TANE96</a>, <a class="docLink" href="biblio01.html#biblio01_028">COME00</a>, <a class="docLink" href="biblio01.html#biblio01_162">STEV94</a>, <a class="docLink" href="biblio01.html#biblio01_098">KURO00</a>.</p>
<p class="docText">Networks today need to be very easy to use and configure. Networks are no longer an expensive educational toy for researchers, but instead are being used by real people. Most sites with networks will not be able to hire a full-time person with networking expertise to start and keep the network running.</p>
<a name="ch01lev2sec1"></a>
<h4 id="title-IDATIW3L" class="docSection2Title">1.5.1. OSI Reference Model</h4>
<p class="docText">Somehow, a book about computer networks would seem incomplete without a picture of the <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_152">OSI (Open Systems Interconnection)</a></span> Reference Model, so here it is.</p>
<a name="ch01tab01"></a><p><table cellspacing="0" class="allBorders" border="1" rules="rows" cellpadding="4"><caption><h5 class="docTableTitle">Figure 1-1. OSI Reference Model</h5></caption><colgroup align="center" span="1"><col width="300"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">application layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">presentation layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">session layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">transport layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">network layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">data link layer</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">physical layer</span></p></td></tr></table></p><br />
<p class="docText">The OSI Reference Model is useful because it gives some commonly used terminology, though it might mislead you into thinking that there is only one way to construct a network. The reference model was designed by an organization known as the International Standards Organization (<span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_110">ISO</a></span>). The ISO decided it would be a good idea to standardize computer networking. Since that was too big a task for a single committee, they decided to subdivide the problem among several committees. They somewhat arbitrarily chose seven, each responsible for one layer. The basic idea is that each layer uses the services of the layer below, adds functionality, and provides a service to the layer above. When you start looking at real networks, they seldom neatly fit into the seven-layer model, but for basic understanding of networking, the OSI Reference Model is a good place to start.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">physical layer.</span> This layer delivers an unstructured stream of bits across a link of some sort.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">data link layer.</span> This layer delivers a piece of information across a single link. It organizes the physical layer's bits into packets and controls who on a shared link gets each packet.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">network layer.</span> <a name="iddle1028"></a><a name="iddle1453"></a><a name="iddle1690"></a><a name="iddle1838"></a><a name="iddle1987"></a><a name="iddle2050"></a><a name="iddle2090"></a>This layer computes paths across an interconnected mesh of links and packet switches, and forwards packets over multiple links from source to destination.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">transport layer.</span> This layer establishes a reliable communication stream between a pair of systems across a network by putting sequence numbers in packets, holding packets at the destination until they can be delivered in order, and retransmitting lost packets.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">session layer.</span> The OSI session layer adds extra functions to the reliable pair-wise communication provided by the transport layer. Most network architectures do not have or need the functionality in this layer, and it is not of concern to security, so for the purposes of this book we can ignore it.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">presentation layer.</span> This layer encodes application data into a canonical (system-independent) format and decodes it into a system-dependent format at the receiving end.</p></div></li><li><div style="font-weight:normal"><p class="docText"><span class="docEmphStrong">application layer.</span> This is where the applications that use the network, such as web surfing, file transfer, and electronic mail, reside.</p></div></li></ol></div>
<p class="docText">A layer communicates with the equivalent layer in a different node. In order to get data to a peer layer, though, the layer at the transmitting node gives the data to the layer below it (on the same node), which adds a header containing additional information if necessary, and that layer in turn gives it to the layer below. As the packet is received by the destination node, each layer reads and strips off its own header, so that the packet received by layer <span class="docEmphasis">n</span> looks to that layer just like it did when it was sent down to layer <span class="docEmphasis">n</span>-1 for transmission.</p>
<p class="docText">This seven-layer model is the basis for a lot of the terminology in networking, and a good first step towards understanding networks, but today's network protocols do not neatly fit this model. Throughout the book we sometimes use the OSI terminology by discussing things such as encryption at layer 2 vs. layer 3 vs. layer 4, or use the terms <span class="docEmphasis">data link layer</span>, or <span class="docEmphasis">transport layer</span>.</p>
<a name="ch01lev2sec2"></a>
<h4 id="title-IDA0QW3L" class="docSection2Title">1.5.2. IP, UDP, and TCP</h4>
<p class="docText">Today the most common protocols are the ones standardized by the <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_105">IETF</a></span> (Internet Engineering Task Force). All the IETF documents are on-line and freely available from the web site <a class="docLink" target="_blank" href="http://www.ietf.org">www.ietf.org</a>. The protocols are specified in documents known as RFCs. (<span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_187">RFC</a></span> is an abbreviation for &quot;Request for Comments&quot;, but the time to comment is when the documents are in the more preliminary &quot;internet draft&quot; stage. Nobody wants to hear your comments on RFCs.)</p>
<p class="docText">The IETF's protocol suite is usually referred to as the &quot;TCP/IP suite&quot;, after the most common layer 3 (IP) and layer 4 (TCP) protocols at the time the suite was being nicknamed. IP (Internet Protocol), the layer 3 protocol, is defined in RFC 791. Its job is to deliver data across a network. To get a letter mailed with the postal service, you put it in an envelope that specifies the source and destination <a name="iddle1275"></a><a name="iddle2103"></a>address. Similarly, the IP layer adds an envelope (a header) to the data that specifies the source and destination addresses.</p>
<p class="docText">But the IP address only specifies the destination machine. There might be multiple processes at the destination machine all communicating across the network, so it's necessary to also specify which process should receive the data. This is similar to putting an apartment number on the envelope in addition to the street address. IP doesn't identify the processes, but instead has a 1-<span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_143">octet</a></span> field that specifies which protocol should receive the packet, and the rest of the information necessary to identify the destination process is contained in the layer 4 header, in the PORT fields.</p>
<p class="docText">The two most important layer 4 protocols in the IETF suite are <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_220">TCP</a></span> (Transmission Control Protocol, defined in RFC 793) and <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_236">UDP</a></span> (User Datagram Protocol, defined in RFC 768). TCP sends an unlimited size stream of data, reliably (either all data is delivered to the other end without loss, duplication, or misordering, or the connection is terminated). UDP sends limited-sized individual chunks, with best-effort service. Both TCP and UDP have fields for <span class="docEmphSmaller">SOURCE PORT</span> and <span class="docEmphSmaller">DESTINATION PORT</span>, which specify the process to whom the data belongs. TCP additionally has sequence numbers and acknowledgments to ensure the data arrives reliably.</p>
<p class="docText">Some port numbers are &quot;well-known&quot;, i.e., permanently assigned to a particular service, whereas others are dynamically assigned. Being able to contact someone at a well-known port makes it easy to establish communication. In contrast, if Alice and Bob were going to attempt to communicate by going to public telephones wherever they happened to be, they'd never be able to communicate, since neither one would know what number to call. But if one of them were listening at a well-known telephone number, then the other could call from anywhere. This is very similar to the use of well-known ports.</p>
<p class="docText">To communicate with a particular service, say the <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_221">telnet</a></span> service, at some machine at IP address x, you'd know that telnet uses TCP, and is always assigned to port 23. So in the IP header, you'd specify x as the destination address, and 6 (which means TCP) as the protocol type. In the TCP header, you'd specify port 23 as the destination port. Your process would be at a dynamically assigned port, but the recipient process at node x would know which port to reply to by copying the port from the source port in the received TCP header.</p>
<p class="docText">This will all become much more relevant when we discuss firewalls in <a class="docLink" href="ch23.html#ch23">Chapter 23</a> <span class="docEmphasis">Firewalls</span>, and how they can distinguish telnet packets (which firewall administrators would usually like to block) from, say, email packets (which firewall administrators would usually like to allow).</p>
<a name="ch01lev2sec3"></a>
<h4 id="title-IDALUW3L" class="docSection2Title">1.5.3. Directory Service</h4>
<p class="docText">Having a telephone line into your house means you can access any phone in the world, if you know the telephone number. The same thing is true, more or less, in computer networks. If you know the network layer address of a node on the network, you should be able to communicate with that node. (This isn't always true because of security gateways, which we'll discuss in <a class="docLink" href="ch23.html#ch23">Chapter 23</a> <span class="docEmphasis">Firewalls</span>.) <a name="iddle1691"></a>But how do you find out another node's network layer address? Network layer addresses are not the kind of things that people will be able to remember, or type. People instead will want to access something using a name such as <span class="docEmphRomanAlt">File-Server-3</span>.</p>
<p class="docText">This is a similar problem to finding someone's telephone number. Typically you start out by knowing the name of the person or service you want to talk to, and then look the name up in a telephone book. In a computer network there is a service which stores information about a name, including its network layer address. Anything that needs to be found is listed in the service. Anything that needs to find something searches the service.</p>
<p class="docText">We call such a service a <b><a class="docLink" href="app02.html#gloss01_072">directory</a></b>, though some people like to reserve the term &quot;directory&quot; for something in which you search based on an attribute (e.g., &quot;find all the people who live on Main Street&quot;) rather than look up something based on knowing its name. Those people would call a simple service in which you look up information (rather than do complex searches) a <b><a class="docLink" href="app02.html#gloss01_134">naming</a></b> service. We see no reason to make that distinction. It might be nice to search for all items that match a certain attribute, but usually the name will be known, and the attributes of that name will be fetched.</p>
<p class="docText">Rather than keeping all names in one directory, the directory service is typically structured as a tree of directories. Usually a name is hierarchical, so that the directory in which the name can be found is obvious from the name. For example, an Internet name looks like <span class="docEmphRomanAlt">radia@east.sun.com</span>. The top level consists of pointers to the directories <span class="docEmphRomanAlt">com</span> for commercial enterprises, <span class="docEmphRomanAlt">edu</span> for educational institutions, <span class="docEmphRomanAlt">gov</span> for U.S. government, and various country names. Under <span class="docEmphRomanAlt">com</span>, there are various company names.</p>
<p class="docText">Having multiple directories rather than keeping all names in one directory serves two purposes. One is to prevent the directory from getting unreasonably large. The other reason is to reduce name collisions (more than one object with the same name). For instance, when you're looking up a telephone number for your friend John Smith, it's bad enough trying to figure out which John Smith is the one you want if you know which town he lives in and the telephone company has separate directories for each town, but imagine if the telephone company didn't have separate books for each town and simply had a list of names and telephone numbers!</p>
<p class="docText">Ideally, with a hierarchy of directories, name collisions could be prevented. Once a company hired one Radia Perlman, they just wouldn't hire another. I<sub>2</sub> think that's reasonable, but someone with a name like <span class="docEmphRomanAlt">John Smith</span> might start having problems finding a company that could hire him.</p>
<blockquote>
<p class="docText"><span class="docEmphasis">Now why did you name your baby</span> John<span class="docEmphasis">? Every Tom, Dick, and Harry is named</span> John.</p>
<p class="docText">ÂSam Goldwyn</p></blockquote>
<p class="docText">For electronic mail addresses, conflicts must be prevented. Typically, companies let the first John Smith use the name <span class="docEmphRomanAlt">John@companyname</span> for his email address, and then perhaps the next one will be <span class="docEmphRomanAlt">Smith@companyname</span>, and the next one <span class="docEmphRomanAlt">JSmith@companyname</span>, and the next one has to start using middle initials. But for directories of names, there is usually no way to avoid name <a name="iddle1758"></a><a name="iddle1908"></a>collisions within a directory. In other words, both John Smiths will use the same name within the company. Then, just like with a telephone book and multiple John Smiths, you have to do the best you can to figure out which one you want based on various attributes (such as in the telephone directory, using the street address). And just like in &quot;real life,&quot; there will be lots of confusion where one John Smith gets messages intended for a different John Smith.</p>
<p class="docText">The directory service is very important to security. It is assumed to be widely available and convenient to accessÂotherwise large-scale networking really is too inconvenient to be practical. The directory service is a convenient place to put information, such as a user's public cryptographic key. But the directory service, although convenient, is not likely to be very secure. An intruder might tamper with the information. The magic of cryptography will help us detect such tampering so that it will not be necessary to physically secure all locations that store directory service information. If the information is tampered with, <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_096">good guys</a></span> will detect this. It might prevent good guys from accessing the network, since they won't be able to find information they can trust, but it will not allow bad guys unauthorized access.</p>
<a name="ch01lev2sec4"></a>
<h4 id="title-IDA0YW3L" class="docSection2Title">1.5.4. Replicated Services</h4>
<p class="docText">Sometimes it is convenient to have two or more computers performing the same function. One reason is performance. A single server might become overloaded, or might not be sufficiently close to all users on a large network. Another reason is availability. If the service is replicated, it does not matter if some of the replicas are down or unavailable. When someone wants to access the service provided, it doesn't matter which of the computers they reach. Often the user can't even tell whether there's a single copy of the service or there are replicas.</p>
<p class="docText">What are the security issues with a replicated service? You'd want the user to have the same authentication information regardless of which replica was authenticating the user. If authentication information is stored at each replica, then coordinating the databases, for example after a <span class="docEmphRomanAlt">change password</span> command, can be tricky. And if the identical exchange will work with any of the replicas, then having an eavesdropper repeat the authentication handshake with a different replica might be a security problem.</p>
<a name="ch01lev2sec5"></a>
<h4 id="title-IDANZW3L" class="docSection2Title">1.5.5. Packet Switching</h4>
<p class="docText">A really naive assumption would be that if people wanted computer A to talk to computer B, they'd string a wire between A and B. This doesn't work if networks get large, either in number of nodes (<span class="docEmphasis">n</span><sup>2</sup> wires) or physical distance (it takes a lot of wire to connect each of 10000 nodes in North America with each of 10000 nodes in Asia). So in a network, messages do not go directly from sender to recipient, but rather have to be forwarded by various computers along the way. These <a name="iddle1558"></a><a name="iddle1566"></a><a name="iddle1934"></a>message forwarders are referred to as packet switches, routers, gateways, bridges, and probably lots of other names as well.</p>
<p class="docText">A message is generally broken into smaller chunks as it is sent through the network. There are various reasons for this.</p>
<ul><li><p class="docList">Messages from various sources can be interleaved on the same link. You wouldn't want your message to have to wait until someone else finished sending a huge message, so messages are sent a small chunk at a time. If the link is in the process of sending the huge message when your little single-chunk message arrives, your message only has to wait until the link finishes sending a chunk of the large message.</p></li><li><p class="docList">Error recovery is done on the chunk. If you find out that one little chunk got mangled in transmission, only that chunk needs to be retransmitted.</p></li><li><p class="docList">Buffer management in the routers is simpler if the size of packets has a reasonable upper limit.</p></li></ul>
<a name="ch01lev2sec6"></a>
<h4 id="title-IDAI1W3L" class="docSection2Title">1.5.6. Network Components</h4>
<p class="docText">The network is a collection of packet switches (usually called routers) and links. A link can either be a wire between two computers or a multi-access link such as a <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_119">LAN (local area network)</a></span>. A multi-access link has interesting security implications. Whatever is transmitted on the link can be seen by all the other nodes on that link. Multi-access links with this property include Ethernet (also known as <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_062">CSMA/CD</a></span>), token rings, and packet radio networks.</p>
<p class="docText">Connected to the backbone of the network are various types of nodes. A common categorization of the nodes is into <i><a class="docLink" href="app02.html#gloss01_045">clients</a></i>, which are workstations that allow humans to access the resources on the network, and <i><a class="docLink" href="app02.html#gloss01_202">servers</a></i>, which are typically dedicated machines that provide services such as file storage and printing. It should be possible to deploy a new service and have users be able to conveniently find the service. Users should be able to access the network from various locations, such as a public workstation a company makes available for visitors. If a person has a dedicated workstation located in one location, such as an office, it should be possible with a minimum of configuration for the user to plug the workstation into the network.</p>
<p class="docText">Historically, another method for users to access a network is through a <span class="docEmphasis">dumb terminal</span>. A dumb terminal is not a general-purpose computer and does not have the compute power to do cryptographic operations. Usually a dumb terminal hooks directly into a host machine, or into a <span class="docEmphasis">terminal server</span> which relays the terminal's keystrokes via a network protocol across the network to the host machine (the machine the user logs into). Very few dumb terminals remain today, but their legacy lives on in the form of software-based terminal emulators implemented in most PCs and workstations. Even though these devices are capable of complex calculations, for backward compatibility, they don't do them.</p>
<a name="ch01lev2sec7"></a>
<h4 id="title-IDAC3W3L" class="docSection2Title">1.5.7. Destinations: Ultimate and Next-Hop</h4>
<p class="docText">A network is something to which multiple systems can attach. We draw it as a cloud since, from the point of view of the systems connected to it, exactly what goes on inside is not relevant. If two systems are on the same cloud, one can send a message to the other by attaching a header that contains a source address and a destination address, much like putting a letter into an envelope for delivery by the postal service.</p>
<a name="ch01fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 1-2. A Network</h5>
</center></p><p class="docText">
<img border="0" alt="" width="200" height="115" src="01fig02.jpg" /></p>
<br />
<p class="docText">But how do you connect to the network? With a point-to-point link to a packet switch inside the network, things are reasonably simple. If A wants to send a message to B, A will put <span class="docEmphRomanAlt">A</span> as source address and <span class="docEmphRomanAlt">B</span> as destination address and send the message on the point-to-point link. But what if A is connected on a LAN? In that case, in order to transmit the packet through the network, A has to specify which of its neighbors should receive the message. For example:</p>
<a name="ch01fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 1-3. Network Connections</h5>
</center></p><p class="docText">
<img border="0" alt="" width="350" height="105" src="01fig03.jpg" /></p>
<br />
<p class="docText">If A wants to send a message to D it has to know (somehowÂif you care how, you can read my<sub>2</sub> book [<a class="docLink" href="biblio01.html#biblio01_126">PERL99</a>]) that the appropriate neighbor for forwarding the packet is R<sub>2</sub>. So when A transmits the message there are two destinations: R<sub>2</sub> as the next recipient and D as the ultimate recipient. A reasonably simple way of thinking about this is that the data link layer worries about transmission across a single link. The data link header has a source address and a destination address which indicate the transmitter on that link and the receiver on that link. The network layer worries about transmission across a multi-hop network. It has a header that carries the original source and ultimate destination. The data link header is removed each time a message is received, and a new data link header is tacked onto the message when it is forwarded to the next hop.</p>
<p class="docText">When A transmits the packet, the network header has source <span class="docEmphRomanAlt">A</span>, destination <span class="docEmphRomanAlt">D</span>. The data link header has source <span class="docEmphRomanAlt">A</span>, destination <span class="docEmphRomanAlt">R<sub>2</sub></span>. R<sub>2</sub> forwards the packet to R<sub>5</sub>. Since R<sub>2</sub> is connected to R<sub>5</sub> with a point-to-point link, the data link header will not have addresses. But when R<sub>5</sub> forwards the packet to R<sub>6</sub> across the LAN, the network layer header will (still) be source <span class="docEmphRomanAlt">A</span>, destination <span class="docEmphRomanAlt">D</span>. The data link header will be source <span class="docEmphRomanAlt">R<sub>5</sub></span>, destination <span class="docEmphRomanAlt">R<sub>6</sub></span>. When R<sub>6</sub> forwards it (across the token ring LAN) the network header is still the same, and the data link header has source <span class="docEmphRomanAlt">R<sub>6</sub></span>, destination <span class="docEmphRomanAlt">D</span>.</p>
<p class="docText">Most likely A's data link address will look different from its network layer address, so it's a bit sloppy to say source <span class="docEmphRomanAlt">A</span> in both the data link header and network header. But this is all irrelevant to security. Fascinating in its own right, but irrelevant to this book.</p>
<p class="docText">The network layer header can be thought of as an envelope for the message. The data link header is an outer envelope. We've described the case of two envelopesÂa network header inside a data link header. The world can be even more complicated than this. In fact, the &quot;data link layer&quot; might be a multi-hop network with multi-hop networks inside it as well. So a message might wind up with several envelopes. Again this is fascinating stuff but irrelevant to this book.</p>
<a name="ch01lev2sec8"></a>
<h4 id="title-IDADCX3L" class="docSection2Title">1.5.8. Address Structure</h4>
<p class="docText">What do addresses look like? In terms of security, the main issue is how difficult it is to forge a source address, and how easy it is to arrange for the network to deliver packets to you when they are addressed to someone other than you. For instance, think of a letter as having a source address (the return address, it's called in paper mail) and a destination address. It's easy to send a letter to anyone and put <span class="docEmphRomanAlt">President, White House, USA</span> as the source address. It's harder to arrange to receive mail sent to <span class="docEmphRomanAlt">President, White House, USA</span> if you are not the U.S. President, especially if you don't live in the White House, and most likely more difficult the further you live from the address you'd like to impersonate. Network addresses are usually hierarchical, just like a postal address. If we think of the address as specifying country/state/city/person, then in general it will be easier to arrange to receive someone else's messages if you reside in the same city (for instance by bribing a postal employee), and most difficult if they're in a different country.</p>
<p class="docText">Forging source addresses is easy in most network layers today. Routers can be built more defensively and do a sanity check on the source address, based on where they receive the packet from. After some highly publicized denial of service attacks, where vandals overwhelmed victim sites with nuisance traffic, many routers are now deployed with this feature of checking source addresses and discarding traffic received from an unexpected direction. It's not a perfect solution, though. As typically implemented, it requires extra configuration (so the routers will know what source addresses to expect from which directions), somewhat violates my<sub>2</sub> philosophy (as a layer 3 specialist) that routers should be self-configuring and adapt to topological changes, and slows down the router because it has to make an extra check when forwarding a packet.</p>
<a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>