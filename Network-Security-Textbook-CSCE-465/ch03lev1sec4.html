<html><head><title>3.4. International Data Encryption Algorithm (IDEA)</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch03lev1sec4"></a>
<h3 id="title-IDAFKILI" class="docSection1Title">3.4. International Data Encryption Algorithm (IDEA)</h3>
<p class="docText">IDEA (International Data Encryption Algorithm) was originally called IPES (Improved Proposed Encryption Standard). It was developed by Xuejia Lai and James L. Massey of ETH Zuria.</p>
<p class="docText">IDEA was designed to be efficient to compute in software. It encrypts a 64-bit block of plaintext into a 64-bit block of ciphertext using a 128-bit key. It was published in 1991, so cryptanalysts have had time to find weaknesses. So far none has been found, at least by the good guys (the ones who would publish their results).</p>
<p class="docText">IDEA is similar to DES in some ways. Both of them operate in rounds, and both have a complicated mangler function that does not have to be reversible in order for decryption to work. Instead, the mangler function is run in the same direction for encryption as decryption, in both IDEA and DES. In fact, both DES and IDEA have the property that encryption and decryption are identical except for key expansion. With DES, the same keys are used in the reverse order (see <a class="docLink" href="ch03lev1sec7.html#ch03qa1q11">Homework Problem 11</a>); with IDEA, the encryption and decryption keys are related in a more complex manner.</p>
<a name="ch03lev2sec8"></a>
<h4 id="title-IDA2KILI" class="docSection2Title">3.4.1. Primitive Operations</h4>
<p class="docText">Each primitive operation in IDEA maps two 16-bit quantities into a 16-bit quantity. (In contrast, each DES S-box maps a 6-bit quantity into a 4-bit quantity.) IDEA uses three operations, all easy to compute in software, to create a mapping. Furthermore, the operations are all reversible, which is important in order to run IDEA backwards (i.e., to decrypt).</p>
<a name="ch03fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 3-18. Basic Structure of IDEA</h5>
</center></p><p class="docText"><div class="v1"><a target="_blank" href="03fig18_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="343" src="03fig18.jpg" /></p>
<br />
<p class="docText">The operations are bitwise exclusive or (<img src="U2295.GIF" border="0" />), a slightly modified add (+), and a slightly modified multiply (<img src="U2297.GIF" border="0" />). The reason add and multiply can't be used in the ordinary way is that the result has to be 16 bits, which won't always be the case when adding or multiplying two 16-bit quantities. Addition in IDEA is done by throwing away carries, which is equivalent to saying addition is mod 2<sup>16</sup>. Multiplication in IDEA is done by first calculating the 32-bit result, and then taking the remainder when divided by 2<sup>16</sup>+1 (which can be done in a clever efficient manner). Multiplication mod 2<sup>16</sup>+1 is reversible, in the sense that every number <span class="docEmphasis">x</span> between 1 and 2<sup>16</sup> has an inverse <span class="docEmphasis">y</span> (i.e., a number in the range 1 to 2<sup>16</sup> such that multiplication by <span class="docEmphasis">y</span> will &quot;undo&quot; multiplication by <span class="docEmphasis">x</span>), because 2<sup>16</sup>+1 happens to be prime. There is one subtlety, though. The number 0, which can be expressed in 16 bits, would not have an inverse. And the number 2<sup>16</sup>, which is in the proper range for mod 2<sup>16</sup>+1 arithmetic, cannot be expressed in 16 bits. So both problems are solved by treating 0 as an encoding for 2<sup>16</sup>.</p>
<p class="docText">How are these operations reversible? Of course the operations are not reversible if all that is known is the 16-bit output. For instance, if we have inputs <span class="docEmphasis">A</span> and <span class="docEmphasis">B</span>, and perform <img src="U2295.GIF" border="0" /> to obtain <span class="docEmphasis">C</span>, we can't find <span class="docEmphasis">A</span> and <span class="docEmphasis">B</span> from <span class="docEmphasis">C</span> alone. However, when running IDEA backwards we will have <span class="docEmphasis">C</span> and <span class="docEmphasis">B</span>, and will use that to obtain <span class="docEmphasis">A</span>. <img src="U2295.GIF" border="0" /> is easy. If you know <span class="docEmphasis">B</span> and <span class="docEmphasis">C</span>, then you can simply do <span class="docEmphasis">B</span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">C</span> to get <a name="iddle1448"></a><a name="iddle1528"></a><span class="docEmphasis">A</span>. <span class="docEmphasis">B</span> is its own inverse with <img src="U2295.GIF" border="0" />. + is easy, too. You compute -<span class="docEmphasis">B</span> (mod 2<sup>16</sup>). If you know <span class="docEmphasis">C</span> and -<span class="docEmphasis">B</span>, then you can find <span class="docEmphasis">A</span> by doing <span class="docEmphasis">C</span> + -<span class="docEmphasis">B</span>. With <img src="U2297.GIF" border="0" /> you find <span class="docEmphasis">B</span><sup>-1</sup> (mod 2<sup>16</sup>+1) using Euclid's algorithmÂ see &sect;<a class="docLink" href="ch07lev1sec4.html#ch07lev1sec4">7.4</a> <span class="docEmphasis">Euclid's Algorithm</span>, and you perform <span class="docEmphasis">C</span> <img src="U2297.GIF" border="0" /> <span class="docEmphasis">B</span><sup>-1</sup> to get <span class="docEmphasis">A</span>.</p>
<p class="docText">The only part of IDEA that isn't necessarily reversible is the mangler function, and it is truly marvelous to note how IDEA's design manages not to require a reversible mangler function (see &sect;<a class="docLink" href="#ch03lev3sec2">3.4.3.2</a> <span class="docEmphasis">Even Round</span>).</p>
<a name="ch03lev2sec9"></a>
<h4 id="title-IDACQILI" class="docSection2Title">3.4.2. Key Expansion</h4>
<p class="docText">The 128-bit key is expanded into 52 16-bit keys, <span class="docEmphasis">K</span><sub>1</sub>, <span class="docEmphasis">K</span><sub>2</sub>,...<span class="docEmphasis">K</span><sub>52</sub>. The key expansion is done differently for encryption than for decryption. Once the 52 keys are generated, the encryption and decryption operations are the same.</p>
<p class="docText">The 52 encryption keys are generated by writing out the 128-bit key and, starting from the left, chopping off 16 bits at a time. This generates eight 16-bit keys (see <a class="docLink" href="#ch03fig19">Figure 3-19</a>).</p>
<a name="ch03fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 3-19. Generation of keys 1 through 8</h5>
</center></p><p class="docText">
<img border="0" alt="" width="200" height="72" src="03fig19.jpg" /></p>
<br />
<p class="docText">The next eight keys are generated by starting at bit 25, and wrapping around to the beginning when the end is reached (see <a class="docLink" href="#ch03fig20">Figure 3-20</a>).</p>
<a name="ch03fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 3-20. Generation of keys 9 through 16</h5>
</center></p><p class="docText">
<img border="0" alt="" width="400" height="73" src="03fig20.jpg" /></p>
<br />
<p class="docText">The next eight keys are generated by offsetting 25 more bits, and so forth, until 52 keys are generated. The last offset starts at bit 23 and only needs 4 keys, so bits 1 thru 22 and bits 87 thru 128 get used in keys once less than bits 23 thru 86.</p>
<p class="docText">We'll discuss how to generate the 52 decryption keys after we finish describing IDEA.</p>
<a name="ch03note01"></a><div class="docNote"><p class="docNoteTitle">Warning!</p>
<p class="docText"><a name="iddle1449"></a><a name="iddle1933"></a>If you're actually going to implement this, we lied a bit above because there's a strange quirk in IDEA. Possibly due to someone mixing up the labels on a diagram of IDEA, the keys <span class="docEmphasis">K</span><sub>50</sub> and <span class="docEmphasis">K</span><sub>51</sub> are swapped. That means that an implementation has to swap encryption keys <span class="docEmphasis">K</span><sub>50</sub> and <span class="docEmphasis">K</span><sub>51</sub> after generating them as described above.</p>
</div><br />
<a name="ch03lev2sec10"></a>
<h4 id="title-IDAFUILI" class="docSection2Title">3.4.3. One Round</h4>
<p class="docText">Like DES, IDEA is performed in rounds. It has 17 rounds, where the odd-numbered rounds are different from the even-numbered rounds. (Note that in other descriptions of IDEA, it is described as having 8 rounds, where those rounds do the work of two of our rounds. Our explanation is functionally equivalent. It's just that we think it's clearer to explain it as having 17 rounds.)</p>
<p class="docText">Each round takes the input, a 64-bit quantity, and treats it as four 16-bit quantities, which we'll call <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>. Mathematical functions are performed on <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, <span class="docEmphasis">X<sub>d</sub></span> to yield new versions of <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, <span class="docEmphasis">X<sub>d</sub></span>.</p>
<p class="docText">The odd rounds use four of the <span class="docEmphasis">K<sub>i</sub></span>, which we'll call <span class="docEmphasis">K<sub>a</sub></span>, <span class="docEmphasis">K<sub>b</sub></span>, <span class="docEmphasis">K<sub>c</sub></span>, and <span class="docEmphasis">K<sub>d</sub></span>. The even rounds use two <span class="docEmphasis">K<sub>i</sub></span>, which we'll call <span class="docEmphasis">K<sub>e</sub></span> and <span class="docEmphasis">K<sub>f</sub></span>. So round one uses <span class="docEmphasis">K</span><sub>1</sub>, <span class="docEmphasis">K</span><sub>2</sub>, <span class="docEmphasis">K</span><sub>3</sub>, <span class="docEmphasis">K</span><sub>4</sub> (i.e., in round 1, <span class="docEmphasis">K<sub>a</sub></span> = <span class="docEmphasis">K</span><sub>1</sub>, <span class="docEmphasis">K<sub>b</sub></span> = <span class="docEmphasis">K</span><sub>2</sub>, <span class="docEmphasis">K<sub>c</sub></span> = <span class="docEmphasis">K</span><sub>3</sub>, <span class="docEmphasis">K<sub>d</sub></span> = <span class="docEmphasis">K</span><sub>4</sub>). Round 2 uses <span class="docEmphasis">K</span><sub>5</sub> and <span class="docEmphasis">K</span><sub>6</sub> (i.e., in round 2, <span class="docEmphasis">K<sub>e</sub></span> = <span class="docEmphasis">K</span><sub>5</sub> and <span class="docEmphasis">K<sub>f</sub></span> = <span class="docEmphasis">K</span><sub>6</sub>). Round 3 uses <span class="docEmphasis">K</span><sub>7</sub>, <span class="docEmphasis">K</span><sub>8</sub>, <span class="docEmphasis">K</span><sub>9</sub>, <span class="docEmphasis">K</span><sub>10</sub> (<span class="docEmphasis">K<sub>a</sub></span> = <span class="docEmphasis">K</span><sub>7</sub> etc.). Round 4 uses <span class="docEmphasis">K</span><sub>11</sub> and <span class="docEmphasis">K</span><sub>12</sub>, and so forth.</p>
<p class="docText">An odd round, therefore has as input <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, <span class="docEmphasis">X<sub>d</sub></span> and keys <span class="docEmphasis">K<sub>a</sub></span>, <span class="docEmphasis">K<sub>b</sub></span>, <span class="docEmphasis">K<sub>c</sub></span>, <span class="docEmphasis">K<sub>d</sub></span>. An even round has as input <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, <span class="docEmphasis">X<sub>d</sub></span> and keys <span class="docEmphasis">K<sub>e</sub></span> and <span class="docEmphasis">K<sub>f</sub></span>.</p>
<a name="ch03lev3sec1"></a>
<h5 id="title-IDAZ1ILI" class="docSection3Title">3.4.3.1. Odd Round</h5>
<p class="docText">The odd round is simple. <span class="docEmphasis">X<sub>a</sub></span> is replaced by <span class="docEmphasis">X<sub>a</sub></span> <img src="U2297.GIF" border="0" /> <span class="docEmphasis">K<sub>a</sub></span>. <span class="docEmphasis">X<sub>d</sub></span> is replaced by <span class="docEmphasis">X<sub>d</sub></span> <img src="U2297.GIF" border="0" /> <span class="docEmphasis">K<sub>d</sub></span>. <span class="docEmphasis">X<sub>c</sub></span> is replaced by <span class="docEmphasis">X<sub>b</sub></span> + <span class="docEmphasis">K<sub>b</sub></span>. <span class="docEmphasis">X<sub>b</sub></span> is replaced by <span class="docEmphasis">X<sub>c</sub></span> + <span class="docEmphasis">K<sub>c</sub></span>.</p>
<a name="ch03fig21"></a><p><center>
<h5 class="docFigureTitle">Figure 3-21. IDEA Odd Round</h5>
</center></p><p class="docText">
<img border="0" alt="" width="350" height="123" src="03fig21.jpg" /></p>
<br />
<p class="docText">Note that this is easily reversible. To get from the new <span class="docEmphasis">X<sub>a</sub></span> to the old <span class="docEmphasis">X<sub>a</sub></span>, we perform <img src="U2297.GIF" border="0" /> with the multiplicative inverse of <span class="docEmphasis">K<sub>a</sub></span>, mod 2<sup>16</sup>+1. Likewise with <span class="docEmphasis">X<sub>d</sub></span>. To get the old <span class="docEmphasis">X<sub>b</sub></span>, given the new <span class="docEmphasis">X<sub>c</sub></span>, we add the additive inverse of <span class="docEmphasis">K<sub>b</sub></span>, i.e., we subtract <span class="docEmphasis">K<sub>b</sub></span>.</p>
<p class="docText">So when decrypting, the odd rounds run as before, but with the mathematical inverses of the keys. This will undo the work that was done during that round in encryption.</p>
<a name="ch03lev3sec2"></a>
<h5 id="title-IDAW5ILI" class="docSection3Title">3.4.3.2. Even Round</h5>
<p class="docText">The even round is a little more complicated. Again, we have <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>. We have two keys, <span class="docEmphasis">K<sub>e</sub></span> and <span class="docEmphasis">K<sub>f</sub></span>. We're going to first compute two values, which we'll call <span class="docEmphasis">Y</span><sub>in</sub> and <span class="docEmphasis">Z</span><sub>in</sub>. We'll do a function, which we'll call the <span class="docEmphasis">mangler function</span>, which takes as input <span class="docEmphasis">Y</span><sub>in</sub>, <span class="docEmphasis">Z</span><sub>in</sub>, <span class="docEmphasis">K<sub>e</sub></span>, and <span class="docEmphasis">K<sub>f</sub></span> and produces what we'll call <span class="docEmphasis">Y</span><sub>out</sub> and <span class="docEmphasis">Z</span><sub>out</sub>. We'll use <span class="docEmphasis">Y</span><sub>out</sub> and <span class="docEmphasis">Z</span><sub>out</sub> to modify <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>.</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="2"><col width="250"></col><col width="250"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">Y</span><sub>in</sub> = <span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">X<sub>b</sub></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">Z</span><sub>in</sub> = <span class="docEmphasis">X<sub>c</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">X<sub>d</sub></span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">Y</span><sub>out</sub> = ((<span class="docEmphasis">K<sub>e</sub></span> <img src="U2297.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>in</sub>) + <span class="docEmphasis">Z</span><sub>in</sub>) <img src="U2297.GIF" border="0" /> <span class="docEmphasis">K<sub>f</sub></span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">Z</span><sub>out</sub> = (<span class="docEmphasis">K<sub>e</sub></span> <img src="U2297.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>in</sub>) + <span class="docEmphasis">Y</span><sub>out</sub></p></td></tr></table></p><br />
<p class="docText">Now we compute the new <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>.</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="2"><col width="250"></col><col width="150"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">new <span class="docEmphasis">X<sub>a</sub></span> = <span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">new <span class="docEmphasis">X<sub>b</sub></span> = <span class="docEmphasis">X<sub>b</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">new <span class="docEmphasis">X<sub>c</sub></span> = <span class="docEmphasis">X<sub>c</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Z</span><sub>out</sub></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">new <span class="docEmphasis">X<sub>d</sub></span> = <span class="docEmphasis">X<sub>d</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Z</span><sub>out</sub></p></td></tr></table></p><br />
<a name="ch03fig22"></a><p><center>
<h5 class="docFigureTitle">Figure 3-22. IDEA Even Round</h5>
</center></p><p class="docText">
<img border="0" alt="" width="500" height="305" src="03fig22.jpg" /></p>
<br />
<p class="docText"><a name="iddle1472"></a>How is the work of an even round reversed? This is truly spectacular (we don't get out much). The even round is its own inverse! When performing decryption, the same keys are used as when performing encryption (not the mathematical inverses of the keys, as in the odd rounds).</p>
<p class="docText">The even round takes as input the four quantities <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>, together with keys <span class="docEmphasis">K<sub>e</sub></span> and <span class="docEmphasis">K<sub>f</sub></span>, and produces new <span class="docEmphasis">X<sub>a</sub></span>, new <span class="docEmphasis">X<sub>b</sub></span>, new <span class="docEmphasis">X<sub>c</sub></span>, and new <span class="docEmphasis">X<sub>d</sub></span>. If new <span class="docEmphasis">X<sub>a</sub></span>, new <span class="docEmphasis">X<sub>b</sub></span>, new <span class="docEmphasis">X<sub>c</sub></span>, and new <span class="docEmphasis">X<sub>d</sub></span> (with the same <span class="docEmphasis">K<sub>e</sub></span> and <span class="docEmphasis">K<sub>f</sub></span>) are fed into the even round, the output is the old <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>. Why is this true?</p>
<p class="docText">Note that new <span class="docEmphasis">X<sub>a</sub></span> = <span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> Y<sub>out</sub> and new <span class="docEmphasis">X<sub>b</sub></span> = <span class="docEmphasis">X<sub>b</sub></span> <img src="U2295.GIF" border="0" /> Y<sub>out</sub>. In the beginning of the round, <span class="docEmphasis">X<sub>a</sub></span> and <span class="docEmphasis">X<sub>b</sub></span> are <img src="U2295.GIF" border="0" />'d together, and the result is <span class="docEmphasis">Y</span><sub>in</sub>, the input to the mangler function. What if we use new <span class="docEmphasis">X<sub>a</sub></span> and new <span class="docEmphasis">X<sub>b</sub></span> instead of <span class="docEmphasis">X<sub>a</sub></span> and <span class="docEmphasis">X<sub>b</sub></span>? (new <span class="docEmphasis">X<sub>a</sub></span>) <img src="U2295.GIF" border="0" /> (new <span class="docEmphasis">X<sub>b</sub></span>) = (<span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> Y<sub>out</sub>) <img src="U2295.GIF" border="0" /> (<span class="docEmphasis">X<sub>b</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub>) = <span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">X<sub>b</sub></span>. So <span class="docEmphasis">Y</span><sub>in</sub> will be the same, whether <span class="docEmphasis">X<sub>a</sub></span> and <span class="docEmphasis">X<sub>b</sub></span> are the inputs, or new <span class="docEmphasis">X<sub>a</sub></span> and new <span class="docEmphasis">X<sub>b</sub></span> are the inputs. The same is true for <span class="docEmphasis">X<sub>c</sub></span> and <span class="docEmphasis">X<sub>d</sub></span>. (<span class="docEmphasis">Z</span><sub>in</sub> is the same value whether the inputs <span class="docEmphasis">X<sub>c</sub></span> and <span class="docEmphasis">X<sub>d</sub></span> are used, or inputs new <span class="docEmphasis">X<sub>c</sub></span> and new <span class="docEmphasis">X<sub>d</sub></span> are used.) So we've shown that the input to the mangler function is the same whether the input is <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span> or whether the input is new <span class="docEmphasis">X<sub>a</sub></span>, new <span class="docEmphasis">X<sub>b</sub></span>, new <span class="docEmphasis">X<sub>c</sub></span>, and new <span class="docEmphasis">X<sub>d</sub></span>.</p>
<p class="docText">That means the output of the mangler function will be the same whether you're doing encryption (starting with <span class="docEmphasis">X<sub>a</sub></span>, etc.) or decryption (starting with new <span class="docEmphasis">X<sub>a</sub></span>, etc.). We called the outputs of the mangler function <span class="docEmphasis">Y</span><sub>out</sub> and <span class="docEmphasis">Z</span><sub>out</sub>. To get the first output of the round (new <span class="docEmphasis">X<sub>a</sub></span>, in the case of encryption), we take the first input (<span class="docEmphasis">X<sub>a</sub></span>) and <img src="U2295.GIF" border="0" /> it with <span class="docEmphasis">Y</span><sub>out</sub>. We're going to show that with inputs of new <span class="docEmphasis">X<sub>a</sub></span>, new <span class="docEmphasis">X<sub>b</sub></span>, new <span class="docEmphasis">X<sub>c</sub></span>, and new X<span class="docEmphasis"><sub>d</sub></span>, the output of the round is <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>, i.e., that running the round with the output results in getting the input back.</p>
<p class="docText">We'll use as inputs new <span class="docEmphasis">X<sub>a</sub></span>, new <span class="docEmphasis">X<sub>b</sub></span>, new <span class="docEmphasis">X<sub>c</sub></span>, and new <span class="docEmphasis">X<sub>d</sub></span>, and we know that <span class="docEmphasis">Y</span><sub>out</sub> and <span class="docEmphasis">Z</span><sub>out</sub> are the same as they would have been with inputs of <span class="docEmphasis">X<sub>a</sub></span>, <span class="docEmphasis">X<sub>b</sub></span>, <span class="docEmphasis">X<sub>c</sub></span>, and <span class="docEmphasis">X<sub>d</sub></span>. What happens in the round? The first output of the round is computed by taking the first input and <img src="U2295.GIF" border="0" />ing it with <span class="docEmphasis">Y</span><sub>out</sub>. We also know (from the encryption round) that new <span class="docEmphasis">X<sub>a</sub></span> = <span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub>.</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">first output = first input <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">first output = (new <span class="docEmphasis">X<sub>a</sub></span>) <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">first output = (<span class="docEmphasis">X<sub>a</sub></span> <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub>) <img src="U2295.GIF" border="0" /> <span class="docEmphasis">Y</span><sub>out</sub> = <span class="docEmphasis">X<sub>a</sub></span></p></td></tr></table></p><br />
<p class="docText">Magic! With an input of new <span class="docEmphasis">X<sub>a</sub></span>, we get an output of <span class="docEmphasis">X<sub>a</sub></span>.</p>
<a name="ch03lev2sec11"></a>
<h4 id="title-IDAZXJLI" class="docSection2Title">3.4.4. Inverse Keys for Decryption</h4>
<p class="docText">IDEA is cleverly designed so that the same code (or hardware) can perform either encryption or decryption given different expanded keys. We want to compute inverse keys such that the encryption procedure, unmodified, will work as a decryption procedure. The basic idea is to take the inverses of the encryption keys and use them in the opposite order (use the inverse of the last-used encryption key as the first key used when doing decryption).</p>
<p class="docText"><a name="iddle1017"></a><a name="iddle1019"></a><a name="iddle1393"></a><a name="iddle1681"></a><a name="iddle1698"></a><a name="iddle1918"></a><a name="iddle2064"></a><a name="iddle2094"></a>Remember that for encryption, we generated 52 keys, <span class="docEmphasis">K</span><sub>1</sub> through <span class="docEmphasis">K</span><sub>52</sub>. We use four of them in each of the odd rounds, and two of them in each of the even rounds. And since we are working backwards, the first decryption keys should be inverses of the last-used encryption keys. Given that the final keys used are <span class="docEmphasis">K</span><sub>49</sub>, <span class="docEmphasis">K</span><sub>50</sub>, <span class="docEmphasis">K</span><sub>51</sub>, and <span class="docEmphasis">K</span><sub>52</sub>, in an odd round, the first four decryption keys will be inverses of the keys <span class="docEmphasis">K</span><sub>49</sub>Â<span class="docEmphasis">K</span><sub>52</sub>. <span class="docEmphasis">K</span><sub>49</sub> is used in <img src="U2297.GIF" border="0" />, so the decryption key <span class="docEmphasis">K</span><sub>1</sub> will be the multiplicative inverse of <span class="docEmphasis">K</span><sub>49</sub> mod 2<sup>16</sup>+1. And the decryption key <span class="docEmphasis">K</span><sub>4</sub> is the multiplicative inverse of <span class="docEmphasis">K</span><sub>52</sub>. Decryption keys <span class="docEmphasis">K</span><sub>2</sub> and <span class="docEmphasis">K</span><sub>3</sub> are the additive inverses of <span class="docEmphasis">K</span><sub>50</sub> and <span class="docEmphasis">K</span><sub>51</sub> (meaning negative <span class="docEmphasis">K</span><sub>50</sub> and <span class="docEmphasis">K</span><sub>51</sub>).</p>
<p class="docText">In the even rounds, as we explained, the keys do not have to be inverted. The same keys are used for encryption as decryption.</p>
<a name="ch03lev2sec12"></a>
<h4 id="title-IDAC2JLI" class="docSection2Title">3.4.5. Does IDEA Work?</h4>
<p class="docText">The definition of &quot;working&quot; is that decryption really does undo encryption, and that is easy to see. Whether it is secure or not depends on the Fundamental Tenet of Cryptography, as nobody has yet published results on how to break it. Certainly, breaking IDEA by exhaustive search for the 128-bit key requires currently unbelievable computing resources.</p>
<a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>