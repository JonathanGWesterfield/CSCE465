<html><head><title>24.4. DASS/SPX</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch24lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch24lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch24lev1sec4"></a>
<h3 id="title-IDAMGH2H" class="docSection1Title">24.4. DASS/SPX</h3>
<p class="docText">DASS stands for Distributed Authentication Security Service. It was deployed as SPX, pronounced Sphinx, and nobody has come up with an acronym expansion for SPX. It was developed at Digital Equipment Corporation and documented in RFC 1507 and [<a class="docLink" href="biblio01.html#biblio01_168">TARD91</a>]. SPX is technically the product name, whereas DASS is the architecture, rather like NetSP and KryptoKnight. We'll use the term DASS because we think it is the more commonly used term for it in the security community, though we haven't done any official polls.</p>
<a name="ch24lev2sec6"></a>
<h4 id="title-IDA5GH2H" class="docSection2Title">24.4.1. DASS Certification Hierarchy</h4>
<p class="docText">DASS has a certificate hierarchy similar to what we describe in &sect;<a class="docLink" href="ch15lev1sec3.html#ch15lev2sec8">15.3.8</a> <span class="docEmphasis">Bottom-Up with Name Constraints</span>. Conceptually there's a CA responsible for each node in the naming hierarchy. Each CA signs a certificate for its parent and for each of its children. These are known as up certificates and down certificates, respectively. DASS also allows cross certificates, where a CA can sign a certificate for any other CA, so that authentication can short-circuit the hierarchy for performance or security reasons. Also, there does not need to be a distinct CA for every node in the tree. One CA could be responsible for many parts of the naming tree.</p>
<p class="docText"><a name="iddle1082"></a><a name="iddle1153"></a><a name="iddle1160"></a><a name="iddle1577"></a><a name="iddle2140"></a>DASS uses X.509 syntax for certificates and originally envisioned storing certificates in an X.500-style directory service, but since one was not deployed, the DASS designers invented their own certificate distribution service, which they called a CDC, for Certificate Distribution Center. It not only stores certificates, but also stores encrypted private keys. Certificates are publicly readable. To obtain the encrypted private key, the client machine must prove knowledge of the user's password, and must know the public key of the <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_033">CDC</a></span> in order for this exchange to be secure. DASS would benefit from one of the protocols described in &sect;<a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">12.4</a> <span class="docEmphasis">Strong Password Credentials Download Protocols</span>, but they did not exist at the time of its design.</p>
<a name="ch24lev2sec7"></a>
<h4 id="title-IDANJH2H" class="docSection2Title">24.4.2. Login Key</h4>
<p class="docText">Once the workstation retrieves the user's private key <span class="docEmphasis">P</span>, it immediately chooses what DASS refers to as a <span class="docEmphasis">login</span> RSA key pair and then generates a certificate, which we'll call the <span class="docEmphStrong">login certificate</span>, signing it with <span class="docEmphasis">P</span>, stating the user's login public key and an expiration time. Then it forgets <span class="docEmphasis">P</span> and remembers only the login private key and the login certificate. This is similar to obtaining a TGT in Kerberos, or obtaining a GQ key in NetWare V4. The DASS method is lower-performance during login than the NetWare method because it takes more computation to generate an RSA key pair than a GQ key. During authentication the DASS method is lower-performance on the client side because RSA signature generation is slower than GQ signature generation. But the DASS method is higher-performance on the server side, because with small public exponents, RSA signature verification is faster than GQ signature verification. The DASS designers envisioned a world where workstations had cycles to burn while servers were overburdened. The NetWare designers envisioned the opposite.</p>
<a name="ch24lev2sec8"></a>
<h4 id="title-IDAGKH2H" class="docSection2Title">24.4.3. DASS Authentication Handshake</h4>
<p class="docText">Let's say user Alice accesses resource Bob. We won't distinguish between Alice's workstation and Alice. Obviously it's Alice's workstation that is performing the cryptographic operations, but we'll refer to the two ends of the conversation as Alice and Bob. The initial authentication handshake is a mutual authentication handshake based on public keys. Alice knows Bob's public key by looking up and verifying his certificate in the CDC. Bob knows Alice's long-term public key by looking up her certificate in the CDC (and verifying the certificate signature). But the key in Alice's certificate is not the key Alice will be using. Alice has to transmit her login certificate to Bob, and Bob, after following the certificate chain, now knows Alice's public key for this login session.</p>
<p class="docText">In the process of doing an authentication handshake, Alice and Bob establish a shared secret key. Future cryptographic operations, such as encryption of the conversation, are done using that shared secret key. For performance reasons, DASS is designed so that subsequent authentication exchanges between the same two parties can also be done without any public key operations, using only the shared secret key.</p>
<p class="docText">It is interesting how the secret key is established between Alice and Bob. Alice (her workstation of course) chooses a DES key <span class="docEmphasis">S</span><sub>Alice-Bob</sub> at random, encrypts <span class="docEmphasis">S</span><sub>Alice-Bob</sub> with Bob's public key, and signs the result using her login private key (for integrity protection). We'll use <span class="docEmphasis">X</span> to designate the encrypted signed <span class="docEmphasis">S</span><sub>Alice-Bob</sub>.</p>
<p class="docText">Alice sends her login certificate and <span class="docEmphasis">X</span> to Bob, along with an authenticator proving she knows the key <span class="docEmphasis">S</span><sub>Alice-Bob</sub>. Bob then does the following:</p>
<ul><li><p class="docList">gets Alice's long-term public key, by retrieving and verifying her certificate from the CDC</p></li><li><p class="docList">verifies Alice's login certificate by using her long-term public key</p></li><li><p class="docList">extracts Alice's login public key from her login certificate</p></li><li><p class="docList">reverses Alice's signature on <span class="docEmphasis">X</span> by using her login public key</p></li><li><p class="docList">reverses the encryption of <span class="docEmphasis">X</span> using his own private key, getting <span class="docEmphasis">S</span><sub>Alice-Bob</sub></p></li><li><p class="docList">verifies the authenticator by decrypting it using <span class="docEmphasis">S</span><sub>Alice-Bob</sub> and checking whether the time is valid</p></li><li><p class="docList">encrypts the timestamp using <span class="docEmphasis">S</span><sub>Alice-Bob</sub> and returns it to provide mutual authentication</p></li></ul>
<a name="ch24fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 24-5. DASS Authentication</h5>
</center></p><p class="docText">
<img border="0" alt="" width="400" height="108" src="24fig05.jpg" /></p>
<br />
<p class="docText">For performance reasons, both Bob and Alice cache both <span class="docEmphasis">S</span><sub>Alice-Bob</sub> and <span class="docEmphasis">X</span>. If Alice accesses Bob again, Alice will transmit <span class="docEmphasis">X</span> again, with a new authenticator. So why does Bob need to remember <span class="docEmphasis">X</span>? The reason he does is to save himself the trouble of cryptographically unwrapping <span class="docEmphasis">X</span> again in order to obtain <span class="docEmphasis">S</span><sub>Alice-Bob</sub>. Alice might have forgotten <span class="docEmphasis">S</span><sub>Alice-Bob</sub> and chosen a new secret. So Bob has to check if the <span class="docEmphasis">X</span> he receives is the same as the one he has cached, but if they match he can assume he's using the same key as before with Alice. If they don't match, or if Bob has forgotten the cached information, the authentication handshake works just fine. It just involves the extra computation of Bob cryptographically unwrapping <span class="docEmphasis">X</span>.</p>
<p class="docText">Why does Alice need to cache <span class="docEmphasis">X</span>? Since Alice does not know whether Bob has cached <span class="docEmphasis">S</span><sub>Alice-Bob</sub>, she has to send <span class="docEmphasis">X</span> again so that the authentication handshake can proceed whether or not <a name="iddle1108"></a><a name="iddle1250"></a><a name="iddle1504"></a><a name="iddle1588"></a>Bob has cached <span class="docEmphasis">S</span><sub>Alice-Bob</sub>. Since she has to perform cryptographic operations in order to regenerate <span class="docEmphasis">X</span>, it saves her time if she caches <span class="docEmphasis">X</span>.</p>
<p class="docText">An interesting feature of DASS is that the authentication handshake is designed to work in a single message in the case of one-way authentication, and two messages in the case of mutual authentication. The price it pays to reach this theoretical minimum number of messages is that it requires roughly synchronized clocks, like Kerberos.</p>
<a name="ch24lev2sec9"></a>
<h4 id="title-IDAWPH2H" class="docSection2Title">24.4.4. DASS Authenticators</h4>
<p class="docText">When Alice initiates a connection to Bob, she sends an authenticator. When mutual authentication is required, Bob sends an authenticator back to Alice. The authenticator is very different in the two directions. In the Alice<img src="U2192.GIF" border="0" />Bob direction, Alice sends Bob an unencrypted timestamp and a MAC. The MAC is computed by doing a DES CBC residue using the secret key <span class="docEmphasis">S</span><sub>Alice-Bob</sub> and an IV of 0, computed over the timestamp and the network layer source and destination addresses extracted from the network layer header. The authenticator Bob sends back to Alice is the timestamp encrypted with <span class="docEmphasis">S</span><sub>Alice-Bob</sub>.</p>
<a name="ch24lev2sec10"></a>
<h4 id="title-IDAMQH2H" class="docSection2Title">24.4.5. DASS Delegation</h4>
<p class="docText">DASS is designed so that if Alice wants to delegate to Bob in addition to performing an authentication handshake with him, the delegation can be piggybacked on the authentication handshake.</p>
<p class="docText">Recall that during the authentication handshake (without delegation), Alice sends Bob her login certificate, the magic quantity <span class="docEmphasis">X</span>, and an authenticator. Remember that <span class="docEmphasis">X</span> is the session key <span class="docEmphasis">S</span><sub>Alice-Bob</sub> encrypted with Bob's public key and signed with Alice's login key.</p>
<p class="docText">If delegation is being done as well as authentication, there's one less public key operation, because instead of sending <span class="docEmphasis">X</span> (which is the session key encrypted with Bob's public key and then signed with Alice's private key), Alice just sends the session key encrypted with Bob's public key. In order to delegate to Bob, she sends Bob her login private key encrypted with <span class="docEmphasis">S</span><sub>Alice-Bob</sub>. As in the non-delegation case, she also sends an authenticator proving she knows <span class="docEmphasis">S</span><sub>Alice-Bob</sub>. It takes some thought as to why, in the delegation case, it isn't necessary to sign the encrypted session key, whereas it is necessary in the non-delegation case. The DASS designers really enjoyed standing on their heads to minimize public key operations (see <a class="docLink" href="ch24lev1sec10.html#ch24qa1q1">Homework Problem 1</a>).</p>
<a name="ch24lev2sec11"></a>
<h4 id="title-IDAXRH2H" class="docSection2Title">24.4.6. Saving Bits</h4>
<p class="docText"><a name="iddle1486"></a><a name="iddle1582"></a><a name="iddle1713"></a>While DASS was intended to work with a variety of protocols, and was only actually deployed with TCP/IP, the DASS designers wanted to integrate their protocols with DECnet Phase IV, which introduced some interesting constraints. They could only piggyback the security information on existing transport layer connection messages if the additional information did not make the transport layer connection messages longer than an Ethernet packet (approximately 1500 bytes). Alice initiates contact with Bob with a <span class="docEmphRomanAlt">connect request</span> message. Bob replies with a <span class="docEmphRomanAlt">connect confirm</span> message. There were only 16 spare bytes in a <span class="docEmphRomanAlt">connect confirm</span>, and DASS managed to only use 8 of them. DASS needed more space in a <span class="docEmphRomanAlt">connect request</span>, because Alice sends her login certificate, <span class="docEmphasis">X</span>, and an authenticator. Luckily, there was enough room. But there would not have been enough room if the DASS designers didn't spend a lot of time doing clever compression of the data they needed to send.</p>
<p class="docText">The exact packet formats are not important, but the most dramatic encoding trick they played was the encoding of Alice's login private key when she transmits it to Bob for delegation. Recall that an RSA public key consists of &lt;<span class="docEmphasis">e</span>,<span class="docEmphasis">n</span>&gt;, where <span class="docEmphasis">n</span> is the modulus and <span class="docEmphasis">e</span> is the public exponent. An RSA private key consists of &lt;<span class="docEmphasis">d</span>,<span class="docEmphasis">n</span>&gt;. Alice's login certificate contains &lt;<span class="docEmphasis">e</span>,<span class="docEmphasis">n</span>&gt;. You'd expect Alice to send <span class="docEmphasis">d</span> in order to give Bob her login private key. But instead, she sends <span class="docEmphasis">p</span>, which is the smaller of the factors of <span class="docEmphasis">n</span>, and will be about half as big as <span class="docEmphasis">d</span> (so it will be about 256 bits instead of 512). Bob has to divide <span class="docEmphasis">n</span> by <span class="docEmphasis">p</span> to get <span class="docEmphasis">q</span>, and then use Euclid's algorithm to calculate <span class="docEmphasis">d</span> (given that he knows <span class="docEmphasis">e</span> and <span class="docEmphasis">n</span> from her login certificate). Actually, when doing delegation it's friendly to pass more than just <span class="docEmphasis">d</span>, since if Bob knows <span class="docEmphasis">n</span>'s factorization he can do private key operations more efficiently. Given <span class="docEmphasis">p</span>, Bob can compute all the information that would have been good to send him. If instead, Alice were to pass all the information so that Bob didn't need to do any computation, it would take about 2&#189; times the size of the modulus (so about 1300 bits). The DASS method makes Bob do some work up front, but then he can sign efficiently on Alice's behalf.</p>
<p class="docText">DASS does use ASN.1 encoding, which might seem surprising since its designers were so worried about encoding efficiency. But they were very careful to avoid sending redundant information, and they were clever in their use of ASN.1 syntax. By using <span class="docEmphStrong"><tt>IMPLICIT</tt></span> and other tricks they avoided the size explosion found in Kerberos V5 and X.509.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch24lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch24lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>