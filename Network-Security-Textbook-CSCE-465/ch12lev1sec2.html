<html><head><title>12.2. Lamport's Hash</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch12lev1sec2"></a>
<h3 id="title-IDANT0BD" class="docSection1Title">12.2. Lamport's Hash</h3>
<blockquote>
<p class="docText"><span class="docEmphasis">It's a poor sort of memory that only works backwards</span>.</p>
<p class="docText">ÂThe White Queen (in <span class="docEmphasis">Through the Looking Glass</span>)</p></blockquote>
<p class="docText">Leslie Lamport invented an interesting one-time password scheme [<a class="docLink" href="biblio01.html#biblio01_101">LAMP81</a>]. This scheme allows Bob to authenticate Alice in a way that neither eavesdropping on an authentication exchange nor reading Bob's database enables someone to impersonate Alice, and it does it without using public key cryptography. Alice (a human) remembers a password. Bob (the server that will authenticate Alice) has a database where it stores, for each user:</p>
<ul><li><p class="docList">username</p></li><li><p class="docList"><span class="docEmphasis">n</span>, an integer which decrements each time Bob authenticates the user</p></li><li><p class="docList">hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>), i.e., hash(hash(...(hash(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>))...))</p></li></ul>
<p class="docText">First, how is the password database entry associated with Alice configured? Alice chooses a password, and a reasonably large number <span class="docEmphasis">n</span> (like 1000) is chosen. The user registration software computes <span class="docEmphasis">x</span><sub>1</sub>=hash(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>). Then it computes <span class="docEmphasis">x</span><sub>2</sub>=hash(<span class="docEmphasis">x</span><sub>1</sub>). It continues this process <span class="docEmphasis">n</span> times, resulting in <span class="docEmphasis">x</span><span class="docEmphasis"><sub>n</sub></span>=hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>), which it sends to Bob, along with <span class="docEmphasis">n</span>.</p>
<p class="docText">When Alice wishes to prove her identity to Bob, she types her name and password to her workstation. The workstation then sends Alice's name to Bob, which sends back <span class="docEmphasis">n</span>. Then the workstation computes hash<span class="docEmphasis"><sup>n</sup></span><sup>-1</sup>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>) and sends the result to Bob. Bob takes the received quantity, hashes it once, and compares it with its database. If it matches, Bob considers the response valid, replaces the stored quantity with the received quantity, and replaces <span class="docEmphasis">n</span> by <span class="docEmphasis">n</span>-1.</p>
<p class="docText">If <span class="docEmphasis">n</span> ever gets to 1, then Alice needs to set her password again with Bob. There is no completely secure way of doing this over an insecure network, since this scheme does not allow encryption or integrity protection of messages between Alice and Bob. But in practice, in many situations, it suffices for Alice to choose a new password, compute hash<span class="docEmphasis"><sup>n</sup></span>(<span class="docEmphasis">new password</span>), and transmit hash<span class="docEmphasis"><sup>n</sup></span>(<span class="docEmphasis">new password</span>) and <span class="docEmphasis">n</span> to the server unencrypted across the network.</p>
<p class="docText">An enhancement is to add <b><a class="docLink" href="app02.html#gloss01_195">salt</a></b>, a number chosen at password installation time to be unique for user Alice. The salt is stored at Bob and concatenated to the password before hashing. So rather than computing hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>), the enhanced Lamport hash computes hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|<i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>). To set the password, the workstation chooses a value for salt, and computes <span class="docEmphasis">x</span><sub>1</sub>=hash(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|<i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>), then <span class="docEmphasis">x</span><sub>2</sub>=hash(<span class="docEmphasis">x</span><sub>1</sub>), then continues this process <span class="docEmphasis">n</span> times, resulting in <span class="docEmphasis">x</span><span class="docEmphasis"><sub>n</sub></span>=hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|<i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>), which it sends to Bob, along with <span class="docEmphasis">n</span> and <i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>.</p>
<a name="ch12fig01"></a><p><center>
<h5 class="docFigureTitle">Protocol 12-1. Lamport's Hash</h5>
</center></p><p class="docText"><div class="v1"><a target="_blank" href="12fig01_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="133" src="12fig01.jpg" /></p>
<br />
<p class="docText">What do we gain by adding salt? It allows Alice to securely use the same password on multiple servers as long as a different salt value is used when installing the password on each of the other servers. When she logs into Bob, she'll wind up decrementing the <span class="docEmphasis">n</span> stored at Bob, but this will not affect the <span class="docEmphasis">n</span> stored at other servers. In other words, when she logs into Bob, if Bob sends her workstation &lt;<span class="docEmphasis">n</span>=87, <i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>=69&gt;, her workstation will compute hash<sup>86</sup>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|69). If when Bob hashes the received quantity the result matches hash<sup>87</sup>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|69) in his database, then Bob will decrement <span class="docEmphasis">n</span> and replace the stored hash with the received hash. When she logs into Fred, Fred might send her workstation &lt;<span class="docEmphasis">n</span>=127, <i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>=105&gt;, in which case her workstation will compute hash<sup>126</sup>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|105) to send to Fred. A way of ensuring that the salt is different on different servers is to also hash in the server name, as in <span class="docEmphasis">x</span><span class="docEmphasis"><sub>n</sub></span>=hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>|<i><a class="docLink" href="app02.html#gloss01_195">salt</a></i>|<span class="docEmphasis">servername</span>).</p>
<p class="docText">Another advantage of salt is that Alice does not need to change her password when <span class="docEmphasis">n</span> decrements to 1 at Bob. Instead the same password can be reinstalled with a different salt value.</p>
<p class="docText">There's an additional value to salt, which is the same as the original UNIX reason for adding salt to the password database (see &sect;<a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">5.2.4.1</a> <span class="docEmphasis">UNIX Password Hash</span>). Adding salt prevents an intruder from precomputing hash<span class="docEmphasis"><sup>k</sup></span> for all passwords in a dictionary and all values of <span class="docEmphasis">k</span> from 1 through 1000, stealing the database at Bob, and then comparing the precomputed hashes with the stolen password hashes of all the users.</p>
<p class="docText">Lamport's hash has interesting properties. It is similar to public key schemes in that the database at Bob is not security sensitive (for reading), other than dictionary attacks to recover the user's password. It has several disadvantages relative to public key schemes. One problem is that you can only log in a finite number of times before having to reinstall password information at the server.</p>
<p class="docText">Another problem is there is no mutual authentication, i.e., Alice does not know she is definitely talking to Bob. This makes it difficult to establish a session key or prevent a man-in-the-middle attack. One might try to have Alice authenticate herself and then do a Diffie-Hellman exchange with Bob to establish a session key. But Trudy could hijack the conversation after the inital authentication <a name="iddle1069"></a><a name="iddle1513"></a><a name="iddle1942"></a><a name="iddle2009"></a>and before the Diffie-Hellman exchange. Another idea might be for Alice and Bob to do the Diffie-Hellman exchange first and then do the authentication handshake protected with the Diffie-Hellman key. But Trudy could act as a man-in-the-middle, establishing a separate Diffie-Hellman key with each of Alice and Bob, and simply relay the authentication handshake. Once Alice sends the authentication information, Trudy can break her connection with Alice and continue conversing with Bob, impersonating Alice.</p>
<p class="docText">There's another security weakness, which we'll call the <span class="docEmphStrong">small</span> <span class="docEmphBoldItalic">n</span> <span class="docEmphStrong">attack</span>. Suppose an intruder, Trudy, were to impersonate Bob's network address and wait for Alice to attempt to log in. When Alice attempts to log into Bob, Trudy sends back a small value for <span class="docEmphasis">n</span>, say 50 (and Alice's salt value at Bob, which she can know from having eavesdropped on a previous authentication by Alice to Bob). When Alice responds with hash<sup>50</sup>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>), Trudy will have enough information to impersonate Alice for some time, assuming that the actual <span class="docEmphasis">n</span> at Bob is greater than 50. What can be done to protect against this? Alice's workstation could display <span class="docEmphasis">n</span> to the human Alice. If Alice remembers approximately what <span class="docEmphasis">n</span> should be, then Alice can do a rough sanity check on <span class="docEmphasis">n</span>.</p>
<p class="docText">Lamport's hash can also be used in environments where the workstation doesn't calculate the hash, for example when:</p>
<ul><li><p class="docList">Alice is logging in from a &quot;dumb terminal&quot;</p></li><li><p class="docList">Alice is logging in from a workstation that does not have Lamport hash code, or</p></li><li><p class="docList">Alice is logging in from a workstation that she doesn't trust enough to tell her password</p></li></ul>
<p class="docText">We'll call this the <span class="docEmphStrong">human and paper</span> environment, and call the other environment the <b><a class="docLink" href="app02.html#gloss01_244">workstation</a></b> environment. The way Lamport's hash works in the human and paper environment is that when the information &lt;<span class="docEmphasis">n</span>,hash<span class="docEmphasis"><sup>n</sup></span>(<i><a class="docLink" href="app02.html#gloss01_158">password</a></i>)&gt; is installed at the server, all the values of hash<span class="docEmphasis"><sup>i</sup></span>(pass-word) for <span class="docEmphasis">i</span>&lt;<span class="docEmphasis">n</span> are computed, encoded into a typeable string, printed on a paper, and given to Alice. When she logs in, she uses the string at the top of the page, and then crosses that value out, using the next value the next time. This approach automatically protects against the small <span class="docEmphasis">n</span> attack. Of course, losing the piece of paper, especially if it falls into the wrong hands, is a problem.</p>
<p class="docText">How big a string does Alice have to type? Ordinarily, a hash function is 128 bits, which would mean a string of about 20 characters. This would be fairly annoying to type. But the scheme is sufficiently secure if a 64-bit hash is used, and then Alice only has to type about 10 characters. It's not necessary to invent a 64-bit hash function. Any hash function (such as MD5) can be used, and have all but 64 bits of the output discarded.</p>
<p class="docText">It is interesting that the human and paper environment is not vulnerable to the small <span class="docEmphasis">n</span> attack, since the human just always uses the next value on the list and can't be tricked into sending an item further down on the list.</p>
<p class="docText">There is a deployed version of Lamport's hash, known as S/Key, implemented by Phil Karn. It was standardized in RFC 1938 <span class="docEmphasis">A one-time password system</span>. It operates in both the workstation <a name="iddle1117"></a><a name="iddle1316"></a><a name="iddle1627"></a><a name="iddle2040"></a>and human and paper environments. It makes no effort to address the small <span class="docEmphasis">n</span> attack, but it certainly is a vast improvement over cleartext passwords and is gaining popularity.</p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>