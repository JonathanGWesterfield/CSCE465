<html><head><title>11.3. Integrity/Encryption for Data</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch11lev1sec3"></a>
<h3 id="title-IDAR4H5F" class="docSection1Title">11.3. Integrity/Encryption for Data</h3>
<p class="docText">In order to provide integrity protection and/or encryption of the data following the authentication exchange it is necessary for Alice and Bob to use cryptography to encrypt and/or add integrity checks to the data messages. We described several bases for the authentication exchange:</p>
<ul><li><p class="docList">&sect;<a class="docLink" href="ch11lev1sec1.html#ch11lev2sec1">11.1.1</a> <span class="docEmphasis">Shared Secret</span>ÂAlice and Bob share a secret key <span class="docEmphasis">K</span><sub>Alice-Bob</sub>.</p></li><li><p class="docList">&sect;<a class="docLink" href="ch11lev1sec2.html#ch11lev2sec5">11.2.3</a> <span class="docEmphasis">Public Keys</span>ÂAlice and Bob know each other's public keys, as well as their own private keys.</p></li><li><p class="docList">&sect;<a class="docLink" href="ch11lev1sec1.html#ch11lev2sec2">11.1.2</a> <span class="docEmphasis">One-Way Public Key</span>Âonly one side has a public key pair; authentication is one-way.</p></li></ul>
<p class="docText">As we discussed in &sect;<a class="docLink" href="ch09lev1sec8.html#ch09lev1sec8">9.8</a> <span class="docEmphasis">Session Key Establishment</span>, it is desirable for Alice and Bob to establish a shared secret per-conversation key (known as the <span class="docEmphStrong">session key</span>) to be used for integrity protection and encryption, even if they already know enough long-term secrets to be able to encrypt and add integrity checks to messages. So we'll want to enhance the authentication exchange so that after the initial handshake both Alice and Bob will share a session key. It is important that an eavesdropper not be able to figure out what the session key is. Once a session key is established, the workstation can forget the user's password, or at least a piece of untrusted software can proceed with a cryptographically protected conversation without being told any long-term secrets. First we'll discuss how to establish a session key for each of the three cases above. Then we'll discuss how to use the session key for encryption and/or integrity protection.</p>
<a name="ch11lev2sec7"></a>
<h4 id="title-IDA4AI5F" class="docSection2Title">11.3.1. Shared Secret</h4>
<p class="docText">Alice and Bob have a shared secret key <span class="docEmphasis">K</span><sub>Alice-Bob</sub>. The authentication exchange is shown in <a class="docLink" href="#ch11fig14">Protocol 11-14</a>. Perhaps mutual authentication was done, in which case there are two <span class="docEmphasis">R</span>s, <span class="docEmphasis">R</span><sub>1</sub> and <span class="docEmphasis">R</span><sub>2</sub>. Perhaps authentication was done using timestamps instead of random <span class="docEmphasis">R</span>s. At any rate, there is sufficient information in this protocol so that Alice and Bob can establish a shared session key at this point in the conversation. They can, for example, use (<span class="docEmphasis">K</span><sub>Alice-Bob</sub> +1){<span class="docEmphasis">R</span>} as the session key. More generally, they can take the shared secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub> and modify it in some way, then encrypt the challenge <span class="docEmphasis">R</span> using the modified <span class="docEmphasis">K</span><sub>Alice-Bob</sub> as the key, and use the result as the session key.</p>
<p class="docText"></p><a name="ch11fig14"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-14. Authentication with shared secret</h5>
</center></p><p class="docText">
<img border="0" alt="" width="400" height="117" src="11fig14.jpg" /></p>
<br />
<p class="docText">Why do they need to modify <span class="docEmphasis">K</span><sub>Alice-Bob</sub>? Why can't they use <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>} as the key? The reason they can't use <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>} is that <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>} is transmitted by Alice as the third message in the authentication handshake, so an eavesdropper would see that value, and it certainly would not be secure as a session key.</p>
<p class="docText">How about using <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>+1} as the session key? There's a more subtle reason why that isn't secure. Suppose Alice and Bob have started a conversation in which Bob used <span class="docEmphasis">R</span> as the challenge. Perhaps Trudy recorded the entire subsequent conversation, encrypted using <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>+1}. Later, Trudy can impersonate Bob's network layer address to Alice, thereby tricking Alice into attempting to communicate with Trudy instead of Bob, and Trudy (pretending to be Bob) can send <span class="docEmphasis">R</span>+1 as a challenge, to which Alice will respond with <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>+1}:</p>
<a name="ch11fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 11-15. Trudy impersonates Bob</h5>
</center></p><p class="docText">
<img border="0" alt="" width="400" height="116" src="11fig15.jpg" /></p>
<br />
<p class="docText">Then Trudy will be able to decrypt the previous Alice-Bob conversation.</p>
<p class="docText">So, Alice and Bob, after the authentication exchange, know <span class="docEmphasis">K</span><sub>Alice-Bob</sub> and <span class="docEmphasis">R</span>, and there are many combinations of the two quantities that would be perfectly acceptable as a session key, but there are also some that are not acceptable as a session key. What makes a good session key? It must be different for each session, unguessable by an eavesdropper, and should not consist of a quantity <span class="docEmphasis">X</span> encrypted with <span class="docEmphasis">K</span><sub>Alice-Bob</sub>, where <span class="docEmphasis">X</span> is a value that can be predicted or extracted by an intruder (as just discussed for <span class="docEmphasis">X</span> = <span class="docEmphasis">R</span>+1). See <a class="docLink" href="ch11lev1sec9.html#ch11qa1q3">Homework Problem 3</a>.</p>
<a name="ch11lev2sec8"></a>
<h4 id="title-IDAIGI5F" class="docSection2Title">11.3.2. Two-Way Public Key Based Authentication</h4>
<p class="docText">Suppose we are doing two-way authentication using public key technology, so that Alice and Bob know their own private keys and know each other's public keys. How can they establish a session key? We'll discuss various possibilities, with their relative security and performance strengths and weaknesses.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">One side, say Alice, could choose a random number <span class="docEmphasis">R</span>, encrypt it with Bob's public key, and send {<span class="docEmphasis">R</span>}<sub>Bob</sub> to Bob attached to one of the messages in the authentication exchange. This scheme has a security flaw. Our intruder, Trudy, could hijack the conversation by picking her own <span class="docEmphasis">R</span>, encrypting it with Bob's public key, and send that to Bob (while impersonating Alice's network layer address) in place of the encrypted key supplied by Alice.</p></div></li><li><div style="font-weight:normal"><p class="docList">Alice could, in addition to encrypting <span class="docEmphasis">R</span> with Bob's public key, sign the result. So she'd send [{<span class="docEmphasis">R</span>}<sub>Bob</sub>]<sub>Alice</sub> to Bob. Bob would take the received quantity, first verify Alice's signature using Alice's public key, and then use his private key on the result to obtain <span class="docEmphasis">R</span>. If Trudy were to attempt the same trick as in scheme 1, namely choosing her own <span class="docEmphasis">R</span> and sending it to Bob, she wouldn't be able to forge Alice's signature on the encrypted <span class="docEmphasis">R</span>.</p><p class="docList">This scheme is reasonable. It has a minor security weakness that can be fixed partially (in 3, below) or completely (in 4, below). The flaw is that if Trudy records the entire Alice-Bob conversation, and then later <b><a class="docLink" href="app02.html#gloss01_155">overruns</a></b> Bob (i.e., manages to take over node Bob and learn all Bob's secrets), she will be able to decrypt the conversation she'd recorded. It seems like the kind of threat that only a very energetic paranoid would bother worrying about, but we'll show how to fix it. First note that if Alice is careful to forget <span class="docEmphasis">R</span> after terminating the conversation with Bob, then overrunning Alice will not enable Trudy to decrypt the recorded conversation, since Trudy needs Alice's public key and Bob's private key to retrieve the session key <span class="docEmphasis">R</span>. She can only get that by overrunning Bob.</p></div></li><li><div style="font-weight:normal"><p class="docList">This is like 2, above, but Alice picks <span class="docEmphasis">R</span><sub>1</sub> and Bob picks <span class="docEmphasis">R</span><sub>2</sub>. Alice sends {<span class="docEmphasis">R</span><sub>1</sub>}<sub>Bob</sub> to Bob. Bob sends {<span class="docEmphasis">R</span><sub>2</sub>}<sub>Alice</sub> to Alice. The session key will be <span class="docEmphasis">R</span><sub>1</sub><img src="U2295.GIF" border="0" /><span class="docEmphasis">R</span><sub>2</sub>. Overrunning Alice will enable Trudy to retrieve <span class="docEmphasis">R</span><sub>2</sub>. Overrunning Bob will enable Trudy to retrieve <span class="docEmphasis">R</span><sub>1</sub>. But in order to retrieve <span class="docEmphasis">R</span><sub>1</sub><img src="U2295.GIF" border="0" /><span class="docEmphasis">R</span><sub>2</sub>, she'll need to overrun them both.</p><p class="docList">In 2 we had Alice sign her quantity (i.e., she sent [{<span class="docEmphasis">R</span>}<sub>Bob</sub>]<sub>Alice</sub> instead of merely {<span class="docEmphasis">R</span>}<sub>Bob</sub>). Why isn't it necessary for Bob and Alice to sign their quantities here? Alice and Bob don't need to sign their quantities because although Trudy is perfectly capable of inserting her own {<span class="docEmphasis">R</span><sub>1</sub>}<sub>Bob</sub>, she cannot decrypt {<span class="docEmphasis">R</span><sub>2</sub>}<sub>Alice</sub>. Trudy might therefore be able to inject confusion into the system by having Bob think <span class="docEmphasis">R</span><sub>1</sub><img src="U2295.GIF" border="0" /><span class="docEmphasis">R</span><sub>2</sub> is a key he shares with Alice, but since Trudy only knows <span class="docEmphasis">R</span><sub>1</sub>, she can't actually see any data intended for Alice.</p></div></li><li><div style="font-weight:normal"><p class="docList"><a name="iddle1642"></a>Alice and Bob can do a Diffie-Hellman key establishment exchange (see &sect;<a class="docLink" href="ch06lev1sec4.html#ch06lev1sec4">6.4</a> <span class="docEmphasis">Diffie-Hellman</span>), where each signs the quantity they are sending. In Diffie-Hellman, Alice chooses a random <span class="docEmphasis">R</span><sub>A</sub>. Bob chooses a random <span class="docEmphasis">R</span><sub>B</sub>. They have already agreed on public numbers <span class="docEmphasis">g</span> and <span class="docEmphasis">p</span>. Alice transmits <span class="docEmphasis">g<sup>R<sub>A</sub></sup></span> mod <span class="docEmphasis">p</span>. Bob transmits <span class="docEmphasis">g<sup>R<sub>B</sub></sup></span> mod <span class="docEmphasis">p</span>. They will use <span class="docEmphasis">g<sup>R<sub>A</sub>R<sub>B</sub></sup></span> mod <span class="docEmphasis">p</span> as their session key. When we say they each sign the quantity they send, we mean that Alice doesn't simply transmit <span class="docEmphasis">g<sup>R<sub>A</sub></sup></span> mod <span class="docEmphasis">p</span>. She actually transmits [<span class="docEmphasis">g<sup>R<sub>A</sub></sup></span> mod <span class="docEmphasis">p</span>]<sub>Alice</sub>. And Bob actually transmits [<span class="docEmphasis">g<sup>R<sub>B</sub></sup></span> mod <span class="docEmphasis">p</span>]<sub>Bob</sub>. In this scheme, even if Trudy overruns both Alice and Bob, she won't be able to decrypt recorded conversations because she won't be able to deduce either <span class="docEmphasis">R</span><sub>A</sub> or <span class="docEmphasis">R</span><sub>B</sub>.</p></div></li></ol></div>
<a name="ch11lev2sec9"></a>
<h4 id="title-IDAONI5F" class="docSection2Title">11.3.3. One-Way Public Key Based Authentication</h4>
<p class="docText">In some cases only one of the parties in the conversation has a public/private key pair. Commonly, as in the case of SSL, it is assumed that servers will have public keys, and clients will not bother obtaining keys and certificates. Cryptographic authentication is one-way. The protocol assures the client that she is talking to the right server Bob, but if Bob wants to authenticate Alice, after the cryptographic session is established, Alice will send a name and password. Here are some ways of establishing a shared session key in this case.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Alice could choose a random number <span class="docEmphasis">R</span>, encrypt it with Bob's public key, send {<span class="docEmphasis">R</span>}<sub>Bob</sub> to Bob, and <span class="docEmphasis">R</span> could be the session key. A weakness in this scheme is that if Trudy records the conversation and later overruns Bob, she can decrypt the conversation (since she can retrieve <span class="docEmphasis">R</span> once she steals Bob's private key).</p></div></li><li><div style="font-weight:normal"><p class="docList">Bob and Alice could do a Diffie-Hellman exchange, where Bob signs his Diffie-Hellman quantity. Alice can't sign hers because she doesn't have a public key. This is slightly more secure than scheme 1 because Trudy can't later overrun Bob and retrieve the session key (assuming Bob has diligently forgotten the session key after terminating the conversation with Alice).</p></div></li></ol></div>
<p class="docText">Note that neither of these schemes assure Bob he's really talking to Alice, but in either scheme Bob is assured that the entire conversation is with a single party.</p>
<a name="ch11lev2sec10"></a>
<h4 id="title-IDAVOI5F" class="docSection2Title">11.3.4. Privacy and Integrity</h4>
<p class="docText">In &sect;<a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">4.3</a> <span class="docEmphasis">Generating MACs</span> we discuss various methods of computing a MAC with secret key cryptography. In &sect;<a class="docLink" href="ch05lev1sec2.html#ch05lev2sec2">5.2.2</a> <span class="docEmphasis">Computing a MAC with a Hash</span> we discuss how to do it with a message digest function. As noted in &sect;<a class="docLink" href="ch04lev1sec3.html#ch04lev2sec6">4.3.1</a> <span class="docEmphasis">Ensuring Privacy and Integrity Together</span>, there is currently no standard algorithm for providing both privacy and integrity with a single key and a single cryptographic pass <a name="iddle1541"></a>over the data. But see &sect;<a class="docLink" href="ch04lev1sec3.html#ch04lev2sec10">4.3.5</a> <span class="docEmphasis">Offset Codebook Mode (OCB)</span>. Until a standard is adopted, plausible solutions are: develop two keys in the authentication exchange and do the two operations independently; make a second key by modifying the first (by changing a few bits in a predictable way); use different cryptographic algorithms so a common key is (presumably) irrelevant; or use a weak checksum for integrity inside a strong algorithm for privacy.</p>
<p class="docText">The messages exchanged on a connection once the keys are known are likely to be in the form of discrete messages, where the authenticity of each must be determined before the conversation can proceed. Even if a message is authentic, it could be misinterpreted if played out of order. An attacker might, for example, record a message and then replay it later on in the exchange. This can be prevented by having all of the messages contain sequence numbers so that an out-of-order message is detected. Sequence numbers are used in both versions of Kerberos. Alternatively, the integrity code can be computed using not just the current message, but information about all previous messages, so that a replayed message will not be valid. This technique is used by Novell (see &sect;<a class="docLink" href="ch24lev1sec1.html#ch24lev1sec1">24.1</a> <span class="docEmphasis">NetWare V3</span>).</p>
<p class="docText">Another form of attack is reflection. Here the attacker records a message going in one direction and replays it in the other. If the same sequence number could be valid in both directions, such a message could be misinterpreted. This can be avoided by using sequence numbers in different ranges for the two directions, by having a <span class="docEmphSmaller">DIRECTION BIT</span> somewhere in the message, or by having the integrity code computed by some subtly different algorithm in the two directions.</p>
<p class="docText">Sequence numbers have to be very large or you face the possibility of running out during a conversation. If you reuse sequence numbers during a conversation (i.e. while using the same session key), an attacker can replay an old recorded message when its sequence number recurs. This is an unlikely threat, but it is good form to prevent it. The best method is to change keys periodically during the conversation. (This also limits the amount of material a cryptanalyst can gather all encrypted under one key.) Changing keys in the middle of a conversation is known as <span class="docEmphStrong">key rollover</span>. The simplest method of rolling over a key is to have one end choose a random key, encrypt it under the existing key, and send it to the other end. Because an attacker might cryptanalyze one key and use it to decrypt the subsequent keys, a stronger design would periodically repeat the authentication protocol or roll over keys by doing a Diffie-Hellman exchange to get the new key and integrity-protecting the public numbers with the old key.</p>
<p class="docText">Sequence number maintenance and key rollover can be significantly complicated if encryption is done using a communications protocol that does not automatically retry transmissions after errors and put messages back in order before decrypting them.</p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>