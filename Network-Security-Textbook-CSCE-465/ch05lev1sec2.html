<html><head><title>5.2. Nifty Things to Do with a Hash</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch05lev1sec2"></a>
<h3 id="title-IDABE3WE" class="docSection1Title">5.2. Nifty Things to Do with a Hash</h3>
<p class="docText">Before we look at the details of several popular hash algorithms, let's look at some interesting uses of hash algorithms. Surprisingly, if there is a shared secret, the hash algorithms can be used in all the ways that secret cryptography is used. It is a little confusing calling the schemes in the next few sections &quot;message digest&quot; schemes, since they do involve a shared secret. By our definition in &sect;<a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3">2.3</a> <a name="iddle1607"></a><a name="iddle1609"></a><a name="iddle1615"></a><a name="iddle1617"></a><a name="iddle1621"></a><a name="iddle1921"></a><a name="iddle2015"></a><span class="docEmphasis">Types of Cryptographic Functions</span> in which we said something that had a single shared secret was a secret key algorithm, these might be considered secret key algorithms. Never take definitions too seriously. The significant difference between a secret key algorithm and a message digest algorithm is that a secret key algorithm is designed to be reversible and a message digest algorithm is designed to be impossible to reverse. In this section we'll use MD as a &quot;generic&quot; message digest (cryptographic hash) algorithm.</p>
<a name="ch05sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Why are there so many message digest functions?</h2>
<p class="docText">Surprisingly, the drive for message digest algorithms started with public key cryptography. RSA was invented, which made possible digital signatures on messages, but computing a signature on a long message with RSA was sufficiently slow that RSA would not have been practical by itself. A cryptographically secure message digest function with high performance would make RSA much more useful. Instead of having to compute a signature over a whole long message, the message could be compressed into a small size by first performing a message digest and then computing the RSA signature on the digest. So MD and MD2 were created. MD was proprietary and never published. It was used in some of <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_192">RSADSI</a></span>'s secure mail products. MD2 is documented in RFC 1319.</p>
<p class="docText">Then Ralph Merkle of Xerox developed a message digest algorithm called SNEFRU [<a class="docLink" href="biblio01.html#biblio01_113">MERK90</a>] that was several times faster than MD2. This prodded Ron Rivest into developing MD4 (RFC 1320), a digest algorithm that took advantage of the fact that newer processors could do 32-bit operations, and was therefore able to be even faster than SNEFRU. Then SNEFRU was broken [<a class="docLink" href="biblio01.html#biblio01_012">BIHA92</a>] (the cryptographic community considered it broken because someone was able to find two messages with the same SNEFRU digest). Independently, [<a class="docLink" href="biblio01.html#biblio01_038">DENB92</a>] found weaknesses in a version of MD4 with two rounds instead of three. This did not officially break MD4, but it made Ron Rivest sufficiently nervous that he decided to strengthen it, and create MD5 (RFC 1321), which is a little slower than MD4. NIST subsequently proposed SHA, which is very similar to MD5, but even more strengthened, and also a little slower. Probably after discovering a never published flaw in the SHA proposal, NIST revised it at the twelfth hour in an effort to make it more secure, and called the revised version SHA-1 (see &sect;<a class="docLink" href="ch05lev1sec6.html#ch05lev2sec21">5.6.3</a> <span class="docEmphasis">SHA-1 Operation on a 512-bit Block</span>). MD2 and MD4 were subsequently broken (in the sense that collisions were found), though they remain secure for most uses. At the time of this writing, NIST was working on a new hash function (probably to be named SHA-2) to increase the number of bits of output to 256 in order to have security comparable to the AES encryption algorithm.</p>
<p class="docText">Yes, Virginia, there was an MD3, but it was superseded by MD4 before it was ever published or used.</p>
</td></tr></table></p><br />
<a name="ch05lev2sec1"></a>
<h4 id="title-IDA2H3WE" class="docSection2Title">5.2.1. Authentication</h4>
<p class="docText"><a name="iddle1097"></a><a name="iddle1591"></a>In &sect;<a class="docLink" href="ch02lev1sec4.html#ch02lev2sec10">2.4.4</a> <span class="docEmphasis">Authentication</span> we discussed how to use a secret key algorithm for authentication. A challenge is transmitted, and the other side has to encrypt the challenge with the shared key.</p>
<a name="f123equ01"></a>
<p class="docText">
<img border="0" alt="" width="400" height="90" src="123euq01.jpg" /></p>
<br />
<p class="docText">Imagine a world without secret key cryptography, but with cryptographic hash functions. So we can't use an algorithm like DES in the above example. This is not an entirely theoretical concern. Export controls may treat secret key algorithms more harshly than digest algorithms even if they are only used to compute MACs, especially when source code is provided. Could we use a message digest function in some way to accomplish the same thing? Bob and Alice will still need to share a secret. Message digest algorithms aren't reversible, so it can't work quite the same way. In the above example, in which secret key cryptography is used for authentication, Bob encrypts something, and Alice decrypts it to make sure Bob encrypted the quantity properly. A hash function will do pretty much the same thing. Alice still sends a challenge. Bob then concatenates the secret he shares with Alice with the challenge, takes a message digest of that, and transmits that message digest. Alice can't &quot;decrypt&quot; the result. However, she can do the same computation, and check that the result matches what Bob sends.</p>
<a name="f123equ02"></a>
<p class="docText">
<img border="0" alt="" width="350" height="91" src="123euq02.jpg" /></p>
<br />
<a name="ch05lev2sec2"></a>
<h4 id="title-IDAHK3WE" class="docSection2Title">5.2.2. Computing a MAC with a Hash</h4>
<p class="docText">In &sect;<a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">4.3</a> <span class="docEmphasis">Generating MACs</span> we described how to compute a MAC (message authentication code) with a secret key algorithm. Again, let's assume that for some reason no secret key algorithms are available. Can we still compute a MAC, using a hash function instead of something like DES?</p>
<p class="docText">The obvious thought is that MD(<span class="docEmphasis">m</span>) is a MAC for message <span class="docEmphasis">m</span>. But it isn't. Anyone can compute MD(<span class="docEmphasis">m</span>). The point of the MAC is to send something that only someone knowing the secret can compute (and verify). For instance, if Alice and Bob share a secret, then Alice can send <span class="docEmphasis">m</span>, plus <a name="iddle1426"></a>MAC, and since nobody except Alice and Bob can compute a MAC with their shared key, nobody but Alice or Bob would be able to send a message to Bob with an appropriate MAC. If we just simply used MD, then anyone can send any message <span class="docEmphasis">m</span>' together with MD(<span class="docEmphasis">m</span>'). So we do roughly the same trick for the MAC as we did for authentication. We concatenate a shared secret <span class="docEmphasis">K</span><sub>AB</sub> with the message <span class="docEmphasis">m</span>, and use MD(<span class="docEmphasis">K</span><sub>AB</sub>|<span class="docEmphasis">m</span>) as the MAC.</p>
<p class="docText">This scheme almost works, except for some idiosyncracies of most of the popular message digest algorithms, which would allow an attacker to be able to compute a MAC of a longer message beginning with <span class="docEmphasis">m</span>, given message <span class="docEmphasis">m</span> and the correct MAC for <span class="docEmphasis">m</span>.</p>
<p class="docText">Assume MD is one of MD4, MD5, or SHA-1. The way these algorithms work is that the message is padded to a multiple of 512 bits with a pad that includes the message length. The padded message is then digested from left to right in 512-bit chunks. In order to compute the message digest through chunk <span class="docEmphasis">n</span>, all that you need to know is the message digest through chunk <span class="docEmphasis">n</span>-1, plus the value of chunk <span class="docEmphasis">n</span> of the padded message.</p>
<p class="docText">Let's assume Carol would like to send a different message to Bob, and have it look like it came from Alice. Let's say that Carol doesn't care what's in the message. She only cares that the end of the message says <span class="docEmphRomanAlt">P.S. Give Carol a promotion and triple her salary</span>. Alice has transmitted some message <span class="docEmphasis">m</span>, and MD(<span class="docEmphasis">K</span><sub>AB</sub>|<span class="docEmphasis">m</span>). Carol can see both of those quantities. She concatenates the padding and then whatever she likes to the end of <span class="docEmphasis">m</span>, and initializes the message digest computation with MD(<span class="docEmphasis">K</span><sub>AB</sub>|<span class="docEmphasis">m</span>). She does not need to know the shared secret in order to compute the MAC.</p>
<p class="docText">How can we avoid this flaw? Lots of techniques have been proposed, all entirely effective as far as anyone can tell. But people came up with &quot;improvements&quot;, each one a little more complex than the one before, with the apparent winner being HMAC. Some proposals with no known weaknesses are:</p>
<ul><li><p class="docList">Put the secret at the end of the message instead of at the beginning. This will work. This method can be criticized for an extremely unlikely security flaw. The complaint is that if the MD algorithm were weak, and it was therefore possible to find two messages with the same digest, then those two messages would also have the same MAC.</p></li><li><p class="docList">Use only half the bits of the message digest as the MAC. For instance, take the low-order 64 bits of the MD5 digest. This gives an attacker no information with which to continue the message digest (well, the attacker has a 1 in 2<sup>64</sup> chance of guessing the rest of the message digest correctlyÂwe assume you're not going to worry about that risk). Having only 64 bits of MAC (rather than using all 128 bits of the MD) is not any less secure, since there is no way that an attacker can generate messages and test the resulting MAC. Without knowing the secret, there is no way for the attacker to calculate the MAC. The best that can be done is to generate a random 64-bit MAC for the message you'd like to send and hope that you'll be really really lucky.</p></li><li><p class="docList"><a name="iddle1336"></a><a name="iddle1417"></a><a name="iddle1427"></a><a name="iddle1502"></a><a name="iddle1549"></a><a name="iddle1738"></a>Concatenate the secret to both the front and the back of the message. That way you get the collision resistance of putting it in front and the protection from appending that comes from putting it in back.</p></li></ul>
<p class="docText">HMAC concatenates the secret to the front of the message, digests the combination, then concatenates the secret to the front of the digest, and digests the combination again. The actual construction is a little more complicated than this, and is described in section &sect;<a class="docLink" href="ch05lev1sec7.html#ch05lev1sec7">5.7</a> <span class="docEmphasis">HMAC</span>. HMAC has lower performance than the other alternatives because it does a second digest. But the second digest is only computed over the secret and a digest, so it does not add much cost to large messages. In the worst case, if the message concatenated with the key fit into a single (512-bit) block, HMAC would be four times as expensive as one of the other alternatives described above. However, if many small messages are to be HMAC'd with the same key, it is possible to reuse the part of the computation that digests the key, so that HMAC would only be twice as slow. With a large enough message, HMAC's performance is only negligibly worse.</p>
<p class="docText">We call any hash combining the secret key and the data a <span class="docEmphStrong">keyed hash</span>.</p>
<a name="ch05lev2sec3"></a>
<h4 id="title-IDAXP3WE" class="docSection2Title">5.2.3. Encryption with a Message Digest</h4>
<p class="docText">&quot;Encryption with a message digest algorithm is easy!&quot; you say. &quot;But let me see you do decryption!&quot; Message digest algorithms are not reversible, so the trick is to design a scheme in which both encryption and decryption run the message digest algorithm in the forward direction. The schemes we'll describe are reminiscent of the chaining methods for a secret key algorithm (see &sect;<a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">4.2</a> <span class="docEmphasis">Encrypting a Large Message</span>).</p>
<a name="ch05lev3sec1"></a>
<h5 id="title-IDAPQ3WE" class="docSection3Title">5.2.3.1. Generating a One-Time Pad</h5>
<p class="docText">Just as OFB (&sect;<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec3">4.2.3</a> <span class="docEmphasis">Output Feedback Mode (OFB)</span>) generates a pseudorandom bit stream which then encrypts a message by simply being <img src="U2295.GIF" border="0" />ed with the message, we can use a message digest algorithm to generate a pseudorandom bit stream.</p>
<p class="docText">Again, Alice and Bob need a shared secret, <span class="docEmphasis">K</span><sub>AB</sub>. Alice wants to send Bob a message. She computes MD(<span class="docEmphasis">K</span><sub>AB</sub>). That gives the first block of the bit stream, <span class="docEmphasis">b</span><sub>1</sub>. Then she computes MD(<span class="docEmphasis">K</span><sub>AB</sub>|<span class="docEmphasis">b</span><sub>1</sub>) and uses that as <span class="docEmphasis">b</span><sub>2</sub>, and in general <span class="docEmphasis">b<sub>i</sub></span> is MD(<span class="docEmphasis">K</span><sub>AB</sub>|<span class="docEmphasis">b</span><sub><span class="docEmphasis">i</span>-1</sub>).</p>
<p class="docText">Alice and Bob can do this in advance, before the message is known. Then when Alice wishes to send the message, she <img src="U2295.GIF" border="0" />s it with as much of the generated bit stream as necessary. Similarly, Bob decrypts the ciphertext by <img src="U2295.GIF" border="0" />ing it with the bit stream he has calculated.</p>
<p class="docText">It is not secure to use the same bit stream twice, so, as with OFB, Alice starts with an IV. The first block is then MD(<span class="docEmphasis">K</span><sub>AB</sub>|IV). She must transmit the IV to Bob. Alice can generate the bit stream in advance of encrypting the message, but Bob cannot generate the bit stream until he sees the IV.</p>
<a name="ch05lev3sec2"></a>
<h5 id="title-IDAQS3WE" class="docSection3Title">5.2.3.2. Mixing In the Plaintext</h5>
<p class="docText"><a name="iddle1419"></a><a name="iddle1420"></a><a name="iddle1781"></a><a name="iddle2110"></a>One-time pad schemes have the problem that if you are able to guess the plaintext, you can <img src="U2295.GIF" border="0" /> the guessed text with the ciphertext, and then <img src="U2295.GIF" border="0" /> any message you like. This is not too much of a problem. We just need to recognize that a one-time pad scheme gives privacy only, and integrity must be gained through a scheme such as using a MAC.</p>
<p class="docText">However, in a scheme similar to CFB (&sect;<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4">4.2.4</a> <span class="docEmphasis">Cipher Feedback Mode (CFB)</span>), we can mix the plaintext into the bit stream generation. For instance, break the message into MD-length chunks <span class="docEmphasis">p</span><sub>1</sub>, <span class="docEmphasis">p</span><sub>2</sub>,.... We'll call the ciphertext blocks <span class="docEmphasis">c</span><sub>1</sub>, <span class="docEmphasis">c</span><sub>2</sub>,.... And we'll need intermediate values <span class="docEmphasis">b</span><sub>1</sub>, <span class="docEmphasis">b</span><sub>2</sub>,... from which we'll compute each ciphertext block.</p>
<a name="f126equ01"></a>
<p class="docText">
<img border="0" alt="" width="300" height="107" src="126euq01.jpg" /></p>
<br />
<p class="docText">Decryption is straightforward. We leave it as <a class="docLink" href="ch05lev1sec8.html#ch05qa1qe18">Homework Problem 18</a>.</p>
<a name="ch05lev2sec4"></a>
<h4 id="title-IDASV3WE" class="docSection2Title">5.2.4. Using Secret Key for a Hash</h4>
<p class="docText">In case the previous sections make the secret key algorithms nervous about job security since they can be replaced by hash algorithms, we'll show that a hash algorithm can be replaced by a secret key algorithm. What we want to generate is a function with the properties of a hash algorithm. It should not require a secret. It should be publishable. It should be noninvertible.</p>
<a name="ch05lev3sec3"></a>
<h5 id="title-IDA3V3WE" class="docSection3Title">5.2.4.1. UNIX Password Hash</h5>
<p class="docText">UNIX uses a secret key algorithm to compute the hash of a password, which it then stores. It never has to reverse the hash to obtain a password. Instead, when the user types a password, UNIX uses the same algorithm to hash the typed quantity and compares the result with the stored quantity.</p>
<p class="docText">The hashing algorithm first converts the password into a secret key. This key is then used, with a DES-like algorithm, to encrypt the number <span class="docEmphRomanAlt">0</span>. The method of turning a text string into a secret key is simply to pack the 7-bit ASCII associated with each of the first 8 characters of the password into a 56-bit quantity into which DES parity is inserted. (UNIX passwords can be longer than 8 characters, but the remaining octets are ignored.)</p>
<p class="docText"><a name="iddle1633"></a><a name="iddle1961"></a>A 12-bit random number, known as <span class="docEmphasis">salt</span>, is stored with the hashed password. For an explanation of why salt is useful, see &sect;<a class="docLink" href="ch10lev1sec3.html#ch10lev1sec3">10.3</a> <span class="docEmphasis">Off-Line Password Guessing</span>. A modified DES is used instead of standard DES to prevent hardware accelerators designed for DES from being used to reverse the password hash. The salt is used to modify the DES data expansion algorithm. The value of the salt determines which bits are duplicated when expanding <span class="docEmphasis">R</span> from 32 to 48 bits (see &sect;<a class="docLink" href="ch03lev1sec3.html#ch03lev2sec5">3.3.5</a> <span class="docEmphasis">The Mangler Function</span>).</p>
<p class="docText">To summarize, each time a password is set, a 12-bit number is generated. The password is converted into a secret key. The 12-bit number is used to define a modified DES algorithm. The modified DES algorithm is used with the secret key as input to encrypt the constant <span class="docEmphRomanAlt">0</span>. The result is stored along with the 12-bit number as the user's hashed password.</p>
<a name="ch05lev3sec4"></a>
<h5 id="title-IDAEY3WE" class="docSection3Title">5.2.4.2. Hashing Large Messages</h5>
<p class="docText">The UNIX password hash is a method of doing a message digest of a very short message (maximum length is the length of the secret key). Here's a method of converting a secret key algorithm into a message digest algorithm for arbitrary messages (see <a class="docLink" href="#ch05fig01">Figure 5-1</a>).</p>
<a name="ch05fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 5-1. Message Digest Using Secret Key Cryptography</h5>
</center></p><p class="docText">
<img border="0" alt="" width="150" height="145" src="05fig01.jpg" /></p>
<br />
<p class="docText">A secret key algorithm has a key length, say <span class="docEmphasis">k</span> bits. It has a message block length, say <span class="docEmphasis">b</span> bits. In the case of DES, <span class="docEmphasis">k</span> = 56 and <span class="docEmphasis">b</span> = 64. In the case of IDEA, <span class="docEmphasis">k</span> = 128 and <span class="docEmphasis">b</span> = 64.</p>
<p class="docText">Divide the message into <span class="docEmphasis">k</span>-bit chunks <span class="docEmphasis">m</span><sub>1</sub>, <span class="docEmphasis">m</span><sub>2</sub>,.... Use the first block of the message as a key to encrypt a constant. The result is a <span class="docEmphasis">b</span>-bit quantity. Use the second <span class="docEmphasis">k</span>-bit chunk of the message to encrypt the <span class="docEmphasis">b</span>-bit quantity to get a new <span class="docEmphasis">b</span>-bit quantity. Keep doing this until you run out of <span class="docEmphasis">k</span>-bit blocks of the message. Use the final <span class="docEmphasis">b</span>-bit result as the message digest.</p>
<p class="docText">There's a serious problem with this, which is that the typical message block length <span class="docEmphasis">b</span> is 64 bits, which is too short to use as a message digest. To obtain two messages with the same message digest using this technique (and remembering the birthday problem), we'd only have to try about 2<sup>32</sup> messages before finding two that had the same digest. And furthermore, if we want to find a <a name="iddle1610"></a>message with a particular message digest, a technique similar to the one in &sect;<a class="docLink" href="ch04lev1sec4.html#ch04lev3sec4">4.4.1.2</a> <span class="docEmphasis">Encrypting Twice with Two Keys</span> could find a message with a particular 64-bit message digest in about 2<sup>33</sup> iterations.</p>
<p class="docText">A technique that works better (and in particular makes it a workfactor of 2<sup>63</sup> to find a message matching a given hash) is to <img src="U2295.GIF" border="0" /> the input to each round with the output as shown below:</p>
<a name="ch05fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 5-2. Improved Message Digest Using Secret Key Cryptography</h5>
</center></p><p class="docText">
<img border="0" alt="" width="175" height="237" src="05fig02.jpg" /></p>
<br />
<p class="docText">One possible technique for generating 128 bits of message digest is to generate two 64-bit quantities using techniques that are similar to compute but designed to produce different values. The first 64-bit quantity might be generated as we just describedÂthe message is broken into key-length chunks <span class="docEmphasis">b</span><sub>1</sub>,<span class="docEmphasis">b</span><sub>2</sub>,... and the chunks are used for encryption in that order. The second 64-bit quantity is generated by using the chunks in reverse order.</p>
<p class="docText">That technique has a flaw (see <a class="docLink" href="ch04lev1sec5.html#ch04qa1q4">Homework Problem 4</a>), and it's a little inconvenient to do two passes on the message. A better alternative is to process the message twice in the forward direction, and just start with two different constants.</p>
<a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>