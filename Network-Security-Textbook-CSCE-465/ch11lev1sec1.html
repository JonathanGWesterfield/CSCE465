<html><head><title>11.1. Login Only</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch11lev1sec1"></a>
<h3 id="title-IDA2OOSQ" class="docSection1Title">11.1. Login Only</h3>
<p class="docText">A lot of existing protocols were designed in an environment where eavesdropping was not a concern (rightly or wrongly), and bad guys were (rightly or wrongly) not expected to be very sophisticated. The authentication in such protocols generally consists of:</p>
<ul><li><p class="docList">Alice (the initiator) sends her name and password (in the clear) across the network to Bob.</p></li><li><p class="docList">Bob verifies the name and password, and then communication occurs, with no further attention to securityÂno encryption, no cryptographic integrity protection.</p></li></ul>
<p class="docText">A very common enhancement to such a protocol is to replace the transmission of the cleartext password with a cryptographic challenge/response. First we'll discuss protocols based on shared secrets, using either secret key cryptographic algorithms or message digest algorithms. Then we'll discuss similar protocols using public key technology.</p>
<a name="ch11lev2sec1"></a>
<h4 id="title-IDAUPOSQ" class="docSection2Title">11.1.1. Shared Secret</h4>
<p class="docText">The notation <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>) means that <span class="docEmphasis">R</span> is cryptographically transformed, somehow, with Alice and Bob's shared secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub>. This could be done by using <span class="docEmphasis">K</span><sub>Alice-Bob</sub> as a secret key in some algorithm such as DES or AES, and using <span class="docEmphasis">K</span><sub>Alice-Bob</sub> to encrypt <span class="docEmphasis">R</span>. Or it could be done by hashing <span class="docEmphasis">R</span> and <span class="docEmphasis">K</span><sub>Alice-Bob</sub>, for instance by concatenating <span class="docEmphasis">R</span> and <span class="docEmphasis">K</span><sub>Alice-Bob</sub> and computing a message digest on the result. When we explicitly mean encryption with <span class="docEmphasis">K</span><sub>Alice-Bob</sub> we'll write <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>}. When we explicitly mean a hash, we'll write h(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>) or hash(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>).</p>
<p class="docText">Consider <a class="docLink" href="#ch11fig01">Protocol 11-1</a>. An eavesdropper will see both <span class="docEmphasis">R</span> and <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>). It is essential that seeing the pair does not enable the eavesdropper to derive <span class="docEmphasis">K</span><sub>Alice-Bob</sub>.</p>
<p class="docText"></p><a name="ch11fig01"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-1. Bob authenticates Alice based on a shared secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub></h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="110" src="11fig01.jpg" /></p>
<br />
<p class="docText">This protocol is a big improvement over passwords in the clear. An eavesdropper cannot impersonate Alice based on overhearing the exchange, since next time there will be a different challenge. However, there are some weaknesses to this protocol:</p>
<ul><li><p class="docList">Authentication is not mutual. Bob authenticates Alice, but Alice does not authenticate Bob. If Trudy can receive packets transmitted to Bob's network address, and respond with Bob's network address (or through other means convince Alice that Trudy's address is Bob's), then Alice will be fooled into assuming Trudy is Bob. Trudy doesn't need to know Alice's secret in order to impersonate BobÂshe just needs to send any old number <span class="docEmphasis">R</span> to Alice and ignore Alice's response.</p></li><li><p class="docList">If this is the entire protocol (i.e., the remainder of the conversation is transmitted without cryptographic protection), then Trudy can hijack the conversation after the initial exchange, assuming she can generate packets with Alice's source address. It's also useful to Trudy, but not absolutely essential, that she be able to receive packets transmitted to Alice's network layer address. (See <a class="docLink" href="ch11lev1sec9.html#ch11qa1q1">Homework Problem 1</a>.)</p></li><li><p class="docList">An eavesdropper could mount an off-line password-guessing attack (assuming <span class="docEmphasis">K</span><sub>Alice-Bob</sub> is derived from a password), knowing <span class="docEmphasis">R</span> and <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>). (Recall that an off-line password-guessing attack is one in which an intruder captures information against which passwords can be tested in private, so in this context it means guessing a password, turning that password into a key <span class="docEmphasis">K</span>, and then seeing whether <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span>,<span class="docEmphasis">R</span>) equals <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>).)</p></li><li><p class="docList">Someone who reads the database at Bob can later impersonate Alice. In many cases it is difficult to protect the database at Bob. There might be many servers where Alice uses the same password, and although the administrators of most of the servers might be very conscientious about security (not letting unauthorized people get near their machines, and enforcing unguessable passwords), it only takes one unprotected server for an intruder to read the relevant information. Furthermore, protecting the database implies protecting all the backup media as well, by either preventing access to it (locking it in a safe) or encrypting the contents and somehow protecting the key with which it was encrypted.</p></li></ul>
<p class="docText">Despite these drawbacks, if there are limited resources available for adding security, replacing the cleartext password transmission is the single most important security enhancement that can be done.</p>
<p class="docText">A minor variant on <a class="docLink" href="#ch11fig01">Protocol 11-1</a> is the following:</p>
<p class="docText">In this protocol Bob chooses a random challenge <span class="docEmphasis">R</span>, encrypts it, and transmits the result. Alice then decrypts the received quantity, using the secret key <span class="docEmphasis">K</span><sub>Alice-Bob</sub> to get <span class="docEmphasis">R</span>, and sends <span class="docEmphasis">R</span> to Bob. This protocol has only minor security differences from <a class="docLink" href="#ch11fig01">Protocol 11-1</a>:</p>
<ul><li><p class="docList">This protocol requires reversible cryptography, for example a secret key cryptographic algorithm. <a class="docLink" href="#ch11fig01">Protocol 11-1</a> can be done using a hash function. For example, <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>) could be the message digest of <span class="docEmphasis">K</span><sub>Alice-Bob</sub> concatenated with <span class="docEmphasis">R</span>. But in <a class="docLink" href="#ch11fig02">Protocol 11-2</a>, Alice has to be able to reverse what Bob has done to <span class="docEmphasis">R</span> in order to retrieve <span class="docEmphasis">R</span>. Sometimes there is a performance advantage to being able to use one of the message digest functions rather than having to use, say, DES. Sometimes there are export issues involved in having code for encryption available, even if it's only used for authentication, whereas using a message digest function would be less likely to create export problems.</p><a name="ch11fig02"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-2. Bob authenticates Alice based on a shared secret key <span class="docEmphasis">K</span><sub>Alice-Bob</sub></h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="110" src="11fig02.jpg" /></p>
</li><li><p class="docList">Suppose <span class="docEmphasis">K</span><sub>Alice-Bob</sub> is derived from a password and therefore vulnerable to a dictionary attack. If <span class="docEmphasis">R</span> is a recognizable quantity, for instance a 32-bit random number padded with 32 zero bits to fill out an encryption block, then Trudy can, without eavesdropping, mount a dictionary attack by merely sending the message <span class="docEmphRomanAlt">I am Alice</span> and obtaining <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>}. If Trudy is eavesdropping, however, and sees both <span class="docEmphasis">R</span> and <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>}, she can mount a dictionary attack with either protocol. It is often the case that eavesdropping is more difficult than merely sending a message claiming to be Alice. Kerberos V4 (see <a class="docLink" href="ch13.html#ch13">Chapter 13</a> <span class="docEmphasis">Kerberos V4</span>) is an example of a protocol that has this security weakness.</p></li><li><p class="docList">If <span class="docEmphasis">R</span> is a recognizable quantity with limited lifetime, such as a random number concatenated with a timestamp, Alice authenticates Bob because only someone knowing <span class="docEmphasis">K</span><sub>Alice-Bob</sub> could generate <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>}. To accomplish <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_133">mutual authentication</a></span>, <span class="docEmphasis">R</span> must be limited lifetime to foil the replaying of an old <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">R</span>}.</p></li></ul>
<p class="docText">Another variant on <a class="docLink" href="#ch11fig01">Protocol 11-1</a> is to shorten the handshake to a single message by having Alice use a timestamp instead of an <span class="docEmphasis">R</span> that Bob supplies:</p>
<a name="ch11fig03"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-3. Bob authenticates Alice based on synchronized clocks and a shared secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub></h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="39" src="11fig03.jpg" /></p>
<br />
<p class="docText">This modification requires that Bob and Alice have reasonably synchronized clocks. Alice encrypts the current time. Bob decrypts the result and makes sure the result is acceptable (i.e., within an acceptable clock skew). The implications of this modification are:</p>
<ul><li><p class="docList">This modification can be added very easily to a protocol designed for sending cleartext passwords, since it does not add any additional messagesÂit merely replaces the cleartext password field with the encrypted timestamp in the first message transmitted by Alice to Bob.</p></li><li><p class="docList">The protocol is now more efficient. It goes beyond saving two messages. It means that a server, Bob, does not need to keep any volatile state (such as <span class="docEmphasis">R</span> in <a class="docLink" href="#ch11fig01">Protocol 11-1</a>) regarding Alice (but see next bullet). This protocol can be added to a request/response protocol (such as <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_190">RPC</a></span>) by having Alice merely add the encrypted timestamp into her request. Bob can authenticate the request, generate a reply, and forget the whole thing ever happened.</p></li><li><p class="docList">Someone eavesdropping can use Alice's transmitted <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">timestamp</span>} to impersonate Alice, if done within the acceptable clock skew. This threat can be foiled if Bob remembers all timestamps sent by Alice until they &quot;expire&quot; (i.e., they are old enough that the clock skew check would consider them invalid).</p></li><li><p class="docList">Another potential security pitfall occurs if there are multiple servers for which Alice uses the same secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub>. Then an eavesdropper who acts quickly can use the encrypted timestamp field Alice transmitted, and (if still within the acceptable time skew) impersonate Alice to a different server. This can be foiled by concatenating the server name in with the timestamp. Instead of sending <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{<span class="docEmphasis">timestamp</span>}, Alice sends <span class="docEmphasis">K</span><sub>Alice-Bob</sub>{&quot;Bob&quot; | <span class="docEmphasis">timestamp</span>}. That quantity would not be accepted by a different server.</p></li><li><p class="docList">If our bad guy Trudy can convince Bob to set his clock back, she can reuse encrypted timestamps she had overheard in what is now Bob's future. In practice there are systems that are vulnerable to an intruder resetting the clock. Although it might be obvious that a password file would be something that needed to be protected, if the security protocols are not completely understood, it might not be obvious that clock-setting could be a serious security vulnerability.</p></li><li><p class="docList">If security relies on time, then setting the time will be an operation that requires a security handshake. A handshake based on time will fail if the clocks are far apart. If there's a system with an incorrect time, then it will be impossible to log into the system in order to manage it (in order to correct its clock). A plausible solution to this is to have a different authentication handshake based on challenge/response (i.e., not dependent on time) for managing clock setting.</p></li></ul>
<p class="docText">In <a class="docLink" href="#ch11fig01">Protocol 11-1</a>, computing <span class="docEmphasis">f</span>(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>). may be done with a secret key encryption scheme using <span class="docEmphasis">K</span><sub>Alice-Bob</sub> as a key, or by concatenating <span class="docEmphasis">K</span><sub>Alice-Bob</sub> with <span class="docEmphasis">R</span> and doing a hash. When we're using timestamps the same is true (a message digest works), except for a minor complication. How does Bob verify that hash(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>,<span class="docEmphasis">R</span>) is reasonable? Suppose the timestamp is in units of minutes, and the believable clock skew is 10 minutes. Then Bob would have to compute hash(<span class="docEmphasis">K</span><sub>Alice-Bob</sub>, <span class="docEmphasis">timestamp</span>) for each of the twenty possible valid timestamps to verify the value Alice sends (though he could stop as soon as he found a match). With a reversible encryption function, all he had to do was decrypt the quantity received and see if the result was acceptable. While checking twenty values might have acceptable performance, this approach would become intolerably inefficient if the clock granularity allows a lot more legal values within the clock skew. For instance, the timestamp might be in units of microseconds. There are 600 million valid timestamps within a five-minute clock skew. This would be unacceptably inefficient for Bob to verify. The solution (assuming you wanted to use a microsecond clock and a hash function rather than a reversible encryption scheme) is to have Alice transmit the actual timestamp unencrypted, in addition to transmitting the hashed value. So the protocol would be:</p>
<a name="ch11fig04"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-4. Bob authenticates Alice based on hashing a high-resolution time and a shared secret <span class="docEmphasis">K</span><sub>Alice-Bob</sub></h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="39" src="11fig04.jpg" /></p>
<br />
<a name="ch11lev2sec2"></a>
<h4 id="title-IDAF5OSQ" class="docSection2Title">11.1.2. One-Way Public Key</h4>
<p class="docText">With protocols in the previous section, which are based on shared secrets, Trudy can impersonate Alice if she can read Bob's database. If the protocols are based on public key technology instead, this can be avoided, as in <a class="docLink" href="#ch11fig05">Protocol 11-5</a>.</p>
<a name="ch11fig05"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-5. Bob authenticates Alice based on her public key signature</h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="110" src="11fig05.jpg" /></p>
<br />
<p class="docText">In this case [<span class="docEmphasis">R</span>]<sub>Alice</sub> means that Alice signs <span class="docEmphasis">R</span> (i.e. transforms <span class="docEmphasis">R</span> using her private key). Bob will verify Alice's signature [<span class="docEmphasis">R</span>]<sub>Alice</sub> using Alice's public key, and accept the login if the result matches <span class="docEmphasis">R</span>. This is very similar to <a class="docLink" href="#ch11fig01">Protocol 11-1</a>. The advantage of this protocol is that the database at Bob is no longer security-sensitive to an attacker reading it. Bob's database must be protected from unauthorized modification, but not from unauthorized disclosure.</p>
<p class="docText"><a name="iddle1815"></a>And as before, the same minor variant works:</p>
<p class="docText">In this variant, Bob chooses <span class="docEmphasis">R</span>, encrypts it using Alice's public key, and Alice proves she knows her private key by decrypting the received quantity to retrieve <span class="docEmphasis">R</span>. A problem with this variant is that some public key schemes (such as DSS) can only do signatures, not reversible encryption. So in those cases this variant cannot be used.</p>
<p class="docText">In both <a class="docLink" href="#ch11fig05">Protocol 11-5</a> and <a class="docLink" href="#ch11fig06">Protocol 11-6</a> there is a potential serious problem. In <a class="docLink" href="#ch11fig05">Protocol 11-5</a> you can trick someone into signing something. That means, if you have a quantity on which you'd like to forge Alice's signature, you might be able to impersonate Bob's network address, wait for Alice to try to log in, and then give her the quantity as the challenge. She'll sign it, and now you know her signature on that quantity. <a class="docLink" href="#ch11fig06">Protocol 11-6</a> has Alice decrypting something. So, if there's some encrypted message someone sent to Alice and you're wondering what's in it, you might again impersonate Bob's address, wait for Alice to log in, and then have Alice decrypt it for you.</p>
<a name="ch11fig06"></a><p><center>
<h5 class="docFigureTitle">Protocol 11-6. Bob authenticates Alice if she can decrypt a message encrypted with her public key</h5>
</center></p><p class="docText">
<img border="0" alt="" width="380" height="110" src="11fig06.jpg" /></p>
<br />
<p class="docText">How can we avoid getting in trouble? The general rule is that you should not use the same key for two different purposes unless the designs for all uses of the key are coordinated so that an attacker can't use one protocol to help break another. An example method of coordination is to ensure that <span class="docEmphasis">R</span> has some structure. For instance, if you sign different types of things (say an <span class="docEmphasis">R</span> in a challenge/response protocol versus an electronic mail message), each type of thing should have a structure so that it cannot be mistaken for another type of thing. For example, there might be a type field concatenated to the front of the quantity before signing, with different values for <span class="docEmphasis">authentication challenge</span> and <span class="docEmphasis">mail message</span>. Part of the purpose of the PKCS standards (see &sect;<a class="docLink" href="ch06lev1sec3.html#ch06lev2sec9">6.3.6</a> <span class="docEmphasis">Public-Key Cryptography Standard (PKCS)</span>) is to impose enough structure to prevent this sort of problem when the same RSA key is used for different purposes.</p>
<p class="docText"><a name="iddle1067"></a><a name="iddle1087"></a><a name="iddle1672"></a><a name="iddle1895"></a>Note the chilling implicationÂyou can design several schemes where each is independently secure, but when you use more than one, you can have a problem. Perhaps even more chilling, you could design a new protocol whose deployment would compromise the security of existing schemes (if the new protocol used the same keys).</p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>