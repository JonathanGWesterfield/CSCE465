<html><head><title>6.3. RSA</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch06lev1sec3"></a>
<h3 id="title-IDAQR3DR" class="docSection1Title">6.3. RSA</h3>
<p class="docText">RSA is named after its inventors, Rivest, Shamir, and Adleman. It is a public key cryptographic algorithm that does encryption as well as decryption. The key length is variable. Anyone using RSA can choose a long key for enhanced security, or a short key for efficiency. The most commonly used key length for RSA is 512 bits.</p>
<p class="docText">The block size in RSA (the chunk of data to be encrypted) is also variable. The plaintext block must be smaller than the key length. The ciphertext block will be the length of the key. RSA is much slower to compute than popular secret key algorithms like DES and IDEA. As a result, RSA does not tend to get used for encrypting long messages. Mostly it is used to encrypt a secret key, and then secret key cryptography is used to actually encrypt the message.</p>
<a name="ch06lev2sec4"></a>
<h4 id="title-IDA3R3DR" class="docSection2Title">6.3.1. RSA Algorithm</h4>
<p class="docText">First, you need to generate a public key and a corresponding private key. Choose two large primes <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> (probably around 256 bits each). Multiply them together, and call the result <span class="docEmphasis">n</span>. The factors <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> will remain secret. (You won't tell anybody, and it's practically impossible to factor numbers that large.)</p>
<p class="docText">To generate your public key, choose a number <span class="docEmphasis">e</span> that is relatively prime to &#966;(<span class="docEmphasis">n</span>). Since you know <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>, you know &#966;(<span class="docEmphasis">n</span>)Âit's (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1). Your public key is &lt;<span class="docEmphasis">e</span>,<span class="docEmphasis">n</span>&gt;.</p>
<p class="docText">To generate your private key, find the number <span class="docEmphasis">d</span> that is the multiplicative inverse of <span class="docEmphasis">e</span> mod &#966;(<span class="docEmphasis">n</span>). &lt;<span class="docEmphasis">d</span>,<span class="docEmphasis">n</span>&gt; is your private key.</p>
<p class="docText">To encrypt a message <span class="docEmphasis">m</span> (&lt; <span class="docEmphasis">n</span>), someone using your public key should compute ciphertext <span class="docEmphasis">c</span> = <span class="docEmphasis">m<sup>e</sup></span> mod <span class="docEmphasis">n</span>. Only you will be able to decrypt <span class="docEmphasis">c</span>, using your private key to compute <span class="docEmphasis">m</span> = <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">n</span>. Also, only you can sign a message <span class="docEmphasis">m</span> (&lt; <span class="docEmphasis">n</span>) with signature <span class="docEmphasis">s</span> = <span class="docEmphasis">m<sup>d</sup></span> mod <span class="docEmphasis">n</span> based on your private key. Anyone can verify your signature by checking that <span class="docEmphasis">m</span> = <span class="docEmphasis">s<sup>e</sup></span> mod <span class="docEmphasis">n</span>.</p>
<p class="docText">That's all there is to RSA. Now there are some questions we should ask.</p>
<ul><li><p class="docList">Why does it work? (E.g., will decrypting an encrypted message get the original message back?)</p></li><li><p class="docList"><a name="iddle1366"></a><a name="iddle1394"></a><a name="iddle1490"></a>Why is it secure? (E.g., given <span class="docEmphasis">e</span> and <span class="docEmphasis">n</span>, why can't someone easily compute <span class="docEmphasis">d</span>?)</p></li><li><p class="docList">Are the operations encryption, decryption, signing, and verifying signatures all sufficiently efficient to be practical?</p></li><li><p class="docList">How do we find big primes?</p></li></ul>
<a name="ch06lev2sec5"></a>
<h4 id="title-IDAQW3DR" class="docSection2Title">6.3.2. Why Does RSA Work?</h4>
<p class="docText">RSA does arithmetic mod <span class="docEmphasis">n</span>, where <span class="docEmphasis">n</span> = <span class="docEmphasis">pq</span>. We know that &#966;(<span class="docEmphasis">n</span>) = (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1). We've chosen <span class="docEmphasis">d</span> and <span class="docEmphasis">e</span> such that <span class="docEmphasis">de</span> = 1 mod &#966;(<span class="docEmphasis">n</span>). Therefore, for any <span class="docEmphasis">x</span>, <span class="docEmphasis">x<sup>de</sup></span> = <span class="docEmphasis">x</span> mod <span class="docEmphasis">n</span>. An RSA encryption consists of taking <span class="docEmphasis">x</span> and raising it to <span class="docEmphasis">e</span>. If we take the result and raise it to the <span class="docEmphasis">d</span> (i.e., perform RSA decryption), we'll get (<span class="docEmphasis">x<sup>e</sup></span>)<sup><span class="docEmphasis">d</span></sup>, which equals <span class="docEmphasis">x<sup>ed</sup></span>, which is the same as <span class="docEmphasis">x</span>. So we see that decryption reverses encryption.</p>
<p class="docText">In the case of signature generation, <span class="docEmphasis">x</span> is first raised to the <span class="docEmphasis">d</span> power to get the signature and then the signature is raised to the <span class="docEmphasis">e</span> power for verification; the result, <span class="docEmphasis">x<sup>de</sup></span>, will equal <span class="docEmphasis">x</span>.</p>
<a name="ch06lev2sec6"></a>
<h4 id="title-IDAAZ3DR" class="docSection2Title">6.3.3. Why Is RSA Secure?</h4>
<p class="docText">We don't know for sure that RSA is secure. We can only depend on the Fundamental Tenet of CryptographyÂlots of smart people have been trying to figure out how to break RSA, and they haven't come up with anything yet.</p>
<p class="docText">The real premise behind RSA's security is the assumption that factoring a big number is hard. The best known factoring methods are really slow. To factor a 512-bit number with the best known techniques would take about thirty thousand MIPS-years [<a class="docLink" href="biblio01.html#biblio01_144">ROBS95</a>]. We suspect that a better technique is to wait a few years and <span class="docEmphasis">then</span> use the best known technique.</p>
<p class="docText">If you can factor quickly, you can break RSA. Suppose you are given Alice's public key &lt;<span class="docEmphasis">e</span>,<span class="docEmphasis">n</span>&gt;. If you could find <span class="docEmphasis">e</span>'s exponentiative inverse mod <span class="docEmphasis">n</span>, then you'd have figured out Alice's private key &lt;<span class="docEmphasis">d</span>,<span class="docEmphasis">n</span>&gt;. How can you find <span class="docEmphasis">e</span>'s exponentiative inverse? Alice did it by knowing the factors of <span class="docEmphasis">n</span>, allowing her to compute &#966;(<span class="docEmphasis">n</span>). She found the number that was <span class="docEmphasis">e</span>'s multiplicative inverse mod &#966;(<span class="docEmphasis">n</span>). She didn't have to factor <span class="docEmphasis">n</span>Âshe started with primes <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> and multiplied them together to get <span class="docEmphasis">n</span>. You can do what Alice did if you can factor <span class="docEmphasis">n</span> to get <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>.</p>
<p class="docText">We do not know that factoring <span class="docEmphasis">n</span> is the only way of breaking RSA. We know that breaking RSA (for example, having an efficient means of finding <span class="docEmphasis">d</span>, given <span class="docEmphasis">e</span> and <span class="docEmphasis">n</span>) is no more difficult than factoring [<a class="docLink" href="biblio01.html#biblio01_030">CORM91</a>], but there might be some other means of breaking RSA.</p>
<p class="docText">Note that it's possible to misuse RSA. For instance, let's say I'm going to send Alice a message divulging the name of the Cabinet member who allegedly once hired a kid to mow his/her lawn, and didn't fill out all the proper IRS forms. Bob knows that's what I'm going to transmit. I'll <a name="iddle1356"></a>encrypt the text string which is the guilty person's name using Alice's public key. Bob can't possibly decrypt it, because we believe RSA is secure. So what can Bob learn from eavesdropping on the encrypted data?</p>
<p class="docText">Well, Bob can't decrypt, but he can encrypt. He knows I'm sending one of fourteen possible messages. He takes each Cabinet member's name and encrypts it with Alice's public key. One of them will match my messageÂunless I use RSA properly. In &sect;<a class="docLink" href="#ch06lev2sec9">6.3.6</a> <span class="docEmphasis">Public-Key Cryptography Standard (PKCS)</span> we'll discuss how to use RSA properly. For now, a simple thing I can do to prevent Bob from guessing my message, encrypting with Alice's public key, and checking the result, is to concatenate the name with a large random number, say 64 bits long. Then instead of fourteen possible messages for Bob to check, there are 14x2<sup>64</sup>, and checking that many messages is computationally infeasible.</p>
<a name="ch06lev2sec7"></a>
<h4 id="title-IDAJ23DR" class="docSection2Title">6.3.4. How Efficient Are the RSA Operations?</h4>
<p class="docText">The operations that need to be routinely performed with RSA are encryption, decryption, generating a signature, and verifying a signature. These need to be very efficient, because they will be used a lot. Finding an RSA key (which means picking appropriate <span class="docEmphasis">n</span>, <span class="docEmphasis">d</span>, and <span class="docEmphasis">e</span>) also needs to be reasonably efficient, but it isn't as critical as the other operations, since it is done less frequently. As it turns out, finding an RSA key is substantially more computationally intensive than using one.</p>
<a name="ch06lev3sec1"></a>
<h5 id="title-IDA123DR" class="docSection3Title">6.3.4.1. Exponentiating with Big Numbers</h5>
<p class="docText">Encryption, decryption, signing, and verifying signatures all involve taking a large number, raising it to a large power, and finding the remainder mod a large number. For the sizes the numbers have to be for RSA to be secure, these operations would be prohibitively expensive if done in the most straightforward way. The following will illustrate some tricks for doing the calculation faster.</p>
<p class="docText">Suppose you want to compute 123<sup>54</sup> mod 678. The straightforward thing to do (assuming your computer has a multiple-precision arithmetic package) is to multiply 123 by itself 54 times, getting a really big product (about 100 digits), and then to divide by 678 to get the remainder. A computer could do this with ease, but for RSA to be secure, the numbers must be on the order of 150 digits. Raising a 150-digit number to a 150-digit power by this method would exhaust the capacity of all existing computers for more than the expected life of the universe, and thus would not be cost-effective.</p>
<p class="docText">Luckily, you can do better than that.</p>
<p class="docText">If you do the modular reduction after each multiply, it keeps the number from getting really ridiculous. To illustrate:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="500"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>2</sup> = 123 &#183; 123 = 15129 = 213 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>3</sup> = 123 &#183; 213 = 26199 = 435 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>4</sup> = 123 &#183; 435 = 53505 = 621 mod 678</p></td></tr></table></p><br />
<p class="docText">This reduces the problem to 54 small multiplies and 54 small divides, but it would still be unacceptable for exponents of the size used with RSA.</p>
<p class="docText">However, there is a much more efficient method. To raise a number <span class="docEmphasis">x</span> to an exponent which is a power of 2, say 32, you could multiply by <span class="docEmphasis">x</span> 32 times, which is reasonable if you have nothing better to do with your time. A much better scheme is to first square <span class="docEmphasis">x</span>, then square the result, and so on. Then you'll be done after 5 squarings (5 multiplies and 5 divides):</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>2</sup> = 123 &#183; 123 = 15129 = 213 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>4</sup> = 213 &#183; 213 = 45369 = 621 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>8</sup> = 621 &#183; 621 = 385641 = 537 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>16</sup> = 537 &#183; 537 = 288369 = 219 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>32</sup> = 219 &#183; 219 = 47961 = 501 mod 678</p></td></tr></table></p><br />
<p class="docText">What if you're not lucky enough to be raising something to a power of 2?</p>
<p class="docText">First note that if you know what 123<sup><span class="docEmphasis">x</span></sup> is, then it's easy to compute 123<sup>2<span class="docEmphasis">x</span></sup>Âyou get that by squaring 123<sup><span class="docEmphasis">x</span></sup>. It's also easy to compute 123<sup>2<span class="docEmphasis">x</span>+1</sup>Âyou get that by multiplying 123<sup>2<span class="docEmphasis">x</span></sup> by 123. Now you use this observation to compute 123<sup>54</sup>.</p>
<p class="docText">Well, 54 is 110110<sub>2</sub> (represented in binary). You'll compute 123 raised to a sequence of powersÂ1<sub>2</sub>, 11<sub>2</sub>, 110<sub>2</sub>, 1101<sub>2</sub>, 11011<sub>2</sub>, 110110<sub>2</sub>. Each successive power concatenates one more bit of the desired exponent. And each successive power is either twice the preceding power or one more than twice the preceding power:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>2</sup> = 123&#183;123 = 15129 = 213 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>3</sup> = 123<sup>2</sup>&#183;123 = 213&#183;123 = 26199 = 435 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>6</sup> = (123<sup>3</sup>)<sup>2</sup> = 435<sup>2</sup> = 189225 = 63 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>12</sup> = (123<sup>6</sup>)<sup>2</sup> = 63<sup>2</sup> = 3969 = 579 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>13</sup> = 123<sup>12</sup>&#183;123 = 579&#183;123 = 71217 = 27 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>26</sup> = (123<sup>13</sup>)<sup>2</sup> = 27 <sup>2</sup> = 729 = 51 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>27</sup> = 123<sup>26</sup>&#183;123 = 51&#183;123 = 6273 = 171 mod 678</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">123<sup>54</sup> = (123<sup>27</sup>)<sup>2</sup> = 171<sup>2</sup> = 29241 = 87 mod 678</p></td></tr></table></p><br />
<p class="docText"><a name="iddle1841"></a>In other words, raising 123 to the 54 can be done by repeated squaring, together with sporadic multiplication by 123 for the bits that are 1:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="4"><col width="75"></col><col width="10"></col><col width="200"></col><col width="100"></col></colgroup><thead></thead><tr><td class="docTableCell" align="right" valign="top"><p class="docText">54</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">=</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(((((1)2+1)2)2+1)2+1)2,</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">so</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">123<sup>54</sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">=</p></td><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText">(((((123)<sup>2</sup>123)<sup>2</sup>)<sup>2</sup>123)<sup>2</sup>123)<sup>2</sup> = 87 mod 678.</p></td></tr></table></p><br />
<p class="docText">The idea is that squaring is the same as multiplying the exponent by two, which in turn is the same as shifting the exponent left by one bit. And multiplying by the base is the same as adding one to the exponent.</p>
<p class="docText">In general, to perform exponentiation of a base to an exponent, you start with your value set to 1. As you read the exponent in binary bit by bit from high-order bit to low-order bit, you square your value, and if the bit is a 1 you then multiply by the base. You perform modular reduction after each operation to keep the intermediate results small.</p>
<p class="docText">By this method you've reduced the computation of 123<sup>54</sup> to 8 multiplies and 8 divides. More importantly, the number of multiplies and divides rises linearly with the length of the exponent in bits rather than with the value of the exponent itself.</p>
<p class="docText">RSA operations using this technique are sufficiently efficient to be practical.</p>
<a name="ch06lev3sec2"></a>
<h5 id="title-IDA0S5B4" class="docSection3Title">6.3.4.2. Generating RSA Keys</h5>
<p class="docText">Most uses of public key cryptography do not require frequent generation of RSA keys. If generation of an RSA key is only done, for instance, when an employee is hired, then it need not be as efficient as the operations that use the keys. However, it still has to be reasonably efficient.</p>
<a name="ch06lev4sec1"></a>
<h5 id="title-IDAFT5B4" class="docSection4Title">6.3.4.2.1. Finding Big Primes <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span></h5>
<p class="docText">There is an infinite supply of primes. However, they thin out as numbers get bigger and bigger. The probability of a randomly chosen number <span class="docEmphasis">n</span> being prime is approximately 1/ln <span class="docEmphasis">n</span>. The natural <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_122">logarithm</a></span> function, ln, rises linearly with the size of the number represented in digits or bits. For a ten-digit number, there is about one chance in 23 of it being prime. For a hundred-digit number (a size that would be useful for RSA), there is about one chance in 230.</p>
<p class="docText">So, we'll choose a random number, and test if it is prime. On the average, we'll only have to try 230 of them before we find one that is a prime. So, how do we test if a number <span class="docEmphasis">n</span> is prime?</p>
<p class="docText">One naive method is to divide <span class="docEmphasis">n</span> by all numbers <img src="U2264.GIF" border="0" />
<img border="0" alt="" width="18" height="15" src="156equ01.jpg" />


 and see if the division comes out even. The problem is, that would take several universe lifetimes for each candidate prime. We said finding <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> didn't need to be as easy as generating or verifying a signature, but forever is too long.</p>
<p class="docText"><a name="iddle1145"></a><a name="iddle1350"></a><a name="iddle1656"></a><a name="iddle1844"></a>It turns out there is no known practical way for absolutely determining that a number of this size is prime. Fortunately, there is a test for determining that a number is probably prime, and the more time we spend testing a number the more assured we can be that the number is prime.</p>
<p class="docText">We'll use <span class="docEmphStrong">Euler's Theorem</span>: For any <span class="docEmphasis">a</span> relatively prime to <span class="docEmphasis">n</span>, <span class="docEmphasis">a</span><sup>&#966;(<span class="docEmphasis">n</span>)</sup> = 1 mod <span class="docEmphasis">n</span>. (See &sect;<a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">7.8</a> <span class="docEmphasis">Euler's Theorem</span> for a proof.)</p>
<p class="docText">In the case where <span class="docEmphasis">n</span> is a prime, &#966;(<span class="docEmphasis">n</span>) = <span class="docEmphasis">n</span> - 1. The theorem then takes on a simpler form and in fact another name:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="center" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphStrong">Fermat's Theorem</span>: If <span class="docEmphasis">p</span> is prime and 0 &lt; <span class="docEmphasis">a</span> &lt; <span class="docEmphasis">p</span>, <span class="docEmphasis">a</span><sup><span class="docEmphasis">p</span>-1</sup> = 1 mod <span class="docEmphasis">p</span>.</p></td></tr></table></p><br />
<p class="docText">You might ask the question (somebody did)Âdoes <span class="docEmphasis">a<sup>n</sup></span>-1 = 1 mod <span class="docEmphasis">n</span> hold even when <span class="docEmphasis">n</span> is not prime? The answer isÂusually not! A primality test, then, for a number <span class="docEmphasis">n</span> is to pick a number <span class="docEmphasis">a</span> &lt; <span class="docEmphasis">n</span>, compute <span class="docEmphasis">a<sup>n</sup></span>-1 mod <span class="docEmphasis">n</span>, and see if the answer is 1. If it is not 1, <span class="docEmphasis">n</span> is certainly not prime. If it is 1, <span class="docEmphasis">n</span> may or may not be prime. If <span class="docEmphasis">n</span> is a randomly generated number of about a hundred digits, the probability that <span class="docEmphasis">n</span> isn't prime but <span class="docEmphasis">a<sup>n</sup></span>-1 mod <span class="docEmphasis">n</span> = 1 is about 1 in 10<sup>13</sup> [<a class="docLink" href="biblio01.html#biblio01_134">POME81</a>, <a class="docLink" href="biblio01.html#biblio01_030">CORM91</a>]. Most people would decide they could live with that risk of falsely assuming <span class="docEmphasis">n</span> was prime when it wasn't. The cost of such a mistake would be that (1) RSA might failÂthey could not decrypt a message addressed to them, or (2) someone might be able to compute their private exponent with less effort than anticipated. There aren't many applications where a risk of failure of 1 in 10<sup>13</sup> is a problem.</p>
<p class="docText">But if the risk of 1 in 10<sup>13</sup> is unacceptable, the primality test can be made more reliable. A likely thing to try is using multiple values of <span class="docEmphasis">a</span>. If for any given <span class="docEmphasis">n</span>, each value of <span class="docEmphasis">a</span> had a probability of 1 in 10<sup>13</sup> of falsely reporting primality, a few tests would assure even the most paranoid person. Unfortunately, there exist numbers <span class="docEmphasis">n</span> which are not prime, but which satisfy <span class="docEmphasis">a<sup>n</sup></span>-1 = 1 mod <span class="docEmphasis">n</span> for all values of <span class="docEmphasis">a</span>. They are called <span class="docEmphStrong">Carmichael numbers</span>. Carmichael numbers are sufficiently rare that the chance of selecting one at random is nothing to lose sleep over. Nevertheless, mathematicians have come up with an enhancement to the above primality test that will detect non-primes (even Carmichael numbers) with high probability and negligible additional computation, so we may as well use it.</p>
<p class="docText">The method of choice for testing whether a number is prime is due to Miller and Rabin [<a class="docLink" href="biblio01.html#biblio01_137">RABI80</a>]. We can always express <span class="docEmphasis">n</span>-1 as a power of two times an odd number, say 2<span class="docEmphasis"><sup>b</sup>c</span>. We can then compute <span class="docEmphasis">a<sup>n</sup></span>-1 mod <span class="docEmphasis">n</span> by computing <span class="docEmphasis">a<sup>c</sup></span> mod <span class="docEmphasis">n</span> and then squaring the result <span class="docEmphasis">b</span> times. If the result is not 1, then <span class="docEmphasis">n</span> is not prime and we're done. If the result is 1, we can go back and look at those last few intermediate squarings. (If we're really clever, we'll be checking the intermediate results as we compute them.) If <span class="docEmphasis">a<sup>c</sup></span> mod <span class="docEmphasis">n</span> is not 1, then one of the squarings took a number that was not 1 and squared it to produce 1. That number is a mod <span class="docEmphasis">n</span> square root of 1. It turns out that if <span class="docEmphasis">n</span> is prime, then the only mod <span class="docEmphasis">n</span> square roots of 1 are 1 and -1 (also known as <span class="docEmphasis">n</span>-1). Further, if <span class="docEmphasis">n</span> is not a power of a prime, then 1 has many square roots, and all are equally likely to be found by this test. For more on why, see &sect;<a class="docLink" href="ch07lev1sec5.html#ch07lev1sec5">7.5</a> <span class="docEmphasis">Chinese Remainder Theorem</span>. So if the Miller-Rabin test finds a square root of 1 that is not &#177;1, then <span class="docEmphasis">n</span> is not prime. Furthermore, if <span class="docEmphasis">n</span> is not prime (even if it is a Carmichael number), at least &#190; of all possible values of <span class="docEmphasis">a</span> will show <span class="docEmphasis">n</span> to be composite. By trying many values for <span class="docEmphasis">a</span>, we can make the probability of falsely identifying <span class="docEmphasis">n</span> as prime inconceivably small. In actual implementations, how many values of <span class="docEmphasis">a</span> to try is a trade-off between performance and paranoia.</p>
<p class="docText">To summarize, an efficient method of finding primes is:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Pick an odd random number <span class="docEmphasis">n</span> in the proper range.</p></div></li><li><div style="font-weight:normal"><p class="docList">Test <span class="docEmphasis">n</span>'s divisibility by small primes and go back to step 1 if you find a factor. (Obviously, this step isn't necessary, but it's worth it since it has a high enough probability of catching some non-primes and is much faster than the next step).</p></div></li><li><div style="font-weight:normal"><p class="docList">Repeat the following until <span class="docEmphasis">n</span> is proven not prime (in which case go back to step 1) or as many times as you feel necessary to show that <span class="docEmphasis">n</span> is probably prime:</p><p class="docList">Pick an <span class="docEmphasis">a</span> at random and compute <span class="docEmphasis">a<sup>c</sup></span> mod <span class="docEmphasis">n</span> (where <span class="docEmphasis">c</span> is the odd number for which <span class="docEmphasis">n</span>-1 = 2<span class="docEmphasis"><sup>b</sup>c</span>). During the computation of <span class="docEmphasis">a<sup>c</sup></span> mod <span class="docEmphasis">n</span>, each time mod <span class="docEmphasis">n</span> squaring is performed, check if the result is 1; if so, check if the number that was squared (which is a square root of 1) is &#177;1; if not, <span class="docEmphasis">n</span> is not prime.</p><p class="docList">Next, if the result of the computation of <span class="docEmphasis">a<sup>c</sup></span> mod <span class="docEmphasis">n</span> is &#177;1, <span class="docEmphasis">n</span> passes the primality test for this <span class="docEmphasis">a</span>. Otherwise, at most <span class="docEmphasis">b</span>-1 times, replace the result by its square and check if it is &#177;1. If it is 1, <span class="docEmphasis">n</span> is not prime (because the previous result is a square root of 1 different from &#177;1). If it is -1, <span class="docEmphasis">n</span> passes the primality test for this <span class="docEmphasis">a</span>. If you've done the squaring <span class="docEmphasis">b</span>-1 times, <span class="docEmphasis">n</span> is not prime (because <span class="docEmphasis">a</span><sup>(</sup><span class="docEmphasis">n</span>-1)/2 is not &#177;1).</p></div></li></ol></div>
<a name="ch06lev4sec2"></a>
<h5 id="title-IDAEQYLK" class="docSection4Title">6.3.4.2.2. Finding <span class="docEmphasis">d</span> and <span class="docEmphasis">e</span></h5>
<p class="docText">How do we find <span class="docEmphasis">d</span> and <span class="docEmphasis">e</span> given <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>? As we said earlier, for <span class="docEmphasis">e</span> we can choose any number that is relatively prime to (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1), and then all we need to do is find the number <span class="docEmphasis">d</span> such that <span class="docEmphasis">ed</span> =1 mod &#966;(<span class="docEmphasis">n</span>). This we can do with Euclid's algorithm.</p>
<p class="docText">There are two strategies one can use to ensure that <span class="docEmphasis">e</span> and (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1) are relatively prime.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">After <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> are selected, choose <span class="docEmphasis">e</span> at random. Test to see if <span class="docEmphasis">e</span> is relatively prime to (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1). If not, select another <span class="docEmphasis">e</span>.</p></div></li><li><div style="font-weight:normal"><p class="docList">Don't pick <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> first. Instead, first choose <span class="docEmphasis">e</span>, then select <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> carefully so that (<span class="docEmphasis">p</span>-1) and (<span class="docEmphasis">q</span>-1) are guaranteed to be relatively prime to <span class="docEmphasis">e</span>. The next section will explain why you'd want to do this.</p></div></li></ol></div>
<a name="ch06lev3sec3"></a>
<h5 id="title-IDAATYLK" class="docSection3Title">6.3.4.3. Having a Small Constant <span class="docEmphasis">e</span></h5>
<p class="docText">A rather astonishing discovery is that RSA is no less secure (as far as anyone knows) if <span class="docEmphasis">e</span> is always chosen to be the same number. And if <span class="docEmphasis">e</span> is chosen to be small, or easy to compute, then the operations of encryption and signature verification become much more efficient. Given that the procedure <a name="iddle1178"></a>for finding a <span class="docEmphasis">d</span> and <span class="docEmphasis">e</span> pair is to pick one and then derive the other, it is straightforward to make <span class="docEmphasis">e</span> be a small constant. This makes public key operations faster while leaving private key operations unchanged. You might wonder whether it would be possible to select small values for <span class="docEmphasis">d</span> to make private key operations fast at the expense of public key operations. The answer is that you can't. If <span class="docEmphasis">d</span> were a constant, the scheme would not be secure because <span class="docEmphasis">d</span> is the secret. If <span class="docEmphasis">d</span> were small, an attacker could search small values to find <span class="docEmphasis">d</span>.</p>
<p class="docText">Two popular values of <span class="docEmphasis">e</span> are 3 and 65537.</p>
<p class="docText">Why 3? 2 doesn't work because it is not relatively prime to (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1) (which must be even because <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> are both odd). 3 can work, and with 3, public key operations require only two multiplies. Using 3 as the public exponent maximizes performance.</p>
<p class="docText">As far as anyone knows, using 3 as a public exponent does not weaken the security of RSA if some practical constraints on its use are followed. Most dramatically, if a message <span class="docEmphasis">m</span> to be encrypted is smallÂin particular, smaller than 

<img border="0" alt="" width="20" height="16" src="159equ01.jpg" />


Âthen raising <span class="docEmphasis">m</span> to the power of three and reducing mod <span class="docEmphasis">n</span> will simply produce the value <span class="docEmphasis">m</span><sup>3</sup>. Anyone seeing such an encrypted message could decrypt it simply by taking a cube root. This problem can be avoided by padding each message with a random number before encryption, so that <span class="docEmphasis">m</span><sup>3</sup> is always large enough to be guaranteed to need to be reduced mod <span class="docEmphasis">n</span>.</p>
<p class="docText">A second problem with using 3 as an exponent is that if the same message is sent encrypted to three or more recipients each of whom has a public exponent of 3, the message can be derived from the three encrypted values and the three public keys &lt;3, <span class="docEmphasis">n</span><sub>1</sub>&gt;, &lt;3, <span class="docEmphasis">n</span><sub>2</sub>&gt;, &lt;3, <span class="docEmphasis">n</span><sub>3</sub>&gt;.</p>
<p class="docText">Suppose a bad guy sees <span class="docEmphasis">m</span><sup>3</sup> mod <span class="docEmphasis">n</span><sub>1</sub>, <span class="docEmphasis">m</span><sup>3</sup> mod <span class="docEmphasis">n</span><sub>2</sub>, and <span class="docEmphasis">m</span><sup>3</sup> mod <span class="docEmphasis">n</span><sub>3</sub> and knows &lt;3, <span class="docEmphasis">n</span><sub>1</sub>&gt;, &lt;3, <span class="docEmphasis">n</span><sub>2</sub>&gt;, &lt;3, <span class="docEmphasis">n</span><sub>3</sub>&gt;. Then by the Chinese Remainder computation (see &sect;<a class="docLink" href="ch07lev1sec5.html#ch07lev1sec5">7.5</a> <span class="docEmphasis">Chinese Remainder Theorem</span>), the bad guy can compute <span class="docEmphasis">m</span><sup>3</sup> mod <span class="docEmphasis">n</span><sub>1</sub><span class="docEmphasis">n</span><sub>2</sub><span class="docEmphasis">n</span><sub>3</sub>. Since <span class="docEmphasis">m</span> is smaller than each of the <span class="docEmphasis">n<sub>i</sub></span> s (because RSA can only encrypt messages smaller than the modulus), <span class="docEmphasis">m</span><sup>3</sup> will be smaller than <span class="docEmphasis">n</span><sub>1</sub><span class="docEmphasis">n</span><sub>2</sub><span class="docEmphasis">n</span><sub>3</sub>, so <span class="docEmphasis">m</span><sup>3</sup> mod <span class="docEmphasis">n</span><sub>1</sub><span class="docEmphasis">n</span><sub>2</sub><span class="docEmphasis">n</span><sub>3</sub> will just be <span class="docEmphasis">m</span><sup>3</sup>. Therefore, the bad guy can compute the ordinary cube root of <span class="docEmphasis">m</span><sup>3</sup> (which again is easy if you are a computer), giving <span class="docEmphasis">m</span>.</p>
<p class="docText">Now this isn't anything to get terribly upset about. In practical uses of RSA, the message to be encrypted is usually a key for a secret key encryption algorithm and in any case is much smaller than <span class="docEmphasis">n</span>. As a result, the message must be padded before it is encrypted. If the padding is randomly chosen (and it should be for a number of reasons), and if it is rechosen for each recipient, then there is no threat from an exponent of 3 no matter how many recipients there are. The padding doesn't really have to be randomÂfor example, the recipient's ID would work fine.</p>
<p class="docText">Finally, an exponent of 3 works only if 3 is relatively prime to &#966;(<span class="docEmphasis">n</span>) (in order for it to have an inverse <span class="docEmphasis">d</span>). How do we choose <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> so that 3 will be relatively prime to &#966;(<span class="docEmphasis">n</span>) = (<span class="docEmphasis">p</span>-1)(<span class="docEmphasis">q</span>-1)? Clearly, (<span class="docEmphasis">p</span>-1) and (<span class="docEmphasis">q</span>-1) must each be relatively prime to 3. To ensure that <span class="docEmphasis">p</span>-1 is relatively prime to 3, we want <span class="docEmphasis">p</span> to be 2 mod 3. That will ensure <span class="docEmphasis">p</span>-1 is 1 mod 3. Similarly we want <span class="docEmphasis">q</span> to be 2 mod 3. We can make sure that the only primes we select are congruent to 2 mod 3 by choosing a random number, multiplying by 3 and adding 2, and using that as the number we will test for primality. Indeed, we want to make sure the number we test is odd (since if it's even it is unlikely to be prime), so we should start with an odd number, multiply by 3 and add 2. This is equivalent to starting with any random number, multiplying by 6 and then adding 5.</p>
<p class="docText">Another popular value of <span class="docEmphasis">e</span> is 65537. Why 65537? The appeal of 65537 (as opposed to others of the same approximate size) is that 65537 = 2<sup>16</sup>+1 and it is prime. Because its binary representation contains only two 1s, it takes only 17 multiplies to exponentiate. While this is much slower than the two multiplies required with an exponent of 3, it is much faster than the 768 (on average) required with a randomly chosen 512-bit value (the typical size of an RSA modulus in practical use today). Also, using the number 65537 as a public exponent largely avoids the problems with the exponent 3.</p>
<p class="docText">The first problem with 3 occurs if <span class="docEmphasis">m</span><sup>3</sup> &lt; <span class="docEmphasis">n</span>. Unless <span class="docEmphasis">n</span> is much longer than the 512 bits in typical use today, there aren't too many values of <span class="docEmphasis">m</span> for which <span class="docEmphasis">m</span><sup>65537</sup> &lt; <span class="docEmphasis">n</span>, so being able to take a normal 65537<span class="docEmphasis"><sup>th</sup></span> root is not a threat.</p>
<p class="docText">The second problem with 3 occurs when the same message is sent to at least 3 recipients. In theory, with 65537 there is a threat if the same message is sent encrypted to at least 65537 recipients. A cynic would argue that under such circumstances, the message couldn't be very secret.</p>
<p class="docText">The third problem with 3 is that we have to choose <span class="docEmphasis">n</span> so that &#966;(<span class="docEmphasis">n</span>) is relatively prime to 3. For 65537, the easiest thing to do is just reject any <span class="docEmphasis">p</span> or <span class="docEmphasis">q</span> which is equal to 1 mod 65537. The probability of rejection is very small (2<sup>-16</sup>), so this doesn't make finding <span class="docEmphasis">n</span> significantly harder.</p>
<a name="ch06lev3sec4"></a>
<h5 id="title-IDAI1YLK" class="docSection3Title">6.3.4.4. Optimizing RSA Private Key Operations</h5>
<p class="docText">There is a way to speed up RSA exponentiations in generating signatures and decrypting (the operations using the private key) by taking advantage of knowledge of <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>. Feel free to skip this sectionÂit isn't a prerequisite for anything else in the book. And it requires more than the usual level of concentration.</p>
<p class="docText">In RSA, <span class="docEmphasis">d</span> and <span class="docEmphasis">n</span> are on the order of 512-bit numbers, or 150 digits. <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> are on the order of 256 bits, or 75 digits. RSA private key operations involve taking some <span class="docEmphasis">c</span> (usually a 512-bit number) and computing <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">n</span>. It's easy to say &quot;raise a 512-bit number to a 512-bit exponent mod a 512-bit number,&quot; but it's certainly processor-intensive, even if you happen to be a silicon-based computer. A way to speed up RSA operations is to do all the computation mod <span class="docEmphasis">p</span> and mod <span class="docEmphasis">q</span>, then use the Chinese Remainder Theorem to compute what the answer is mod <span class="docEmphasis">pq</span>.</p>
<p class="docText">So suppose you want to compute <span class="docEmphasis">m</span> = <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">n</span>.</p>
<p class="docText">Instead, you could take <span class="docEmphasis">c<sub>p</sub></span> = <span class="docEmphasis">c</span> mod <span class="docEmphasis">p</span> and <span class="docEmphasis">c<sub>q</sub></span> = <span class="docEmphasis">c</span> mod <span class="docEmphasis">q</span> and compute <span class="docEmphasis">m<sub>p</sub></span> = <span class="docEmphasis">c<sub>p</sub><sup>d</sup></span> mod <span class="docEmphasis">p</span> and <span class="docEmphasis">m<sub>q</sub></span> = <span class="docEmphasis">c<sub>q</sub><sup>d</sup></span> mod <span class="docEmphasis">q</span>, then use the Chinese Remainder Theorem to convert back to what <span class="docEmphasis">m</span> would equal mod <span class="docEmphasis">n</span>, which would give you <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">n</span>. Also, it is not necessary to raise to the <span class="docEmphasis">d</span><sup>th</sup> power mod <span class="docEmphasis">p</span>, given that <span class="docEmphasis">d</span> is going to be bigger than <span class="docEmphasis">p</span> (by a factor of about <span class="docEmphasis">q</span>). Since (by Euler's Theorem) any <span class="docEmphasis">a</span><sup><span class="docEmphasis">p</span>-1</sup> = 1 mod <span class="docEmphasis">p</span>, we can take <span class="docEmphasis">d</span>'s value mod <span class="docEmphasis">p</span>-1 and use that as the exponent instead. In other words, if <span class="docEmphasis">d</span> = <span class="docEmphasis">k</span>(<span class="docEmphasis">p</span>-1) + <span class="docEmphasis">r</span>, then <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">p</span> = <span class="docEmphasis">c<sup>r</sup></span> mod <span class="docEmphasis">p</span>.</p>
<p class="docText"><a name="iddle2013"></a>So, let us compute <span class="docEmphasis">d<sub>p</sub></span> = <span class="docEmphasis">d</span> mod (<span class="docEmphasis">p</span>-1) and <span class="docEmphasis">d<sub>q</sub></span> = <span class="docEmphasis">d</span> mod (<span class="docEmphasis">q</span>-1). Then, instead of doing the expected RSA operation of <span class="docEmphasis">m</span> = <span class="docEmphasis">c<sup>d</sup></span> mod <span class="docEmphasis">n</span> which involves 512-bit numbers, we'll compute both <span class="docEmphasis">m<sub>p</sub></span> = <span class="docEmphasis">c<sub>p</sub><sup>d</sup>p</span> mod <span class="docEmphasis">p</span> and <span class="docEmphasis">m<sub>q</sub></span> = <span class="docEmphasis">c<sub>q</sub><sup>d</sup>q</span> mod <span class="docEmphasis">q</span> and then compute <span class="docEmphasis">m</span> from the Chinese Remainder Theorem. To save ourselves work, since we'll be using <span class="docEmphasis">d<sub>p</sub></span> and <span class="docEmphasis">d<sub>q</sub></span> a lot (every time we do an RSA private key computation), we'll compute them once and remember them. Similarly, to use the Chinese Remainder Theorem at the end, we need to know <span class="docEmphasis">p</span><sup>-1</sup> mod <span class="docEmphasis">q</span> and <span class="docEmphasis">q</span><sup>-1</sup> mod <span class="docEmphasis">p</span>, so we'll precompute and remember them as well.</p>
<p class="docText">All told, instead of one 512-bit exponentiation, this modified calculation does two 256-bit exponentiations, followed by two 256-bit multiplies and a 512-bit add. This might not seem like a net gain, but because the exponents are half as long, using this variant makes RSA about twice as fast.</p>
<p class="docText">Note that to do these optimizations for RSA operations, we need to know <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>. Someone who is only supposed to know the public key will not know <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> (or else they can easily compute <span class="docEmphasis">d</span>). Therefore, these optimizations are only useful for the private key operations (decryption and generating signatures). However, that's okay because we can choose <span class="docEmphasis">e</span> to be a convenient value (like 3 or 65537) so that raising a 512-bit number to <span class="docEmphasis">e</span> will be easy enough without the Chinese Remainder optimizations.</p>
<a name="ch06lev2sec8"></a>
<h4 id="title-IDA5KO0H" class="docSection2Title">6.3.5. Arcane RSA Threats</h4>
<p class="docText">Any number <span class="docEmphasis">x</span> &lt; <span class="docEmphasis">n</span> is a signature of <span class="docEmphasis">x<sup>e</sup></span> mod <span class="docEmphasis">n</span>. So it's trivial to forge someone's signature if you don't care what you're signing. The trick is to find a way to sign a specific number. Typically what is being signed is sufficiently constrained so that a random number has negligible probability of being a valid message. For example, often what is being signed is a message digest padded in a specific manner. If the pad is hundreds of zero bits, it is extremely unlikely that a random number will look like a padded message digest.</p>
<p class="docText">If you're not careful about how you pad your message data, you may allow an attacker without knowledge of your private key to forge your signature on valid messages.</p>
<p class="docText">Note: RSA deals with large numbers, and there is unfortunately more than one way to represent such numbers. In what follows, we have chosen to order the octets left to right from most significant to least significant.</p>
<a name="ch06lev3sec5"></a>
<h5 id="title-IDAZLO0H" class="docSection3Title">6.3.5.1. Smooth Numbers</h5>
<p class="docText">A <span class="docEmphStrong">smooth number</span> is defined as one that is the product of reasonably small primes. There's no absolute definition of a smooth number, since there's no real definition of <span class="docEmphasis">reasonably small</span>. The more compute power the attacker has at her disposal, and the more signatures she has access to, the larger the primes can be.</p>
<p class="docText">The threat we are about to describe is known as the <span class="docEmphStrong">smooth number threat</span>. It is really only of theoretical interest, because of the immense amount of computation, gathering of immense numbers of signed messages, and luck involved. However, it costs very little to have an encoding that avoids this threat. The smooth number threat was discovered by Desmedt and Odlyzko [<a class="docLink" href="biblio01.html#biblio01_045">DESM86</a>].</p>
<p class="docText">The first observation is that if you have signed <span class="docEmphasis">m</span><sub>1</sub> and <span class="docEmphasis">m</span><sub>2</sub>, and a bad guy Carol can see your signature on <span class="docEmphasis">m</span><sub>1</sub> and <span class="docEmphasis">m</span><sub>2</sub>, she can compute your signature on <span class="docEmphasis">m</span><sub>1</sub>&#183;<span class="docEmphasis">m</span><sub>2</sub>, and on <span class="docEmphasis">m</span><sub>1</sub>/<span class="docEmphasis">m</span><sub>2</sub>, and <span class="docEmphasis">m</span><sub>1</sub><span class="docEmphasis"><sup>j</sup></span>, and on <span class="docEmphasis">m</span><sub>1</sub><span class="docEmphasis"><sup>j</sup></span>&#183;<span class="docEmphasis">m</span><sub>2</sub><span class="docEmphasis"><sup>k</sup></span>. For instance, if Carol sees <span class="docEmphasis">m</span><sub>1</sub><span class="docEmphasis"><sup>d</sup></span> mod <span class="docEmphasis">n</span> (which is your signature on <span class="docEmphasis">m</span><sub>1</sub>), then she can compute your signature on <span class="docEmphasis">m</span><sub>1</sub><sup>2</sup> by computing (<span class="docEmphasis">m</span><sub>1</sub><span class="docEmphasis"><sup>d</sup></span> mod <span class="docEmphasis">n</span>)<sup>2</sup> mod <span class="docEmphasis">n</span> (see <a class="docLink" href="ch06lev1sec9.html#ch06qa1q8">Homework Problem 8</a>).</p>
<p class="docText">If Carol collects a lot of your signed messages, she will be able to compute your signature on any message that can be computed from her collection by multiplication and division. If the messages you sign are mostly smooth, there will be a lot of other smooth messages on which she will be able to forge your signature.</p>
<p class="docText">Suppose she collects your signatures on two messages whose ratio is a prime. Then she can compute your signature on that prime. If she's lucky enough to get many such message pairs, she can compute your signature on lots of primes, and then she can forge your signature on any message that is the product of any subset of those primes, each raised to any power. With enough pairs, she will be able to forge your signature on any message that is a smooth number.</p>
<p class="docText">Actually, Carol does not have to be nearly that lucky. With as few as <span class="docEmphasis">k</span> signatures on messages which are products of different subsets of <span class="docEmphasis">k</span> distinct primes, she will be able to isolate the signatures on the individual primes through a carefully chosen set of multiplications and divisions.</p>
<p class="docText">The typical thing being signed with RSA is a padded message digest. If it is padded with zeroes, it is much more likely to be smooth than is a random mod <span class="docEmphasis">n</span> number. A random mod <span class="docEmphasis">n</span> quantity is extremely unlikely to be smooth (low enough probability so that if you are signing random mod <span class="docEmphasis">n</span> numbers, we can assume Carol would have to have a lot of resources and a lot of luck to find even one smooth number you've signed, and she might need millions of them in order to mount the attack).</p>
<p class="docText">Padding on the left with zeroes keeps the padded message digest small and therefore likely to be smooth. Padding on the right with zeroes is merely multiplying the message digest by some power of 2, and so isn't any better.</p>
<p class="docText">Another tempting padding scheme is to pad on the right with random data. That way, since you are signing fairly random mod <span class="docEmphasis">n</span> numbers, it is very unlikely that any of the messages you sign will be smooth, so Carol won't have enough signed smooth messages to mount the threat. However, this leaves us open to the next obscure threat.</p>
<a name="ch06lev3sec6"></a>
<h5 id="title-IDADA0ER" class="docSection3Title">6.3.5.2. The Cube Root Problem</h5>
<p class="docText">Let's say you pad on the right with random data. You chose that scheme so that there is a negligible probability that anything you sign will be smooth. However, if the public exponent is 3, this enables Carol to forge your signature on virtually any message she chooses!</p>
<p class="docText"><a name="iddle1002"></a><a name="iddle1033"></a><a name="iddle1814"></a><a name="iddle1878"></a>Let's say Carol wants your signature on some message. The message digest of that message is <span class="docEmphasis">h</span>. Carol pads <span class="docEmphasis">h</span> on the right with zeroes. She then computes its ordinary cube root and rounds up to an integer <span class="docEmphasis">r</span>. Now she has forged your signature, because <span class="docEmphasis">r<sup>e</sup></span> = <span class="docEmphasis">r</span><sup>3</sup> = (<span class="docEmphasis">h</span> padded on the right with a seemingly random number).</p>
<a name="ch06lev2sec9"></a>
<h4 id="title-IDAJC0ER" class="docSection2Title">6.3.6. Public-Key Cryptography Standard (PKCS)</h4>
<p class="docText">It is useful to have some standard for the encoding of information that will be signed or encrypted through RSA, so that different implementations can interwork, and so that the various pitfalls with RSA can be avoided. Rather than expecting every user of RSA to be sophisticated enough to know about all the attacks and develop appropriate safety measures through careful encoding, <span class="docEmphRoman"><a class="docLink" href="app02.html#gloss01_192">RSADSI</a></span> has developed a standard known as <b><a class="docLink" href="app02.html#gloss01_164">PKCS</a></b> which recommends encodings. PKCS is actually a set of standards, called PKCS #1 through PKCS #15. There are also two companion documents, <span class="docEmphasis">An overview of the PKCS standards</span>, and <span class="docEmphasis">A layman's guide to a subset of ASN.1, BER, and DER</span>. (<b><a class="docLink" href="app02.html#gloss01_008">ASN.1</a></b> = <i><a class="docLink" href="app02.html#gloss01_008">Abstract Syntax Notation 1</a></i>, <span class="docEmphStrong">BER</span> = <span class="docEmphasis">Basic Encoding Rules</span>, and <span class="docEmphStrong">DER</span> = <span class="docEmphasis">Distinguished Encoding Rules</span>Âaren't you glad you asked?).</p>
<p class="docText">The PKCS standards define the encodings for things such as an RSA public key, an RSA private key, an RSA signature, a short RSA-encrypted message (typically a secret key), a short RSA-signed message (typically a message digest), and password-based encryption.</p>
<p class="docText">The threats that PKCS has been designed to deal with are:</p>
<ul><li><p class="docList">encrypting guessable messages</p></li><li><p class="docList">signing smooth numbers</p></li><li><p class="docList">multiple recipients of a message when <span class="docEmphasis">e</span> = 3</p></li><li><p class="docList">encrypting messages that are less than a third the length of <span class="docEmphasis">n</span> when <span class="docEmphasis">e</span> = 3</p></li><li><p class="docList">signing messages where the information is in the high-order part and <span class="docEmphasis">e</span> = 3</p></li></ul>
<a name="ch06lev3sec7"></a>
<h5 id="title-IDAIF0ER" class="docSection3Title">6.3.6.1. Encryption</h5>
<p class="docText">PKCS #1 defines a standard for formatting a message to be encrypted with RSA. RSA is not generally used to encrypt ordinary data. The most common quantity that would be encrypted with RSA is a secret key, and for performance reasons the ordinary data would be encrypted with the secret key.</p>
<p class="docText">The recommended standard is</p>
<p><table cellspacing="0" class="allBorders" border="1" rules="all" cellpadding="4"><colgroup align="center" span="5"><col width="50"></col><col width="50"></col><col width="200"></col><col width="50"></col><col width="150"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">0</span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">2</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">at least eight random nonzero octets</span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">0</span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">data</span></p></td></tr></table></p><br />
<p class="docText"><a name="iddle1057"></a><a name="iddle1657"></a>The actual data to be encrypted, usually a secret key, is much smaller than the modulus. If it's a DES key, it's 64 bits. If multiple DES encryption is used, then there might be two DES keys there, or 128 bits.</p>
<p class="docText">The top octet is <span class="docEmphRomanAlt">0</span>, which is a good choice because this guarantees that the message <span class="docEmphasis">m</span> being encrypted is smaller than the modulus <span class="docEmphasis">n.</span> (If <span class="docEmphasis">m</span> were larger than <span class="docEmphasis">n</span>, decryption would produce <span class="docEmphasis">m</span> mod <span class="docEmphasis">n</span> instead of <span class="docEmphasis">m</span>.) Note that PKCS specifies that the high-order octet (not bit!) of the modulus must be non-zero.</p>
<p class="docText">The next octet is <span class="docEmphRomanAlt">2</span>, which is the format type. The value <span class="docEmphRomanAlt">2</span> is used for a block to be encrypted. The value <span class="docEmphRomanAlt">1</span> is used for a value to be signed (see next section).</p>
<p class="docText">Each octet of padding is chosen independently to be a random nonzero value. The reason <span class="docEmphRomanAlt">0</span> cannot be used as a padding octet is that <span class="docEmphRomanAlt">0</span> is used to delimit the padding from the data.</p>
<p class="docText">Let's review the RSA threats and see how this encoding addresses them:</p>
<ul><li><p class="docList">encrypting guessable messagesÂSince there are at least eight octets of randomly chosen padding, knowing what might appear in the data does not help the attacker who would like to guess the data, encrypt it, and compare it with the ciphertext. The attacker would have to guess the padding as well, and this is infeasible.</p></li><li><p class="docList">sending the same encrypted message to more than three recipients (assuming 3 is chosen for <span class="docEmphasis">e</span>)ÂAs long as the padding is chosen independently for each recipient, the quantities being encrypted will not be the same.</p></li><li><p class="docList">encrypting messages that are less than a third the length of <span class="docEmphasis">n</span> when <span class="docEmphasis">e</span> = 3ÂBecause the second octet is nonzero, the message will be guaranteed to be more than a third the length of <span class="docEmphasis">n</span>.</p></li></ul>
<a name="ch06lev3sec8"></a>
<h5 id="title-IDACTTDR" class="docSection3Title">6.3.6.2. EncryptionÂTake 2</h5>
<p class="docText">There was an attack on SSL (see <a class="docLink" href="ch19.html#ch19">Chapter 19</a> <span class="docEmphasis">SSL/TLS</span>) that could have been interpreted as a flaw in the design of SSL, but the world has come to see it as a flaw in the PKCS #1 encryption format, and there is a PKCS #1 version 2 format that fixes the &quot;flaw&quot;. The attack is known as the <span class="docEmphStrong">million message attack</span>, and occurs because SSL made some incorrect assumptions about the services PKCS #1 padding provides.</p>
<p class="docText">In the SSL protocol, the client sends the server a randomly chosen key padded according to PKCS #1 and encrypted using RSA. SSL decrypts the value, and, if the padding is correct, sends a response encrypted with the enclosed key. If after the decryption the padding is not correct, it sends an error message. The problem is that this allows an attacker to use the server as an oracle: it can send the server a message and the server will tell it whether the message (when decrypted) has proper PKCS #1 padding. Some SSL servers were particularly helpful and would say whether the padding was wrong because the first two octets were something other than <span class="docEmphRomanAlt">0</span> and <span class="docEmphRomanAlt">2</span> or whether it <a name="iddle1720"></a>was wrong because the length of the encrypted quantity was something other than what was expected.</p>
<p class="docText">Daniel Bleichenbacher [<a class="docLink" href="biblio01.html#biblio01_020">BLEI98</a>] figured out how an eavesdropper who picked up a key encrypted for a server could carefully craft variations of that encrypted key such that if the server would identify some of those variations which when decrypted began with the octets <span class="docEmphRomanAlt">0</span> and <span class="docEmphRomanAlt">2</span>, the attacker could eventually figure out the encrypted key. The most helpful servers would identify one message in 2<sup>16</sup> as having that form, allowing the eavesdropper to recover the encrypted key after sending about a million messages (most of them invalid).</p>
<p class="docText">Attacks of this sort can be avoided if the padding for encryption includes enough redundancy that the probability of a randomly chosen value decrypting into something that looks like it is properly padded is negligible. (<span class="docEmphasis">One in a million</span> is not considered negligible to cryptographers. To them &quot;negligible&quot; should be less than one in 2<sup>100</sup> or so.) A particularly complex scheme for doing that is specified in PKCS #1 version 2, also known as OAEP [<a class="docLink" href="biblio01.html#biblio01_009">BELL94</a>] and standardized in IEEE P1363.</p>
<p class="docText">Because this is an obscure attack easily avoided by other means (like not being so helpful when people send you invalid messages), the world has not scrambled to migrate to this new padding. But it will probably be mandated in newly defined protocols where backwards compatibility is not an issue.</p>
<a name="ch06lev3sec9"></a>
<h5 id="title-IDATVTDR" class="docSection3Title">6.3.6.3. Signing</h5>
<p class="docText">PKCS #1 also defines a standard for formatting a message to be signed with RSA. Usually the data being signed is a message digest, typically 128 bits. As with encryption, padding is required.</p>
<p><table cellspacing="0" class="allBorders" border="1" rules="all" cellpadding="4"><colgroup align="center" span="5"><col width="50"></col><col width="50"></col><col width="200"></col><col width="50"></col><col width="200"></col></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">0</span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">1</span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">at least eight octets of ff<sub>16</sub></span></p></td><td class="docTableCell" align="center" valign="middle"><p class="docText"><span class="docEmphRomanAlt">0</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphRomanAlt">ASN.1-encoded digest type and digest</span></p></td></tr></table></p><br />
<p class="docText">As with encryption, the top octet of 0 ensures that the quantity to be signed will be less than <span class="docEmphasis">n</span>. The next octet is the PKCS type, in this case, a quantity to be signed. The padding ensures that the quantity to be signed is very large and therefore unlikely to be a smooth number.</p>
<p class="docText">Inclusion of the digest type instead of merely the digest serves two purposes. It standardizes how to tell the other party which digest function you used, and it prevents an obscure threat. The threat is that one of the message digest functions, say MD4, might be weak, so that bad guys with big budgets can generate a message with a particular MD4 message digest. Now suppose you were suspicious of MD4 and therefore used MD5. You signed the MD5 message digest of your message <span class="docEmphasis">m</span>. If the digest type were not included in the quantity that you RSA signed, then a bad guy could generate some message <span class="docEmphasis">m</span>' such that MD4(<span class="docEmphasis">m</span>') = MD5(<span class="docEmphasis">m</span>), and use the same signature you'd generated for <span class="docEmphasis">m</span> as the signature for <span class="docEmphasis">m</span>'. Including the digest type in the signature means you're at risk only for the cryptographic strength of the message digest functions you choose to use.</p>
<a href="15051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>