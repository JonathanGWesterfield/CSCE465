<html><head><title>2.6. Hash Algorithms</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Networking Security Networking Security Networking Security Security Networking Security Networking Security Networking Charlie Kaufman Radia Perlman Mike Speciner Prentice Hall Network Security: Private Communication in a Public World, Second Edition<a name="ch02lev1sec6"></a>
<h3 id="title-IDANLG5H" class="docSection1Title">2.6. Hash Algorithms</h3>
<p class="docText">Hash algorithms are also known as <span class="docEmphStrong">message digests</span> or <span class="docEmphStrong">one-way transformations</span>.</p>
<p class="docText">A cryptographic hash function is a mathematical transformation that takes a message of arbitrary length (transformed into a string of bits) and computes from it a fixed-length (short) number.</p>
<p class="docText"><a name="iddle1780"></a>We'll call the hash of a message <span class="docEmphasis">m</span>, <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>). It has the following properties:</p>
<ul><li><p class="docList">For any message <span class="docEmphasis">m</span>, it is relatively easy to compute <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>). This just means that in order to be practical it can't take a lot of processing time to compute the hash.</p></li><li><p class="docList">Given <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>), there is no way to find an <span class="docEmphasis">m</span> that hashes to <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>) in a way that is substantially easier than going through all possible values of <span class="docEmphasis">m</span> and computing <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>) for each one.</p></li><li><p class="docList">Even though it's obvious that many different values of <span class="docEmphasis">m</span> will be transformed to the same value <span class="docEmphasis">h</span>(<span class="docEmphasis">m</span>) (because there are many more possible values of <span class="docEmphasis">m</span>), it is <span class="docEmphasis">computationally infeasible</span> to find two values that hash to the same thing.</p></li></ul>
<p class="docText">An example of the sort of function that might work is taking the message <span class="docEmphasis">m</span>, treating it as a number, adding some large constant, squaring it, and taking the middle <span class="docEmphasis">n</span> digits as the hash. You can see that while this would not be difficult to compute, it's not obvious how you could find a message that would produce a particular hash, or how one might find two messages with the same hash. It turns out this is not a particularly good message digest functionÂwe'll give examples of secure message digest functions in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> <span class="docEmphasis">Hashes and Message Digests</span>. But the basic idea of a message digest function is that the input is mangled so badly the process cannot be reversed.</p>
<a name="ch02lev2sec17"></a>
<h4 id="title-IDAUOG5H" class="docSection2Title">2.6.1. Password Hashing</h4>
<p class="docText">When a user types a password, the system has to be able to determine whether the user got it right. If the system stores the passwords unencrypted, then anyone with access to the system storage or backup tapes can steal the passwords. Luckily, it is not necessary for the system to know a password in order to verify its correctness. (A proper password is like pornography. You can't tell what it is, but you know it when you see it.)</p>
<p class="docText">Instead of storing the password, the system can store a hash of the password. When a password is supplied, it computes the password's hash and compares it with the stored value. If they match, the password is deemed correct. If the hashed password file is obtained by an attacker, it is not immediately useful because the passwords can't be derived from the hashes. Historically, some systems made the password file publicly readable, an expression of confidence in the security of the hash. Even if there are no cryptographic flaws in the hash, it is possible to guess passwords and hash them to see if they match. If a user is careless and chooses a password that is guessable (say, a word that would appear in a 50000-word dictionary or book of common names), an exhaustive search would &quot;crack&quot; the password even if the encryption were sound. For this reason, many systems hide the hashed password list (and those that don't should).</p>
<a name="ch02lev2sec18"></a>
<h4 id="title-IDAFPG5H" class="docSection2Title">2.6.2. Message Integrity</h4>
<p class="docText"><a name="iddle1416"></a><a name="iddle1462"></a><a name="iddle1548"></a><a name="iddle1636"></a>Cryptographic hash functions can be used to generate a MAC to protect the integrity of messages transmitted over insecure media in much the same way as secret key cryptography.</p>
<p class="docText">If we merely sent the message and used the hash of the message as a MAC, this would not be secure, since the hash function is well-known. The bad guy can modify the message and compute a new hash for the new message, and transmit that.</p>
<p class="docText">However, if Alice and Bob have agreed on a secret, Alice can use a hash to generate a MAC for a message to Bob by taking the message, concatenating the secret, and computing the hash of <span class="docEmphasis">message</span>|<span class="docEmphasis">secret</span>. This is called a <span class="docEmphStrong">keyed hash</span>. Alice then sends the hash and the message (without the secret) to Bob. Bob concatenates the secret to the received message and computes the hash of the result. If that matches the received hash, Bob can have confidence the message was sent by someone knowing the secret. [Note: there are some cryptographic subtleties to making this actually secure; see &sect;<a class="docLink" href="ch05lev1sec2.html#ch05lev2sec2">5.2.2</a> <span class="docEmphasis">Computing a MAC with a Hash</span>].</p>
<a name="f056fig01"></a>
<p class="docText">
<img border="0" alt="" width="450" height="110" src="056fig01.jpg" /></p>
<a name="ch02lev2sec19"></a>
<h4 id="title-IDAZRG5H" class="docSection2Title">2.6.3. Message Fingerprint</h4>
<p class="docText">If you want to know whether some large data structure (e.g. a program) has been modified from one day to the next, you could keep a copy of the data on some tamper-proof backing store and periodically compare it to the active version. With a hash function, you can save storage: you simply save the message digest of the data on the tamper-proof backing store (which because the hash is small could be a piece of paper in a filing cabinet). If the message digest hasn't changed, you can be confident none of the data has.</p>
<p class="docText">A note to would-be usersÂif it hasn't already occurred to you, it has occurred to the bad guysÂthe program that computes the hash must also be independently protected for this to be secure. Otherwise the bad guys can change the file but also change the hashing program to report the checksum as though the file were unchanged!</p>
<a name="ch02lev2sec20"></a>
<h4 id="title-IDAKSG5H" class="docSection2Title">2.6.4. Downline Load Security</h4>
<p class="docText">It is common practice to have special-purpose devices connected to a network, like routers or printers, that do not have the nonvolatile memory to store the programs they normally run. Instead, they keep a bootstrap program smart enough to get a program from the network and run it. This scheme is called <span class="docEmphStrong">downline load</span>.</p>
<p class="docText">Suppose you want to downline load a program and make sure it hasn't been corrupted (whether intentionally or not). If you know the proper hash of the program, you can compute the hash of the loaded program and make sure it has the proper value before running the program.</p>
<a name="ch02lev2sec21"></a>
<h4 id="title-IDA3SG5H" class="docSection2Title">2.6.5. Digital Signature Efficiency</h4>
<p class="docText">The best-known public key algorithms are sufficiently processor-intensive that it is desirable to compute a message digest of the message and sign that, rather than to sign the message directly. The message digest algorithms are much less processor-intensive, and the message digest is much shorter than the message.</p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>